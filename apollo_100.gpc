/*

												 			Fortnite: Apollo


														Author:		Swedemafia
														Script:		Apollo
														Version:	1.00 [BETA]
														Build Date:	5 April 2023
														Support:	https://discord.gg/tZBxJmWmZh
														
														
							REQUIREMENTS:
								* Zen Studio (current version: v1.3.1 Beta 11).
								* In Zen Studio, 'Use Legacy 16Bit Compiler' found in the Device tab *MUST* be disabled.
							
							SUPPORT:
								* https://discord.gg/tZBxJmWmZh
								
							README:
								* https://docs.google.com/document/d/1Nr-5NGz4RUFCZ-udhOYNje_S2aqatiZ5quJoN4L2qc8
							
							FEATURES:
								* Aim Assist, Rotation Assist, Inverse Assist, Idle Target Asist, Motion Assist, Shape Pulse, Shape Spin
									- Customize to your personal preference or use default settings.
									- Thousands of possible Aim Assist setting combinations.
								* Anti-drift
									- Got stick drift?  No problem.  You can run the lowest in-game deadzone and have no stick drift at all.
									- Unique feature only found in scripts from this developer.
									- Quick & easy calibration process to determine your stick drift so the script will cancel it out.
								* Anti-recoil
									- Adjustable Strength.
								* Auto Ping
									- Select Ping Once on Fire or select an interval to repeatedly ping at when firing.
								* Hair Triggers
									- Enable hair triggers for your controller.
								* Rapid Fire
									- Using a semi-automatic weapon, choose how many Shots per Second you wish to fire by holding your trigger.

							MISCELLANEOUS:
								* Compatible for Inverted players.
								* Support for Toggles (set a HOLD button + DOUBLE-TAP button) to quickly enable/disable Options.
								
							NAVIGATION:
								* Enter script menu:
									* Hold LT and press Menu (Xbox).
									* Hold L2 and press Options (PlayStation).
								* Enter Anti-recoil Quick Edit or Weapon Select Menu
									* Hold LT and press View (Xbox).
									* Hold L2 and press Share (PlayStation).
								* Selecting values to edit or enabling/disabling Options
									* Press Up or Down.
								* Editing values
									* Hold LT/L2 and press Right/Left (cycle setting/increase by 1/decrease by 1).
									* Hold LT/L2 and press Up/Down (increase by 10/decrease by 10).
								* Save Settings
									* Press B/Circle until your Cronus Zen device says "Settings Saved."
									
							CHANGE LOG:
								[Version 1.00] - Initial public release
									
									
*/


/**************************************************************/
//	Author
/**************************************************************/
define DEVELOPER = FALSE;
const string author = "Swedemafia";
const string script = "Apollo";
const string version = "Beta v1.00";

/**************************************************************/
//	Variables
/**************************************************************/

// (Aim Assist) Variables
int aimAssistShapeMin, aimAssistShapeMax, aimAssistRandomShape;
int aimAssistAngle, aimAssistRadius, aimAssistShape, aimAssistSpeed, aimAssistX, aimAssistY;
// (Aim Assist) Activation flags
int assistFlags;
// (Aim Assist) Stick values for Type
int polarStick, polarValue;
// (Aim Assist) Idle Target Assist
int idleTargetEngaged, idleTargetTimer;
// (Aim Assist) Rotation Assist
int rotationAngle, rotationCounter, rotationType, rotationSpeed, rotationDirection, rotationRadius, rotationRandomShape;
// (Aim Assist) Shape Motion
int motionAngle, motionShape, motionRadius, motionSpeed, motionX, motionY;
// (Aim Assist) Shape Pulse
int pulseRadius, pulseDirection;
// (Aim Assist) Shape Spin
int spinX, spinY, spinAngle, spinSpeed, spinType;

// (Anti-drift)
int antiDriftStickValue;
int antiDriftHighValue, antiDriftLowValue;
int antiDriftCalibrationHigh, antiDriftCalibrationLow;
int antiDriftCalibrationRangeValue, antiDriftCalibrationValue;
int antiDriftCalibrationInRange, antiDriftCalibrationCanSet, antiDriftCalibrationState;
int antiDriftCalibrationStick, antiDriftCalibrationDirection, antiDriftCalibrationPolarStick;

// (Anti-recoil)
int antiRecoilQuickEdit;
int antiRecoilY, antiRecoilCounterY;

// (Controller) Button and Stick Layout
int build[7], combat[14], stick[4];
// (Controller) Current ADS & Fire button values
int holdingADS, holdingFire;

// (Display)
int displayBuffer, displayDepth, displayUpdate, displayBufferInsertCopyValue, displayBufferInsertNumberOfDigits, displayBufferInsertDigits[5];
// (Display) Script state
int scriptPaused;

// (Menu) Edit Menu data
int editMenuType, editMenuAdsType, editMenuVariable1, editMenuVariable2, editMenuParent, editMenuMinValue, editMenuMaxValue, editMenuAdsMinValue, editMenuAdsMaxValue;
// (Menu) Edit Menu variables
int editMenuEventChangeTime, editMenuIndex, editMenuSelectedRow;
// (Menu) Mod Menu index
int modMenuIndex;

// (Miscellaneous) Loop iterators
int i, j;

// (Options) Edit assist
int editAssist;
// (Options) Build Tracker / Harvesting
int tracker;
int autoHarvest, enteringHarvest;
int disableHarvestToggle;

// (Screen saver) State
int screenSaverEnabled, screenSaverCounter;
// (Screen saver) Script uptime
int uptimeCounter, uptimeDays, uptimeHours, uptimeMinutes, uptimeSeconds;

// (Settings) Smoothing
int forecast_x, forecast_y;

// User-defined configuration data
int userData[89];

enum {
	/* Aim Assist */
	vAimAssist, vAimAssistType,
	vAimAssistAdsShape, vAimAssistFireShape,
	vAimAssistAdsRadius, vAimAssistFireRadius,
	vAimAssistAdsSpeed, vAimAssistFireSpeed,
	
	/* Rotation Assist */
	vRotationAssist,
	vRotationAdsShape, vRotationFireShape,
	vRotationAdsRadius, vRotationFireRadius,
	vRotationAdsSpeed, vRotationFireSpeed,
	
	/* Inverse Assist */
	vInverseAssist, vInverseAssistThreshold,
	
	/* Idle Target Assist */
	vIdleTargetAssist,
	vIdleTargetShape, vIdleTargetTime, vIdleTargetRadius, vIdleTargetSpeed,
	
	/* Motion Assist */
	vMotionAssist,
	vMotionAdsShape, vMotionFireShape,
	vMotionAdsRadius, vMotionFireRadius,
	vMotionAdsSpeed, vMotionFireSpeed,
	
	/* Shape Pulse */
	vShapePulse,
	vShapePulseAdsRadius, vShapePulseFireRadius,
	
	/* Shape Spin */
	vShapeSpin,
	vShapeSpinAdsType, vShapeSpinFireType,
	vShapeSpinAdsAngle, vShapeSpinFireAngle,
	
	/* Anti-drift */
	vAntiDrift, vAntiDriftLeft, vAntiDriftRight = 42,
	
	/* Anti-recoil */
	vAntiRecoil = 46, vAntiRecoilStrength, vAntiRecoilKickStrength, vAntiRecoilKickDuration,
	
	/* Controller */
	vControllerConfiguration, vControllerEditHoldTime, vControllerEditPressType, vControllerHarvestPressType, vControllerButton, /* 12 buttons */
	
	/* Options */
	vOptionAutoHarvest = 66,
	vOptionAutoPing, vOptionAutoPingInterval,
	vOptionBuildTracker,
	vOptionEditAssist,
	vOptionFastReset,
	vOptionHairTriggers,
	vOptionInstantPickaxe,
	vOptionRapidFire, vOptionRapidFireSpeed,
	vOptionButton, /* 3 buttons */
	
	/* Settings */
	vBlockRumble = 79, vDeadzone,
	vInverted = 82, vScreenSaver, vSmoothing, vVMSpeed,
	vToggleButton
}

// Menu Data IDs
enum { menuType, menuAdsType, menuVariable1, menuVariable2, menuParent, menuMinValue, menuMaxValue, menuAdsMinValue, menuAdsMaxValue }
// Menu Type
enum { menuNone, menuAntiDriftCalibrate, menuAssistDualSelection, menuAssistRowSelection, menuCycleListOption, menuMultiSelection, menuToggle, menuToggleOnOff }
// Menu Type ADS
enum { menuAdsNone, menuAdsAssistDualSelection, menuAdsDualSelectionEdit, menuAdsAntiDriftCalibrate, menuAdsCycleEditValue, menuAdsCycleListOption, menuAdsMultiSelection, menuAdsToggle, menuWeaponSelectionEdit }

const int16 menuData[][] = {
/* Menu ID		  Menu type (No ADS)		Menu type w/ ADS    		Value 1				Value 2					Parent value 		Min			Max						Ads Min		Ads Max
/* AA */ 		{ menuCycleListOption, 		menuAdsNone, 				vAimAssist, 		-1,						-1,					assistOff, 	assistAdsAndFireOrAds,	-1,			-1 },
/* AAType */ 	{ menuCycleListOption, 		menuAdsNone, 				vAimAssistType, 	-1, 					-1,					aat_mRadius, aat_pRadius,			-1,			-1 },
/* AAShape */	{ menuAssistDualSelection, 	menuAdsAssistDualSelection,	vAimAssistAdsShape, vAimAssistFireShape, 	vAimAssist,			aasCircle, 	aasEcstasy, 				aasCircle, 	aasEcstasy },
/* AARadius */	{ menuAssistRowSelection, 	menuAdsDualSelectionEdit,	vAimAssistAdsRadius,vAimAssistFireRadius, 	vAimAssist, 		1, 			100,					1,			100 },
/* AASpeed */	{ menuAssistRowSelection, 	menuAdsDualSelectionEdit,	vAimAssistAdsSpeed, vAimAssistFireSpeed, 	vAimAssist, 		1, 			100,					1,			100 },
	
/* RA */		{ menuCycleListOption,		menuAdsNone,				vRotationAssist,	-1						,-1,				assistOff,	assistAdsAndFireOrAds,	-1,			-1 },
/* RAShape */	{ menuAssistDualSelection,	menuAdsAssistDualSelection,	vRotationAdsShape,	vRotationFireShape,		vRotationAssist,	rasStrafe,	rasRandom, 				rasStrafe,	rasRandom },
/* RARadius*/	{ menuAssistRowSelection,	menuAdsDualSelectionEdit,	vRotationAdsRadius,	vRotationFireRadius,	vRotationAssist, 	1, 			100,					1,			100 },
/* RASpeed*/	{ menuAssistRowSelection,	menuAdsDualSelectionEdit,	vRotationAdsSpeed,	vRotationFireSpeed,		vRotationAssist,	1, 			120,					1,			120 },

/* IA */		{ menuCycleListOption,		menuAdsCycleEditValue,		vInverseAssist,		vInverseAssistThreshold,-1,					assistOff,	assistAdsAndFireOrAds,	0,			100 },

/* ITA */		{ menuToggle,				menuAdsNone,				vIdleTargetAssist,	-1,						-1,					assistOff, 	assistOn,				-1,			-1 },
/* ITShape */	{ menuCycleListOption,		menuAdsNone,				vIdleTargetShape,	-1,						-1,					aasCircle,	aasEcstasy,				-1,			-1  },
/* ITTime */	{ menuNone,					menuAdsCycleEditValue,		-1,					vIdleTargetTime,		-1,					-1,			-1,						0,			100 },
/* ITRadius */	{ menuNone,					menuAdsCycleEditValue,		-1,					vIdleTargetRadius,		-1,					-1,			-1,						1,			100 },
/* ITRSpeed */	{ menuNone,					menuAdsCycleEditValue,		-1,					vIdleTargetSpeed,		-1,					-1,			-1,						1,			100 },
	
/* MA */		{ menuCycleListOption,		menuAdsNone,				vMotionAssist,		-1,						-1,					assistOff, 	assistAdsAndFireOrAds,	-1,			-1 },
/* MAType */	{ menuAssistDualSelection,	menuAdsAssistDualSelection,	vMotionAdsShape,	vMotionFireShape,		vMotionAssist,		aasCircle,	aasHorizon,				aasCircle,	aasHorizon },
/* MARadius */	{ menuAssistRowSelection,	menuAdsDualSelectionEdit,	vMotionAdsRadius,	vMotionFireRadius,		vMotionAssist,		1,			100,					1,			100  },
/* MASpeed */	{ menuAssistRowSelection,	menuAdsDualSelectionEdit,	vMotionAdsSpeed,	vMotionFireSpeed,		vMotionAssist,		1,			100,					1,			100  },
	
/* SP */		{ menuCycleListOption,		menuAdsNone,				vShapePulse,		-1,						-1,					assistOff, 	assistAdsAndFireOrAds,	-1,			-1 },
/* SPRadius */	{ menuAssistRowSelection,	menuAdsDualSelectionEdit,	vShapePulseAdsRadius,vShapePulseFireRadius, vShapePulse,		1,			100,					1,			100 },
	
/* SS */		{ menuCycleListOption,		menuAdsNone,				vShapeSpin,			-1,						-1,					assistOff,	assistAdsAndFireOrAds,	-1,			-1 },
/* SSType */	{ menuAssistDualSelection,	menuAdsAssistDualSelection, vShapeSpinAdsType,	vShapeSpinFireType,		vShapeSpin,			spinOffset, spinSpinning,			spinOffset, spinSpinning },
/* SSAngle */	{ menuAssistRowSelection,	menuAdsDualSelectionEdit, 	vShapeSpinAdsAngle,	vShapeSpinFireAngle,	vShapeSpin,			1,			180,					1,			180 },
	
/* AD */		{ menuToggleOnOff,			menuAdsNone,				vAntiDrift,			-1,						-1,					-1,			-1,						-1,			-1 },
/* ADCal */		{ menuAntiDriftCalibrate,	menuAdsAntiDriftCalibrate,	-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* ADDT */		{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* ADDV */		{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
	
/* AR */		{ menuCycleListOption,		menuAdsNone,				vAntiRecoil,		-1,						-1,					antiRecoilOff, antiRecoilAdvanced,	-1,			-1 },
/* ARBasc */	{ menuNone,					menuAdsCycleEditValue,		-1,					vAntiRecoilStrength,	-1,					-1,			-1,						1,			100 },
/* ARAdvaKS */	{ menuNone,					menuAdsCycleEditValue,		-1,					vAntiRecoilKickStrength,-1,					-1,			-1,						1,			100 },
/* ARAdvaKD */	{ menuNone,					menuAdsCycleEditValue,		-1,					vAntiRecoilKickDuration,-1,					-1,			-1,						1,			200 },

/* CtrlConfig*/	{ menuCycleListOption,		menuAdsNone,				vControllerConfiguration, -1,				-1,					oldSchool, customLayout,			-1,			-1 },
/* CtlEdtHldTm*/{ menuNone,					menuAdsCycleEditValue,		-1,					vControllerEditHoldTime,-1,					-1,			-1,						100,		250 },
/* AdsBtn*/		{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* AttackBtn*/	{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* BldMdeBtn*/	{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* ConfrmBtn*/	{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* EditBtn*/	{ menuCycleListOption,		menuAdsNone,				vControllerEditPressType,-1,				-1,					buttonTap,	buttonHold,				-1,			-1 },
/* HrvstBtn*/	{ menuCycleListOption,		menuAdsNone,				vControllerHarvestPressType,-1,				-1,					buttonTap,	buttonHold,				-1,			-1 },
/* InvtryBtn*/	{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* NextWpnBtn*/	{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* PingBtn*/	{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* PrevWpnBtn*/	{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* ResetBtn*/	{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* SelectBtn*/	{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },

/* AutoHrvst */	{ menuToggleOnOff,			menuAdsNone,				vOptionAutoHarvest,	-1,						-1,					0,			1,						-1,			-1 },
/* AutoPing */	{ menuToggleOnOff,			menuAdsCycleEditValue,		vOptionAutoPing,	vOptionAutoPingInterval,-1,					-1,			-1,						0,			8 },
/* BuildTckr*/	{ menuToggle,				menuAdsNone,				vOptionBuildTracker,-1,						-1,					0,			1,						-1,			-1 },
/* EditAsst*/	{ menuToggleOnOff,			menuAdsNone,				vOptionEditAssist,	-1,						-1,					-1,			-1,						-1,			-1 },
/* FastReset*/	{ menuCycleListOption,		menuAdsNone,				vOptionFastReset,	-1,						-1,					resetOff,	resetRepeat,			-1,			-1 },
/* HairTrig*/	{ menuToggleOnOff,			menuAdsNone,				vOptionHairTriggers,-1,						-1,					-1,			-1,						-1,			-1 },
/* InsntPkax*/	{ menuToggleOnOff,			menuAdsNone,				vOptionInstantPickaxe,-1,					-1,					-1,			-1,						-1,			-1 },
/* RpdFire */	{ menuToggleOnOff,			menuAdsCycleEditValue,		vOptionRapidFire,	vOptionRapidFireSpeed,	-1,					-1,			-1,						1,			60 },

/* BlckRmbl*/	{ menuToggleOnOff,			menuAdsNone,				vBlockRumble,		-1,						-1,					-1,			-1,						-1,			-1 },
/* Deadzone*/	{ menuMultiSelection,		menuAdsMultiSelection,		-1,					vDeadzone,				-1,					0,			1,						5,			15 },
/* Inverted*/	{ menuToggleOnOff,			menuAdsNone,				vInverted,			-1,						-1,					-1,			-1,						-1,			-1 },
/* ScreenSvr*/	{ menuCycleListOption,		menuAdsNone,				vScreenSaver,		-1,						-1,					screenSaverOff,	screenSaverVisualizer, -1,		-1 },
/* Smoothing*/	{ menuToggleOnOff,			menuAdsNone,				vSmoothing,			-1,						-1,					-1,			-1,						-1,			-1 },
/* VMSpeed*/	{ menuCycleListOption,		menuAdsNone,				vVMSpeed,			-1,						-1,					vmSpeed4,	vmSpeed10,				-1,			-1 },

/* T-APing*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-RpdFire*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 }

}

/**************************************************************/
//	Enumerations
/**************************************************************/
// (Aim Assist) Aim Assist Type IDs
enum { aat_mRadius, aat_mSpeed, aat_mRadius_mSpeed, aat_mRadius_pSpeed, aatSteady, aat_pRadius_mSpeed, aat_pRadius_pSpeed, aat_pSpeed, aat_pRadius }
// (Aim Assist) Shape IDs
enum { aasCircle, aasOval, aasEllipse, aasLemniscate, aasDiamond, aasHorizon, aasRose, aasHeart, aasFlower, aasOrbit, aasSpiral, aasEcstasy }
// (Aim Assist) Rotation Shape IDs
enum { rasStrafe, rasCeorin, rasCircle, rasOval, rasEllipse, rasLemniscate, rasDiamond, rasRandom }
// (Aim Assist) Aim/Rotation/Idle Target Assist status IDs
enum { assistOff, assistAdsOnly, assistFireOnly, assistAdsAndFire, assistAdsOrFire, assistAdsAndFireOrFire, assistAdsAndFireOrAds, assistOn }
// (Aim Assist) Spin Type IDs
enum { spinOffset, spinSpinning }

// (Anti-drift) Calibration direction
enum { antiDriftUp, antiDriftDown, antiDriftLeft, antiDriftRight }
// (Anti-drift) Calibratoin stick
enum { antiDriftLeftStick, antiDriftRightStick }

// (Anti-recoil) Status IDs
enum { antiRecoilOff, antiRecoilBasic, antiRecoilAdvanced }

// (Controller) Custom buttons
enum { ads_button, attack_button, build_mode_button, confirm_button, edit_button, harvest_button, inventory_button, next_weapon_button, ping_button, previous_weapon_button, reset_button, select_button }
// (Controller) Combat Controls IDs
enum { ads, attack, previous_weapon, next_weapon, harvest, interact, build_mode, jump, slide, sprint, inventory, emote, ping, augment }
// (Controller) Configuraiton IDs
enum { oldSchool, quickBuilder, combatPro, builderPro, customLayout }
// (Controller) Build Controls IDs
enum { stair, roof, wall, floor, trap, edit, rotate_repair_reset }
// (Controller) Button response type
enum { buttonTap, buttonHold }
// (Controller) Stick layout IDs
enum { moveY, moveX, aimY, aimX }

// (Display) Formatting IDs
enum { displayString, displayNumber }
// (Display) Text formatting & alignment IDs
enum { alignCenter = -2, alignRight, alignLeft = 5, alignBottom = -1, alignTop = 5 }
// (Display) Home screen message IDs
enum { homeScriptName, homeScriptVersion }
// (Display) LED color IDs
enum { red, orange, gold, white, yellow, green, teal, blue, purple, pink }
// (Display) LED (HSB) IDs
enum { hue, saturation, brightness }

// (Menu) Cycle value IDs
enum { cycleValueUp, cycleValueDown }
// (Menu) Edit menu navigation & event IDs
enum { editMenuMin, editMenuMax, editMenuShowProfile }
// (Menu) Mod navigation
enum { modMenuPrevious, modMenuCurrent, modMenuNext, modMenuDown, modMenuUp, modMenuEnter, modMenuExit }

// (Options) Build Tracker
enum { harvestTracker = 1, buildTracker = 2, mapTracker = 4, settingsTracker = 8, inventoryTracker = 16 }
// (Options) Fast Reset
enum { resetOff, resetOnce, resetRepeat }
// (Options) Quick Buttons
enum { buttonAutoHarvest, buttonEditAssist, buttonFastReset }

// (Settings) Deadzone IDs
enum { deadzoneLeft, deadzoneRight }
// (Settings) Screen saver IDs
enum { screenSaverOff, screenSaverBlank, screenSaverUptime, screenSaverVisualizer }
// (Settings) VM speed IDs
enum { vmSpeed4, vmSpeed6, vmSpeed8, vmSpeed10 }

// (Toggle) Array IDs
enum { toggleAutoPing = 0, toggleRapidFire = 2 }

/**************************************************************/
//	Constants (strings)
/**************************************************************/

// (Aim Assist) Aim Assist Type
const string aimAssistTypeName[] = { "-Radius", "-Speed", "-Radius/-Speed", "-Radius/+Speed", "Constant", "+Radius/-Speed", "+Radius/+Speed", "+Speed", "+Radius" }
// (Aim Assist) Aim/Rotation/Idle Target Assist status
const string assistStatus[] = { "Off", "ADS Only", "Fire only", "ADS & Fire", "ADS or Fire", "ADS & Fire / Fire", "ADS & Fire / ADS", "On" }
// (Aim Assist) Shapes
const string aimAssistShapeName[] = { "Circle", "Oval", "Ellipse", "Lemniscate", "Diamond", "Horizon", "Rose", "Heart", "Flower", "Orbit", "Spiral", "Ecstasy" }
// (Aim Assist) Rotation Shape
const string aimAssistRotationShape[] = { "Strafe", "Ceorin", "Circle", "Oval", "Ellipse", "Lemniscate", "Diamond", "Random"  }
// (Aim Assist) Rotation Type Threshold
const string aimAssistRotationThreshold[] = { "Threshold: ", "none" }
// (Aim Assist) Idle Target Assist prompt
const string aimAssistIdleTarget = "Instant"
// (Aim Assist) Type prompt
const string aimAssistTypeMsg[] = { "ADS: ", "Fire: " }
// (Aim Assist) Shape Spinner
const string aimAssistSpinType[] = { "Offset", "Spinning" }

// (Anti-drift) Calibration direction
const string antiDriftCalibrationDirectionPrompt[] = { "Direction: Up", "Direction: Down", "Direction: Left", "Direction: Right" }
// (Anti-drift) Calibration prompt
const string antiDriftCalibrationResult[] = { "Failed", "Success", "Cancelled", "Reset Value" }
// (Anti-drift) Calibration state
const string antiDriftCalibrationStateMsg[] = { "Press A/Cross", "Waiting", "Release Joystick" }
// (Anti-drift) Calibration stick
const string antiDriftCalibrationStickPrompt[] = { "Joystick: Left", "Joystick: Right" }
// (Anti-drift) Values display
const string antiDriftValues[] = { "U: ", "D: ", "L: ", "R: " }

// (Anti-recoil) Strength
const string antiRecoilType[] = { "Off", "Basic", "Advanced" }

// (Controller) Configuration
const string controller[] = { "Old School", "Quick Builder", "Combat Pro", "Builder Pro", "Custom" }
// (Controller) Button names [PlayStation]
const string controllerButtonsPS4[] = { "not set", "", "", "R1", "R2", "R3", "L1", "L2", "L3", "", "", "", "", "Up", "Down", "Left", "Right", "Triangle", "Circle", "Cross", "Square" }
// (Controller) Button names [XBOX]
const string controllerButtonsXBOX[] = { "not set", "", "", "RB", "RT", "RS", "LB", "LT", "LS", "", "", "", "", "Up", "Down", "Left", "Right", "Y", "B", "A", "X" }
// (Controller) Button Press Type
const string buttonPressType[] = { "Tap Button", "Hold Button" }

// (Display) Greeting
const string apollo[] = { "APOLLO" };
// (Display) On/off Toggle
const string toggleOffOn[] = { "Off", "On" }
// (Display) Script paused notification
const string scriptPausedMsg = "Paused";

// (Options) Auto Ping
const string autoPing[] = { "Interval: ", "Ping Once on Fire" }
// (Options) Edit Assist/Fast Reset
const string buttonToUse[] = { "Button: " }
// (Options) Fast Reset
const string fastReset[] = { "Off", "Reset Once", "Repeat Reset" }
// (Options) Fire Speed
const string fireSpeed = "Shots/Second: "
// (Options) Build Tracker
const string trackerMsg[] = { "Building", "Harvesting", "Map", "Settings", "Auto Harvest", "Inventory" }

// (Settings) Deadzone prompt
const string stickName[] = { "Left: ", "Right: " }
// (Settings) Screen saver names
const string screenSaver[] = { "Off", "Blank", "Uptime", "Visualizer" }
// (Settings) VM speed display
const string vmSpeed[] = { "4ms", "6ms", "8ms", "Default (10ms)" }
// (Settings) Settings saved notification
const string settingsSaved = "Settings Saved";

// (Toggles) Toggle combo messages
const string toggles[] = { "Button 1: ", "Button 2: " }
// (Toggles) Toggle display messages
const string toggleMessages[] = { "Auto Ping: ", "Rapid Fire: " }
// (Toggles) Reset Message
const string toggleReset[] = {  "Reset: Hold Share", "Reset: Hold View" }

/**************************************************************/
//	Constants (integers)
/**************************************************************/

// (Controller) Available toggle buttons
const int8 controllerButtons[] = { XB1_VIEW, XB1_RB, XB1_RT, XB1_RS, XB1_LB, XB1_LT, XB1_LS, XB1_UP, XB1_DOWN, XB1_LEFT, XB1_RIGHT, XB1_Y, XB1_B, XB1_A, XB1_X }
// (Controller) Build Controls layout IDs
const int8 buildLayoutMap[][] = {
	{ XB1_LB, XB1_LB, XB1_LB, XB1_LB, XB1_X, XB1_B, XB1_RS }, // Old School
	{ XB1_RB, XB1_RB, XB1_RB, XB1_RB, XB1_Y, XB1_B, XB1_RS }, // Quick Builder
	{ XB1_RB, XB1_RB, XB1_RB, XB1_RB, XB1_X, XB1_B, XB1_RS }, // Combat Pro
	{ XB1_LT, XB1_LB, XB1_RT, XB1_RB, XB1_X, XB1_B, XB1_RS } // Builder Pro
}
// (Controller) Combat Controls layout IDs
const int8 combatLayoutMap[][] = {
	{ XB1_LT, XB1_RT, XB1_Y, XB1_Y, XB1_Y, XB1_X, XB1_B, XB1_A, XB1_LB, XB1_LS, XB1_VIEW, XB1_DOWN, XB1_LEFT, XB1_RIGHT }, // Old School
	{ XB1_LT, XB1_RT, XB1_Y, XB1_Y, XB1_Y, XB1_X, XB1_B, XB1_A, XB1_LB, XB1_LS, XB1_VIEW, XB1_DOWN, XB1_LEFT, XB1_RIGHT }, // Quick Builder
	{ XB1_LT, XB1_RT, XB1_LB, XB1_RB, XB1_Y, XB1_X, XB1_B, XB1_A, XB1_RS, XB1_LS, XB1_UP, XB1_DOWN, XB1_LEFT, XB1_RIGHT }, // Combat Pro
	{ XB1_LT, XB1_RT, XB1_LB, XB1_RB, XB1_Y, XB1_X, XB1_B, XB1_A, XB1_RS, XB1_LS, XB1_UP, XB1_DOWN, XB1_LEFT, XB1_RIGHT } // Builder Pro
}

// (Display) HSB color values
const int16 colorValues[][] = {
	{ 0, 100, 75 }, { 10, 100, 75 }, { 17, 100, 100 }, { 20, 50, 100 },  { 30, 100, 100 },
	{ 120, 100, 75 },  { 135, 100, 75 }, { 200, 100, 50 },  { 300, 100, 50 }, { 359, 50, 75 }
}
// (Display) Menu action buttons
const uint8 menuButtons[] = {  XB1_UP, XB1_DOWN, XB1_LEFT, XB1_RIGHT, XB1_A, XB1_B, XB1_RB, XB1_LB, XB1_VIEW }
// (Display) Line numbers for OLED_FONT_SMALL
const int8 lineNumber[] = { 22, 34, 46 }
// (Display) Font height
const int8 fontHeight[] = { OLED_FONT_SMALL_HEIGHT, OLED_FONT_MEDIUM_HEIGHT, OLED_FONT_LARGE_HEIGHT }
// (Display) Font width
const int8 fontWidth[] = { OLED_FONT_SMALL_WIDTH, OLED_FONT_MEDIUM_WIDTH, OLED_FONT_LARGE_WIDTH }

// (Setings) VM Speed
const int8 vmSpeedValue[] = { -6, -4, -2, 0 }

/**************************************************************/
//	Edit Menu
/**************************************************************/

// (Menu) Edit Menu IDs
enum {
	// Aim Assist
	editMenuAimAssist, editMenuAimAssistBoost, editMenuAimAssistShape, editMenuAimAssistRadius, editMenuAimAssistSpeed,
	/* Rotation Assist  */	editMenuRotationAssist, editMenuRotationShape, editMenuRotationRadius, editMenuRotationSpeed,
	/* Inverse Assist */	editMenuInverseAssist,
	/* Idle Target */		editMenuIdleTargetAssist, editMenuIdleTargetShape, editMenuIdleTargetTime, editMenuIdleTargetRadius, editMenuIdleTargetSpeed,
	/* Shape Motion */		editMenuMotionAssist, editMenuMotionShape, editMenuMotionRadius, editMenuMotionSpeed,
	/* Shape Pulse */		editMenuShapePulse, editMenuShapePulseRadius,
	/* Shape Spin */		editMenuShapeSpin, editMenuShapeSpinType, editMenuShapeSpinAngle,
	//
	// Anti-drift
	editMenuAntidrift, editMenuAntidriftCalibration, editMenuAntidriftTest, editMenuAntidriftValues,
	// Anti-recoil
	editMenuAntiRecoil,
	/* Basic */ 			editMenuAntiRecoilStrength,
	/* Advanced */			editMenuAntiRecoilKickStrength, editMenuAntiRecoilKickDuration,
	//
	// Controller
	editMenuControllerConfiguration, editMenuControllerEditHoldTime,
		editMenuControllerADSButton, editMenuControllerAttackButton, editMenuControllerBuildModeButton, editMenuControllerConfirmButton, editMenuControllerEditButton,
		editMenuControllerHarvestButton, editMenuControllerInventoryButton, editMenuControllerNextWeaponButton, editMenuControllerPingButton,
		editMenuControllerPreviousWeaponButton, editMenuControllerResetButton, editMenuControllerSelectButton,
	// Options
	editMenuOptionsAutoHarvest, editMenuOptionsAutoPing, editMenuOptionsBuildTracker, editMenuOptionsEditAssist, editMenuOptionsFastReset,
	editMenuOptionsHairTriggers, editMenuOptionsInstantPickaxe, editMenuOptionsRapidFire,
	// Settings
	editMenuSettingsBlockRumble, editMenuSettingsDeadzone, editMenuSettingsInverted, editMenuSettingsScreenSaver, editMenuSettingsSmoothing, editMenuSettingsVMSpeed,
	// Toggles
	editMenuToggleAutoPing, editMenuToggleRapidFire
}

// (Menu) Edit Menu names
const string editMenuNames[] = {
	/* Aim Assist */			"Aim Assist", "Aim Assist Type", "Aim Assist Shape", "Aim Assist Radius", "Aim Assist Speed",
	/* Rotation Assist */		"Rotation Assist", "Rotation Shape", "Rotation Radius", "Rotation Speed",
	/* Inverse Assist */		"Inverse Assist",
	/* Idle Target Assist */	"Idle Target Assist", "Idle Target Shape", "Idle Target Time", "Idle Target Radius", "Idle Target Speed",
	/* Motion Assist */			"Motion Assist", "Motion Shape", "Motion Radius", "Motion Speed",
	/* Shape Pulse */			"Shape Pulse", "Pulse Radius",
	/* Shape Spin */			"Shape Spin", "Spin Type", "Spin Angle",
	//
	// Anti-drift
	"Anti-drift", "Calibration", "Drift Test", "Drift Values",
	// Anti-recoil
	"Anti-recoil",
	/* Basic */					"Strength",
	/* Advanced */				"Kick Strength", "Kick Duration",
	// Controller
	"Configuration", "Edit Hold Time",
		/* Custom */	"ADS Button", "Attack Button", "Build Mode Button", "Confirm Button", "Edit Button",
						"Harvest Button", "Inventory Btn", "Next Weapon Btn", "Ping Button", "Prev Weapon Btn", "Reset Button", "Select Button",
	// Options
	"Auto Harvest", "Auto Ping", "Build Tracker", "Edit Assist", "Fast Reset", "Hair Triggers", "Instant Pickaxe", "Rapid Fire",
	// Settings
	"Block Rumble", "Deadzone", "Inverted", "Screen Saver", "Smoothing", "VM Speed",
	// Toggles
	"Auto Ping", "Rapid Fire"
}

// (Menu) Edit Menu items
const int8 editMenuItems[][] = {
	  // Menu			Head							Tail
	{ /* Aim Assist */ 	editMenuAimAssist, 				editMenuShapeSpinAngle			},
	{ /* Anti-drift */ 	editMenuAntidrift, 				editMenuAntidriftValues			},
	{ /* Anti-recoil */ editMenuAntiRecoil, 			editMenuAntiRecoilKickDuration	},
	{ /* Controller */	editMenuControllerConfiguration, editMenuControllerSelectButton	},
	{ /* Options */		editMenuOptionsAutoHarvest, 	editMenuOptionsRapidFire		},
	{ /* Settings */	editMenuSettingsBlockRumble, 	editMenuSettingsVMSpeed			},
	{ /* Toggles */		editMenuToggleAutoPing, 		editMenuToggleRapidFire			}
}

/**************************************************************/
//	Mod Menu
/**************************************************************/

// (Menu) Mod menu IDs
enum { modMenuAimAssist, modMenuAntidrift, modMenuAntiRecoil, modMenuController, modMenuOptions,modMenuSettings, modMenuToggles }
// (Menu) Mod menu names
const string modMenuNames[] = { "Aim Assist", "Anti-drift", "Anti-recoil", "Controller", "Options", "Settings", "Toggles" }
// (Menu) Mod menu items
const int8 modMenuItems[][] = {
	  // Menu			Previous			Data				Next
	{ /* Aim Assist */	modMenuToggles, 	modMenuAimAssist, 	modMenuAntidrift },
	{ /* Anti-drift */	modMenuAimAssist, 	modMenuAntidrift, 	modMenuAntiRecoil },
	{ /* Anti-recoil */	modMenuAntidrift, 	modMenuAntiRecoil, 	modMenuController },
	{ /* Controller */	modMenuAntiRecoil, 	modMenuController, 	modMenuOptions },
	{ /* Options */		modMenuController, 	modMenuOptions, 	modMenuSettings },
	{ /* Settings */	modMenuOptions, 	modMenuSettings, 	modMenuToggles },
	{ /* Toggles */		modMenuSettings, 	modMenuToggles,	 	modMenuAimAssist }
}

/**************************************************************/
//	Begin script
/**************************************************************/
init {
	// Initialize menu min/max
	aimAssistShapeMin = aasCircle;
	aimAssistShapeMax = aasEcstasy;
	
	displayBuffer = 1; // Initialize display buffer
	loadSettings(); // Load user-defined settings
	combo_run(cboGreeting); // Run greeting
}

main {
	calculateUptime(); // Calculate uptime
	if(!displayDepth && !combo_running(cboGreeting)) { // Home screen
		swapPS4(); // Fix PS4 issue
		if(!checkPause()) { // Do not do anything if any specific combos are running
			if(!checkCombos()) {
				// Check for Screen Saver, otherwise display Home Screen
				if(!screenSaverEnabled) {
					if(!screenSaverCounter) {
						displayHomeScreen(); // Display Home Screen
						vm_tctrl(vmSpeedValue[userData[vVMSpeed]]); // Set VM speed
						screenSaverCounter = 1; // Prevent from constant update
					} else if(screenSaverCounter >= 2000) {
						screenSaverEnabled = TRUE; // Enable Screen Saver
						cls_oled(OLED_BLACK); // Clear screen
					}
					if(userData[vScreenSaver] != screenSaverOff) {
						screenSaverCounter += get_rtime(); // Increase Screen Saver counter
					}
				} else if(userData[vScreenSaver] != screenSaverVisualizer) {
					displayScreenSaver(); // Display Screen Saver
				}

				// Check for menu action
				if(get_ival(XB1_LT)) {
					if(!antiRecoilQuickEdit) {
						// Determine menu to enter, if any
						if(event_press(XB1_MENU)) {
							changeDisplayDepth(1);
						} else if(event_press(XB1_VIEW)) {
							changeDisplayDepth(2);
							antiRecoilQuickEdit = TRUE;
							modMenuIndex = modMenuAntiRecoil; // Set mod menu ID
							editMenuIndex = editMenuAntiRecoil;
						} else if(event_press(XB1_LS) && userData[vOptionBuildTracker]) {
							if(!tracker) {
								tracker = harvestTracker;
							} else if(tracker == harvestTracker) {
								tracker = buildTracker;
							} else if(tracker == buildTracker) {
								tracker = mapTracker;
							} else if(tracker == mapTracker) {
								tracker = settingsTracker;
							} else if(tracker == settingsTracker) {
								tracker = inventoryTracker;
							} else if(tracker == inventoryTracker) {
								tracker = 0;
							}
							displayUpdate = TRUE;
						}
					}
				} else {
					if(userData[vOptionBuildTracker]) {
						if(event_press(XB1_VIEW)) {
							if(!(tracker & settingsTracker)) {
								tracker = (tracker ^ mapTracker);
								tracker = (tracker & ~inventoryTracker);
							}
							displayUpdate = TRUE;
						} else if(event_press(XB1_MENU)) {
							tracker = (tracker & ~mapTracker);
							if(tracker & inventoryTracker) {
								tracker = (tracker & ~inventoryTracker);
							} else {
								tracker = (tracker ^ settingsTracker);
							}
							displayUpdate = TRUE;
						} else if(event_press(XB1_B)) {
							tracker = (tracker & ~mapTracker);
							tracker = (tracker & ~settingsTracker);
							tracker = (tracker & ~inventoryTracker);
							displayUpdate = TRUE;
						}
					}
				}
			}

			// Remove drift and apply deadzone if calibration is not running
			if(!antiDriftCalibrationState && !displayDepth) {
				removeDriftAndApplyDeadzone(); // Remove stick drift and apply deadzone
				applySmoothing(); // Apply Exponential Smoothing
				checkOptions(); // Execute any running options
				checkTriggers(); // Get trigger state & set hair triggers
				checkAssist(); // Execute any enabled assists (Aim Assist [+etc.], Rotation Assist, Anti-Recoil)
				checkToggles(); // Execute any toggles
				checkDisplay(); // Determine LED color & prompt message (if any)
				blockActionButtons(); // Block any buttons used in toggles/profile switches
			}
		}
	} else if(displayDepth == 1) { // Mod menu
		if(!checkCombos()) {
			setLedColor(purple);
		}
		checkModMenuEvent(); // Check for mod menu events
		checkToggles(); // Check for Profile switches
	} else if(displayDepth == 2) { // Edit menu
		if(antiDriftCalibrationState) {
			// Determine stick being calibrated
			if(antiDriftCalibrationStick == antiDriftLeftStick) {
				antiDriftCalibrationPolarStick = iif(antiDriftCalibrationDirection == antiDriftUp || antiDriftCalibrationDirection == antiDriftDown, POLAR_LY, POLAR_LX);
			} else {
				antiDriftCalibrationPolarStick = iif(antiDriftCalibrationDirection == antiDriftUp || antiDriftCalibrationDirection == antiDriftDown, POLAR_RY, POLAR_RX);
			}
			checkCalibrationRange(); // Check calibration range
			setLedColor(iif(antiDriftCalibrationInRange, green, orange)); // Notify user of calibration state
			
			// Display to user "Release Joystick" if they are in range and remove if they are not
			if(antiDriftCalibrationInRange) {
				antiDriftCalibrationState = 2;
				displayUpdate = TRUE;
			} else {
				if(antiDriftCalibrationState == 2 && !antiDriftCalibrationInRange) {
					antiDriftCalibrationState = 1;
					displayUpdate = TRUE;
				}
			}
		} else {
			// Remove drift only in drift test menu
			if(editMenuIndex == editMenuAntidriftTest) {
				removeDriftAndApplyDeadzone();
			}
			if(!checkCombos()) {
				setLedColor(purple);
			}
		}
		checkEditMenuEvent(); // Check for edit menu event
	}
	
	blockMenuButtons(); // Block any buttons pressed if in a menu
	checkBlockRumble(); // Always check for blocking rumbled called for by the game
}


/**************************************************************/
//	Functions
/**************************************************************/

// This function applies Exponential Smoothing to the stick movement, if enabled
function applySmoothing() {
	if(userData[vSmoothing] && (get_ival(combat[ads]) || get_ival(combat[attack]))) {
		forecast_x = exponentialSmoothing(get_val(POLAR_RX) * 10, forecast_x); // Calculate X
		forecast_y = exponentialSmoothing(get_val(POLAR_RY) * 10, forecast_y); // Calculate Y
		set_val(POLAR_RX, forecast_x / 10); // Set X
		set_val(POLAR_RY, forecast_y / 10); // Set Y
	}
}

// Block output to controller from menu actions
function blockActionButtons() {
	// Loop through each toggle combination and block if being used
	for(i = 0; i < 4; i += 2) {
		if(userData[vToggleButton + i] && userData[vToggleButton + i + 1]) {
			if(get_val(userData[vToggleButton + i]) && get_ptime(userData[vToggleButton + i + 1]) < 250) {
				set_val(userData[vToggleButton + i + 1], 0);
			}
		}
	}
	// Block quick edit recoil and entering the menu buttons
	if(get_ival(combat[ads])) {
		set_val(XB1_MENU, 0);
		set_val(XB1_VIEW, 0);
	}
}

// Block output to controller from menu actions
function blockMenuButtons() {
	// Block all buttons while in a menu
	if(displayDepth || antiRecoilQuickEdit) {
		block_all_inputs();
	}
}

// Prepares the display buffer for a multiple item menu
function buildSelectedItemBuffer(type, message, value) {
	// Build display
	insertString(message);
	
	// Determine data type being used
	if(type == displayString) {
		insertString(value);
	} else {
		insertNumber(value);
	}
}

// Calculates the adjustment made to the left stick based on Inverse Assist threshold
function calculateRotationThresholdAdjustment(value) {
	// Determine the proper adjustment value based on stick moving left/right
	if(get_val(stick[aimX]) > 0) {
		return iif(rotationDirection, value - polarValues[userData[vInverseAssistThreshold]], inv(value - polarValues[userData[vInverseAssistThreshold]]));
	}
	
	return iif(rotationDirection, value + polarValues[userData[vInverseAssistThreshold]], inv(value + polarValues[userData[vInverseAssistThreshold]]));
}

// Calculate uptime values
function calculateUptime() {
	uptimeCounter += get_rtime();
	if(uptimeCounter >= 1000) {
		uptimeSeconds++;
		uptimeCounter -= 1000;
		if(uptimeSeconds >= 60) {
			uptimeMinutes++;
			uptimeSeconds = 0;
			if(uptimeMinutes >= 60) {
				uptimeHours++;
				uptimeMinutes = 0;
				if(uptimeHours >= 24) {
					uptimeDays++;
					uptimeHours = 0;
				}
			}
		}
	}
}

// This function changes the display depth
function changeDisplayDepth(depth) {
	displayDepth = depth; // Set display depth
	displayUpdate = TRUE; // Enable update
	screenSaverCounter = 0; // Reset Screen Saver
	screenSaverEnabled = FALSE; // Make sure Screen Saver is diabled
}

// Checks for activation based on ADS and Fire flags
function checkActivation(activation) {
	// Check activation flags
	if(activation) {
		//	ADS Only / Fire Only / ADS & Fire				ADS or Fire										(ADS & Fire / Fire)											(ADS & Fire / ADS)
		return ((activation == assistFlags) || ((activation == assistAdsOrFire) && assistFlags) || ((activation == assistAdsAndFireOrFire) && (assistFlags & 2)) || (activation == assistAdsAndFireOrAds) && (assistFlags & 1));
	}
	
	return 0;
}

// Determine which Assist mods must be executed
// - Aim Assist (+etc.), Rotation Assist, Anti-recoil
function checkAssist() {
	
	if(!tracker) {
		// Set flags (disable ADS for Akimbo)
		assistFlags = (holdingADS > 0) | ((holdingFire > 0) << 1);
		
		// Check Inverse Assist
		if(checkActivation(userData[vInverseAssist])) {
			executeInverseAssist();
		}
		
		// Check Aim Assist
		if(checkActivation(userData[vAimAssist])) {
			executeAimAssist();
		} else if (userData[vAimAssist]) {
			resetAimAssist(); // Correct aim assist
		}
		
		// Check Rotation Assist
		if(checkActivation(userData[vRotationAssist])) {
			executeRotationAssist();
		} else if(userData[vRotationAssist]) {
			rotationCounter = 0; // Reset rotation counter
			rotationDirection = 0;
		}
		
		// Check Anti-recoil
		if(userData[vAntiRecoil] && checkActivation(assistAdsAndFireOrFire)) {
			executeAntiRecoil();
		} else {
			antiRecoilCounterY = 0; // Reset vertical counter
		}
		
		assistFlags = 0; // Reset assist (aiming/firing) flags
	}
}

// Checks for rumble block state
function checkBlockRumble() {
	if(userData[vBlockRumble]) {
		block_rumble();
	}
}

// Checks the stick when in calibration mode to make sure the
// user has moved the stick to the appropriate range prior to
// releasing the stick and setting the new value
function checkCalibrationRange() {
	// Determine target range
	if((antiDriftCalibrationDirection == antiDriftLeft) || (antiDriftCalibrationDirection == antiDriftUp)) {
		antiDriftCalibrationLow = -11468; // 35
		antiDriftCalibrationHigh = -8191 // 25
	} else {
		antiDriftCalibrationLow = 8191; // 25
		antiDriftCalibrationHigh = 11468; // 35
	}
	
	// Get stick value
	antiDriftCalibrationRangeValue = get_ival(antiDriftCalibrationPolarStick);
	
	// See if stick is moved within boundaries
	if((antiDriftCalibrationRangeValue >= antiDriftCalibrationLow) && (antiDriftCalibrationRangeValue <= antiDriftCalibrationHigh)) {
		antiDriftCalibrationInRange = antiDriftCalibrationCanSet = TRUE; // Notify user it is in range and allow calibration to proceed
	} else if(((antiDriftCalibrationDirection == antiDriftLeft) || (antiDriftCalibrationDirection == antiDriftUp)) && antiDriftCalibrationRangeValue < antiDriftCalibrationLow) {
		antiDriftCalibrationCanSet = antiDriftCalibrationInRange = FALSE; // Stick moved too far, reading will be inaccurate.  Stick pulls to hard back to center
	} else if(((antiDriftCalibrationDirection == antiDriftRight) || (antiDriftCalibrationDirection == antiDriftDown)) && antiDriftCalibrationRangeValue > antiDriftCalibrationHigh) {
		antiDriftCalibrationCanSet = antiDriftCalibrationInRange = FALSE; // Stick moved too far, reading will be inaccurate.  Stick pulls to hard back to center
	} else {
		antiDriftCalibrationInRange = FALSE; // Release zone not met
	} 
}

// Checks if a status change combo is running (i.e. action failed/success)
function checkCombos() {
	if(combo_running(cboActionFailed)) {
		return TRUE;
	} else if(combo_running(cboActionSuccess)) {
		return TRUE;
	} else if(combo_running(cboSaveSettings)) {
		return TRUE;
	} else if(combo_running(cboToggleOn) || combo_running(cboToggleOff)) {
		return TRUE;
	}
	return FALSE;
}

// Determine the appropriate LED color & message to be prompted
function checkDisplay() {
	if(tracker & settingsTracker) {
		setTrackerPrompt(white, 3);
	} else if(tracker & inventoryTracker) {
		setTrackerPrompt(white, 5);
	} else if(tracker & mapTracker) {
		setTrackerPrompt(white, 2);
	} else if(tracker & buildTracker) {
		setTrackerPrompt(teal, 0);
	} else if(tracker & harvestTracker) {
		setTrackerPrompt(orange, iif(autoHarvest, 4, 1));
	} else if(!userData[vOptionRapidFire] ) {
		setLedColor(green); // Back to normal state
		if(!displayDepth && displayUpdate) {
			cls_oled(OLED_BLACK);
			displayUpdate = FALSE;
		}
	} else {
		combo_run(cboAlertRapidFire); // If Rapid Fire enabled, enable alert
	}
}

// Check and perform display update
function checkDisplayUpdate() {
	if(displayUpdate) {
		cls_oled(OLED_BLACK); // Clear display
		if(displayDepth == 1) {
			displayModMenu(); // Display mod menu
		} else if(displayDepth == 2) {
			displayEditMenu(); // Display edit menu
		}
	}
}
	
// Check for edit menu event
function checkEditMenuEvent() {
	
	checkDisplayUpdate(); // See if edit menu needs to update to the display
	
	if((modMenuIndex == modMenuController) && (userData[vControllerConfiguration] == customLayout)) {
		createToggle(vControllerButton, editMenuIndex - editMenuControllerADSButton);
		/*switch(editMenuIndex) {
			case editMenuControllerADSButton {
				createToggle(vControllerButton, ads_button);
				break;
			} case editMenuControllerAttackButton {
				createToggle(vControllerButton, attack_button);
				break;
			} case editMenuControllerBuildModeButton {
				createToggle(vControllerButton, build_mode_button);
				break;
			} case editMenuControllerConfirmButton {
				createToggle(vControllerButton, confirm_button);
				break;
			} case editMenuControllerEditButton {
				createToggle(vControllerButton, edit_button);
				break;
			} case editMenuControllerHarvestButton {
				createToggle(vControllerButton, harvest_button);
				break;
			} case editMenuControllerNextWeaponButton {
				break;
			} case editMenuControllerPingButton {
				createToggle(vControllerButton, ping_button);
				break;
			} case editMenuControllerResetButton {
				createToggle(vControllerButton, reset_button);
				break;
			} case editMenuControllerSelectButton {
				createToggle(vControllerButton, select_button);
				break;
			}
		}*/
	} else if(modMenuIndex == modMenuToggles) {
		// See if we are setting toggle combination buttons
		switch(editMenuIndex) {
			case editMenuToggleAutoPing {
				createToggle(vToggleButton, toggleAutoPing);
				break;
			} case editMenuToggleRapidFire {
				createToggle(vToggleButton, toggleRapidFire);
				break;
			}
		}
	} else if(modMenuIndex == modMenuOptions) {
		switch(editMenuIndex) {
			case editMenuOptionsAutoHarvest {
				createToggle(vOptionButton, buttonAutoHarvest);
				break;
			} case editMenuOptionsEditAssist {
				createToggle(vOptionButton, buttonEditAssist);
				break;
			} case editMenuOptionsFastReset {
				createToggle(vOptionButton, buttonFastReset);
				break;
			}
		}
	}
	
	// Check for events (only responsive to presses under 1000ms)
	for(i = 0; i < sizeof(menuButtons) / sizeof(menuButtons[0]); i++) {
		if(checkEvent(menuButtons[i])) {
			cycleEditMenu(menuButtons[i]);
		}
	}
	
	if(editMenuIndex == editMenuAntidriftTest) {
		displayUpdate = TRUE; // Constantly update display
	}
}

// Determine if an event is being called
function checkEvent(b) {
	// Check if user is holding down the button to quickly cycle through values
	if(get_ival(combat[ads]) && get_ival(b) && get_ptime(b) > 240) {
		if(editMenuEventChangeTime >= 120) {
			editMenuEventChangeTime = 0;
			return TRUE;
		} else {
			editMenuEventChangeTime += get_rtime();
			return FALSE;
		}
	}
	
	return (event_release(b) && (get_ptime(b) < 720));
}

// Check for mod menu event
function checkModMenuEvent() {
	
	checkDisplayUpdate(); // See if edit menu needs to update to the display
	
	if(event_press(XB1_DOWN)) { // Request mod menu cycle downwards
		cycleModMenu(modMenuDown);
	} else if(event_press(XB1_UP)) {// Request mod menu cycle upwards
		cycleModMenu(modMenuUp); 
	} else if(event_press(XB1_A)) { // Request enter mod menu
		cycleModMenu(modMenuEnter);
	} else if(event_release(XB1_B)) { // Exit mod menu to home screen
		cycleModMenu(modMenuExit);
	} else {
		displayUpdate = FALSE;
	}
}

// Cycles the Build Tracker state
function cycleHarvestTracker() {
	if(tracker & buildTracker) { // Check if user was building
		tracker = (tracker ^ buildTracker); // Disable it, if so
		if(!(tracker & harvestTracker)) { // Check if harvest was not enabled but build was
			tracker = (tracker | harvestTracker); // Enable it, if so 
		}
	} else {
		tracker = (tracker ^ harvestTracker); // Toggle Build Tracker
	}
	
	displayUpdate = TRUE; // Update display message
}

// Cycles the build tracker state
function checkBuildModeEvent() {
	// Perform build tracker
	if(event_press(combat[build_mode])) {
		tracker = (tracker ^ buildTracker); // Toggle build tracker
		displayUpdate = TRUE; // Update display message
	}
}

// Checks for a harvest mode event when the button must be held
function checkHarvestModeEvent() {
	if(get_ival(combat[harvest]) && (get_ptime(combat[harvest]) >= 260) && !enteringHarvest && !disableHarvestToggle && (!(tracker & harvestTracker))) {
		enteringHarvest = TRUE;
		cycleHarvestTracker();
	} else if((tracker & harvestTracker) && event_press(combat[harvest])) {
		tracker = (tracker ^ harvestTracker);
		displayUpdate = TRUE; // Update display message
		disableHarvestToggle = TRUE; 
	} else if(event_release(combat[harvest])) {
		disableHarvestToggle = FALSE;
		enteringHarvest = FALSE;
	}
}

combo cboOptionAutoHarvest {
	set_hsb(0, 0, 0);
	set_rumble(RUMBLE_A, 50);
	wait(240);
	reset_rumble();
}

int putAwayPickaxe;

// Checks for running options and executes them if enabled
function checkOptions() {
	
	// Auto Harvest
	if(userData[vOptionBuildTracker] && userData[vOptionAutoHarvest] && !displayDepth) {
		if(tracker & harvestTracker) {
			if(!autoHarvest && get_ival(combat[attack]) && get_ival(userData[vOptionButton + buttonAutoHarvest]) && (get_ptime(userData[vOptionButton + buttonAutoHarvest]) >= 750)) {
				autoHarvest = !autoHarvest;
				displayUpdate = TRUE;
				combo_run(cboOptionAutoHarvest);
			} else if(autoHarvest) {
				if(get_ival(userData[vOptionButton + buttonAutoHarvest]) && (get_ptime(userData[vOptionButton + buttonAutoHarvest]) >= 750)) {
					autoHarvest = !autoHarvest;
					displayUpdate = TRUE;
				} else if(event_press(combat[attack])) {
					autoHarvest = FALSE;
					displayUpdate = TRUE;
				} else if(event_press(combat[next_weapon]) || event_press(combat[previous_weapon])) {
					autoHarvest = FALSE;
					displayUpdate = TRUE;
				} else if(event_press(combat[harvest]) || event_press(combat[build_mode]) || event_press(build[edit])) {
					autoHarvest = FALSE;
					displayUpdate = TRUE;
				} else if(!userData[vOptionInstantPickaxe] && event_press(combat[ads])) {
					tracker = (tracker ^ harvestTracker);
					set_val(combat[harvest], 100);
					autoHarvest = FALSE;
					displayUpdate = TRUE;
				/*} else if(userData[vOptionInstantPickaxe] && get_ival(combat[ads]) && (get_ptime(combat[ads]) >= 200)) {
					tracker = (tracker ^ harvestTracker);
					set_val(combat[harvest], 100);
					autoHarvest = FALSE;
					displayUpdate = TRUE;*/
				} else {
					set_val(combat[attack], 100);
				}
			}
		}
	}
	
	// Instant Pickaxe
	if(userData[vOptionInstantPickaxe]) {
		if(tracker & harvestTracker) {
			if(event_release(combat[attack])) {
				if(putAwayPickaxe && !autoHarvest) {
					set_val(combat[harvest], 100);
					tracker = (tracker ^ harvestTracker);
					displayUpdate = TRUE;
				} else {
					putAwayPickaxe = TRUE;
				}
			} else if(!autoHarvest && get_ival(combat[attack])) {
				 if(event_release(combat[ads]) && (get_ptime(combat[ads]) < 200)) {
					putAwayPickaxe = !putAwayPickaxe;
				} else if(get_ival(combat[ads]) && (get_ptime(combat[ads]) >= 200)) {
					tracker = (tracker ^ harvestTracker);
					set_val(combat[harvest], 100);
					autoHarvest = FALSE;
					displayUpdate = TRUE;
				}
			} else if(autoHarvest) {
				 if(event_release(combat[ads]) && (get_ptime(combat[ads]) < 200)) {
					putAwayPickaxe = !putAwayPickaxe;
				} else if(get_ival(combat[ads]) && (get_ptime(combat[ads]) >= 200)) {
					tracker = (tracker ^ harvestTracker);
					set_val(combat[harvest], 100);
					autoHarvest = FALSE;
					displayUpdate = TRUE;
				}
			}
		} else {
			putAwayPickaxe = TRUE;
		}
	}
	
	// Auto Ping
	if(holdingADS && userData[vOptionAutoPing]) {
		if(!userData[vOptionBuildTracker] || (userData[vOptionBuildTracker] && !tracker)) {
			if(event_press(combat[attack]) && !userData[vOptionAutoPingInterval]) {
				combo_run(cboOptionAutoPingOnce);
			} else if(holdingFire && userData[vOptionAutoPingInterval]) {
				combo_run(cboOptionAutoPing);
			}
		}
	}
	
	// Edit Assist
	if(userData[vOptionEditAssist] && !autoHarvest && (userData[vOptionButton + buttonEditAssist] != userData[vOptionButton + buttonAutoHarvest])) {
		if(!userData[vOptionBuildTracker] || (userData[vOptionBuildTracker] && !(tracker & settingsTracker) && !(tracker & mapTracker) && !(tracker & inventoryTracker))) {
			if(get_ival(userData[vOptionButton + buttonEditAssist]) && !get_ival(userData[vOptionButton + buttonFastReset])) {
				if(!editAssist) {
					combo_run(cboOptionEditAssist);
				} else {
					if(!combo_running(cboOptionEditAssist)) {
						set_val(userData[vControllerButton + select_button], 100);
					}
				}
				editAssist = TRUE;
			} else if(editAssist && event_release(userData[vOptionButton + buttonEditAssist])) {
				set_val(userData[vControllerButton + confirm_button], 100);
				editAssist = FALSE;
			} else if(!get_ival(userData[vOptionButton + buttonEditAssist])) {
				editAssist = FALSE;
			}
		}
	}
	
	// Fast Reset
	if(userData[vOptionFastReset]) {
		if(!userData[vOptionBuildTracker] || (userData[vOptionBuildTracker] && !(tracker & settingsTracker) && !(tracker & mapTracker) && !(tracker & inventoryTracker))) {
			if(userData[vOptionFastReset] == resetOnce && event_press(userData[vOptionButton + buttonFastReset])) {
				combo_run(cboOptionFastReset);
			} else if(!get_ival(userData[vOptionButton + buttonEditAssist]) && get_ival(userData[vOptionButton + buttonFastReset]) && (userData[vOptionFastReset] == resetRepeat)) {
				combo_run(cboOptionFastReset);
			} else if(event_release(userData[vOptionButton + buttonFastReset])) {
				if((userData[vOptionButton + buttonFastReset] == build[rotate_repair_reset])) {
					combo_run(cboResetRepair);
				}
			}
		}
	}
	
	// Build Tracker
	if(userData[vOptionBuildTracker]) {
		if(userData[vControllerConfiguration] == customLayout) {
			// Perform Build Tracker based on HOLD or TAP for harvest toggle
			if((userData[vControllerHarvestPressType] == buttonTap) && event_press(combat[harvest])) {
				if((!(tracker & mapTracker)) && (!(tracker & settingsTracker)) && (!(tracker & inventoryTracker))) {
					cycleHarvestTracker();
				}
			} else if(userData[vControllerHarvestPressType] == buttonHold) {
				if((!(tracker & mapTracker)) && (!(tracker & settingsTracker)) && (!(tracker & inventoryTracker))) {
					checkHarvestModeEvent();
				}
			} else if(event_press(combat[next_weapon])) {
				if((!(tracker & mapTracker)) && (!(tracker & settingsTracker)) && (!(tracker & inventoryTracker))) {
					if(tracker & harvestTracker) {
						tracker = (tracker ^ harvestTracker);
						displayUpdate = TRUE;
					}
				}
			} else if(event_press(combat[previous_weapon])) {
				if((!(tracker & mapTracker)) && (!(tracker & settingsTracker)) && (!(tracker & inventoryTracker))) {
					if(tracker & harvestTracker) {
						tracker = (tracker ^ harvestTracker);
						displayUpdate = TRUE;
					}
				}
			} else if(event_press(combat[inventory])) {
				if((!(tracker & mapTracker)) && (!(tracker & settingsTracker))) {
					tracker = (tracker | inventoryTracker);
					displayUpdate = TRUE;
				}
			}
			checkBuildModeEvent();
		} else {
			// Non-custom (pre-set settings) are always HOLD for harvest toggle
			checkHarvestModeEvent();
			checkBuildModeEvent();
		}
	}
	
	// Rapid Fire
	if(userData[vOptionRapidFire] && holdingFire) {
		if(!userData[vOptionBuildTracker] || (userData[vOptionBuildTracker] && !tracker)) {
			combo_run(cboOptionRapidFire); // Execute Rapid Fire
		}
	} else {
		combo_stop(cboOptionRapidFire); // Stop Rapid Fire
	}
}

// Checks if user is attempting to pause the script (i.e. when using a vehicle)
function checkPause() {

	// Check if pause button combination is pressed
	if(get_ival(XB1_RT) && event_press(XB1_RIGHT) && get_brtime(XB1_RIGHT) <= 240 && !scriptPaused) {
		cls_oled(OLED_BLACK); // Clear screen
		scriptPaused = TRUE; // Set pause flag
		screenSaverEnabled = FALSE; // Disable screen saver
		screenSaverCounter = 0; // Reset screen saver timer
		printText(alignCenter, alignCenter, scriptPausedMsg[0], OLED_FONT_SMALL, OLED_WHITE); // Display message
	} else if(get_ival(XB1_X) && (get_ptime(XB1_X) > 500) && scriptPaused) {
		cls_oled(OLED_BLACK); // Clear screen
		scriptPaused = FALSE; // Unpause script
		displayUpdate = TRUE; // Enable display update
		combo_stop(cboAlertScriptPaused); // Disable pause mode notification
	} else if(scriptPaused) {
		combo_run(cboAlertScriptPaused);
	}
	
	return scriptPaused;
}

// Checks if the aim assist shape to use is different from
// the last shape and resets all aim assist values if needed 
function checkShapeChange(shape) {
	if(shape != aimAssistShape && shape != aasEcstasy) {
		resetAimAssist();
	}
}

// Checks for toggle combination buttons to be pressed
function checkToggles() {
	// Only check for toggles when not in a menu
	if(!displayDepth) {
		// Loop through all toggle combinations
		for(i = 0; i < 4; i += 2) {
			// Only process if a toggle is set
			if(userData[vToggleButton + i] && userData[vToggleButton + i + 1]) {
				// See if toggle is requested
				if(get_ival(userData[vToggleButton + i])) {
					if(event_press(userData[vToggleButton + i + 1]) && (get_brtime(userData[vToggleButton + i + 1]) <= 240)) {
						dispatchToggle(i);
					}
				}
			}
		}
	}
}

// Checks for triggers
function checkTriggers() {

	// Set trigger values and max out if buttons are pressed
	holdingADS = get_val(combat[ads]);
	holdingFire = get_val(combat[attack]);
	
	if(holdingADS) {
		if(userData[vOptionHairTriggers]) { // Check for Hair Triggers
			set_val(combat[ads], 100);
		}
	}
	
	if(holdingFire) {
		if(userData[vOptionHairTriggers]) { // Check for Hair Triggers
			set_val(combat[attack], 100);
		}
	}
}

// Called to check if OLED should be cleared after an action while using Visualizer screen saver
function clearVisualizer() {
	// Check for visualizer screen saver
	if(screenSaverEnabled && (userData[vScreenSaver] == screenSaverVisualizer)) {
		combo_run(cboClearScreen); // Runs faster in a combo
	}
}

// Correct stick input based on drift low/high values including deadzone and compensate for "lost" values
function correctStickInput(low, high, deadzone, stick) {

	// Calculate the boundaries
	antiDriftLowValue = low - polarValues[deadzone - 5];
	antiDriftHighValue = high + polarValues[deadzone - 5];
	antiDriftStickValue = get_ival(stick); // Get stick value
	
	// In the drift zone, so set stick to no movement
	if((antiDriftStickValue >= antiDriftLowValue) && (antiDriftStickValue <= antiDriftHighValue)) {
		set_val(stick, 0);
		
	// If user has moved stick under the lower boundary (left/up)
	} else if(antiDriftStickValue < antiDriftLowValue) {
		set_val(stick, clamp((antiDriftStickValue - antiDriftLowValue) - ((antiDriftStickValue / 327) * antiDriftLowValue) / 100, -32768, 32767));
		
	// If user has moved stick over the upper boundary (right/down)
	} else if(antiDriftStickValue > antiDriftHighValue) {
		set_val(stick, clamp((antiDriftStickValue - antiDriftHighValue) + ((antiDriftStickValue / 327) * antiDriftHighValue) / 100, -32768, 32767));
		
	// Just incase stick_value isn't in driftzone and doesn't meet other conditions
	// (i.e. calculations equate to low/high value)
	// At that point we still do not want to make any adjustment because we're not outside of the drift+deadzone
	} else {
		set_val(stick, 0);
	}
}

// Creates a toggle combination
function createToggle(base_button, toggle) {
	// Loop through each controllerButtons and see what is being held down for 1 second
	for(i = 0; i < sizeof(controllerButtons) / sizeof(controllerButtons[0]); i++) {	
		if(get_val(controllerButtons[i]) && (get_ptime(controllerButtons[i]) >= 1000)) {
			if(modMenuIndex == modMenuToggles) {
				if(!editMenuSelectedRow) {
					// Setting HOLD
					userData[base_button + toggle] = setToggleButton(userData[base_button + toggle], controllerButtons[i], userData[base_button + toggle + 1]);
					userData[base_button + toggle] = verifyToggleCombo(userData[base_button + toggle], toggle);
				} else {
					// Setting PRESS
					userData[base_button + toggle + 1] = setToggleButton(userData[base_button + toggle + 1], controllerButtons[i], userData[base_button + toggle]);
					userData[base_button + toggle + 1] = verifyToggleCombo(userData[base_button + toggle + 1], toggle);
				}
			} else {
				userData[base_button + toggle] = setToggleButton(userData[base_button + toggle], controllerButtons[i], 0);
				userData[base_button + toggle] = verifyToggleButton(userData[base_button + toggle], toggle);
			}
		}
	}
}

function dispatchAdsCycleEditValue(direction, variable, min, max) {
	switch(direction) {
		case XB1_UP {
			userData[variable] = cycleEditValue(userData[variable], cycleValueUp, 10, max);
			break;
		} case XB1_DOWN {
			userData[variable] = cycleEditValue(userData[variable], cycleValueDown, 10, min);
			break;
		} case XB1_LEFT {
			userData[variable] = cycleEditValue(userData[variable], cycleValueDown, 1, min);
			break;
		} case XB1_RIGHT {
			userData[variable] = cycleEditValue(userData[variable], cycleValueUp, 1, max);
			break;
		} default {
			menuActionFailed();
		}
	}
}

function dispatchCycleListOption(direction) {
	switch(direction) {
		case XB1_UP {
			userData[editMenuVariable1] = cycleListOption(userData[editMenuVariable1], cycleValueUp, editMenuMaxValue, editMenuMinValue);
			break;
		} case XB1_DOWN {
			userData[editMenuVariable1] = cycleListOption(userData[editMenuVariable1], cycleValueDown, editMenuMinValue, editMenuMaxValue);
			break;
		} default {
			dispatchMenuAction(direction);
		}
	}
}

function dispatchAssistDualSelection(direction) {
	switch(direction) {
		case XB1_UP {
			if(userData[editMenuParent] == assistAdsOnly) { // Ads only
				userData[editMenuVariable1] = cycleListOption(userData[editMenuVariable1], cycleValueUp, editMenuMaxValue, editMenuMinValue);
			} else if(userData[editMenuParent] == assistAdsOrFire || userData[editMenuParent] == assistAdsAndFireOrAds) { // Ads or fire setting allows selection of ads/fire
				editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
			} else { // Fire only
				userData[editMenuVariable2] = cycleListOption(userData[editMenuVariable2], cycleValueUp, editMenuMaxValue, editMenuMinValue);
			}
			break;
		} case XB1_DOWN {
			if(userData[editMenuParent] == assistAdsOnly) { // Ads only
				userData[editMenuVariable1] = cycleListOption(userData[editMenuVariable1], cycleValueDown, editMenuMinValue, editMenuMaxValue);
			} else if(userData[editMenuParent] == assistAdsOrFire || userData[editMenuParent] == assistAdsAndFireOrAds) { // Ads or fire setting allows selection of ads/fire
				editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
			} else { // Fire only
				userData[editMenuVariable2] = cycleListOption(userData[editMenuVariable2], cycleValueDown, editMenuMinValue, editMenuMaxValue);
			}
			break;
		} default {
			dispatchMenuAction(direction);
		}
	}
}

function dispatchAssistRowSelection(direction) {
	if(userData[editMenuParent] == assistAdsOrFire || userData[editMenuParent] == assistAdsAndFireOrAds) { // Ads or fire
		switch(direction) {
			case XB1_UP {
				editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				break;
			} case XB1_DOWN {
				editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
				break;
			} default {
				dispatchMenuAction(direction);
			}
		}
	} else {
		dispatchMenuAction(direction);
	}
}

function dispatchAdsAssistDualSelection(direction) {
	if(userData[editMenuParent] == assistAdsOrFire || userData[editMenuParent] == assistAdsAndFireOrAds) {
		editMenuSelectionEditVariable = iif(!editMenuSelectedRow, editMenuVariable1, editMenuVariable2);
		switch(direction) {
			case XB1_LEFT {
				userData[editMenuSelectionEditVariable] = cycleListOption(userData[editMenuSelectionEditVariable], cycleValueDown, editMenuAdsMinValue, editMenuAdsMaxValue);
				break;
			} case XB1_RIGHT {
				userData[editMenuSelectionEditVariable] = cycleListOption(userData[editMenuSelectionEditVariable], cycleValueUp, editMenuAdsMaxValue, editMenuAdsMinValue);
				break;
			} default {
				menuActionFailed();
			}
		}
	} else {
		menuActionFailed();
	}
}

function dispatchAdsCycleListOption(direction) {
	switch(direction) {
		case XB1_LEFT {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleListOption(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueDown, editMenuAdsMinValue, editMenuAdsMaxValue);
			break;
		} case XB1_RIGHT {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleListOption(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueUp, editMenuAdsMaxValue, editMenuAdsMinValue);
			break;
		} default {
			menuActionFailed();
		}
	}
}

function dispatchAdsMultiSelection(direction) {
	switch(direction) {
		case XB1_UP {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleEditValue(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueUp, 10, editMenuAdsMaxValue);
			break;
		} case XB1_DOWN {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleEditValue(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueDown, 10, editMenuAdsMinValue);
			break;
		} case XB1_LEFT {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleEditValue(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueDown, 1, editMenuAdsMinValue);
			break;
		} case XB1_RIGHT {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleEditValue(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueUp, 1, editMenuAdsMaxValue);
			break;
		} default {
			menuActionFailed();
		}
	}
}

function dispatchAdsToggle(direction) {
	if((direction == XB1_LEFT) || (direction == XB1_RIGHT)) {
		userData[editMenuVariable2] = !userData[editMenuVariable2];
	} else {
		menuActionFailed();
	}
}

function dispatchMenuToggle(direction) {
	if((direction == XB1_UP) || (direction == XB1_DOWN)) {
		userData[editMenuVariable1] = (userData[editMenuVariable1] ^ editMenuMaxValue);
	} else {
		dispatchMenuAction(direction);
	}
}

function dispatchMenuMultiSelection(direction) {
	switch(direction) {
		case XB1_UP {
			editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, editMenuMinValue);
			break;
		} case XB1_DOWN {
			editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, editMenuMaxValue);
			break;
		} default {
			dispatchMenuAction(direction);
		}
	}
}

function dispatchMenuNone(direction) {
	if((direction == XB1_UP) || (direction == XB1_DOWN)) {
		menuActionFailed();
	} else {
		dispatchMenuAction(direction);
	}
}

function dispatchMenuToggleOnOff(direction) {
	if((direction == XB1_UP) || (direction == XB1_DOWN)) {
		userData[editMenuVariable1] = !userData[editMenuVariable1];
	} else {
		dispatchMenuAction(direction);
	}
}

int editMenuHoldingADS;

function dispatchMenuAction(direction) {
	switch(direction) {
		case XB1_B { // When user presses B/Circle
			if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				antiDriftCalibrationCanSet = 2; // Flag for cancelled
				combo_run(cboCalibrationComplete);
			} else {
				// Check if we are in anti-recoil quick edit
				if(antiRecoilQuickEdit) {
					displayDepth = 0; // Reset to Home Screen
					antiRecoilQuickEdit = FALSE; // Disable anti-recoil quick edit
					combo_run(cboSaveSettings); // Save settings
				} else {
					displayUpdate = TRUE;
					displayDepth--; // Exit to Mod Menu
					editMenuSelectedRow = 0; // Reset selected item index
					editMenuIndex = 0; // Reset index
				}
			}
			break;
		} case XB1_LEFT {
			if((editMenuIndex == editMenuAimAssist) && (userData[vShapeSpin] == assistOff)) {
				editMenuIndex = editMenuShapeSpin; // Goto Shape Spin toggle if SS is off
			} else if(editMenuIndex == editMenuAntiRecoil && !userData[vAntiRecoil]) {
				menuActionFailed();
			} else if(editMenuIndex == editMenuAntiRecoil && (userData[vAntiRecoil] == antiRecoilBasic)) {		
				editMenuIndex = editMenuAntiRecoilStrength;
			} else if((editMenuIndex == editMenuInverseAssist) && (userData[vRotationAssist] == assistOff)) {
				editMenuIndex = editMenuRotationAssist;
			} else if((editMenuIndex == editMenuRotationAssist) && (userData[vAimAssist] == assistOff)) {
				editMenuIndex = editMenuAimAssist; // Goto Aim Assist toggle if RA is off
			} else if((editMenuIndex == editMenuMotionAssist) && (userData[vIdleTargetAssist] == assistOff)) {
				editMenuIndex = editMenuIdleTargetAssist; // Goto Idle Target Assist toggle if Shape Motion is off
			} else if((editMenuIndex == editMenuShapePulse) && (userData[vMotionAssist] == assistOff)) {
				editMenuIndex = editMenuMotionAssist;
			} else if((editMenuIndex == editMenuShapeSpin) && (userData[vShapePulse] == assistOff)) {
				editMenuIndex = editMenuShapePulse;
			} else if((editMenuIndex == editMenuAntidrift) && !userData[vAntiDrift]) {
				menuActionFailed(); // Anti-drift must be enabled to see rest of options
			} else if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				menuActionFailed(); // Cannot leave calibration menu if calibration is running
			} else if(editMenuIndex == editMenuControllerConfiguration && userData[vControllerConfiguration] != customLayout) {
				editMenuIndex = editMenuControllerEditHoldTime;
			} else if(editMenuIndex == editMenuControllerADSButton) {
				editMenuIndex = editMenuControllerConfiguration;
			} else {
				editMenuSelectedRow = 0;
				editMenuIndex = cycleListOption(editMenuIndex, cycleValueDown, editMenuItems[modMenuIndex][editMenuMin], editMenuItems[modMenuIndex][editMenuMax]);
				// Will not alert in DisplayEditMenu due to constant repeat, so enable here
				if(editMenuIndex == editMenuAntidriftTest) {
					menuActionSuccess();	
				}
			}
			break;
		} case XB1_RIGHT {
			if((editMenuIndex == editMenuAimAssist) && (userData[vAimAssist] == assistOff)) {
				editMenuIndex = editMenuRotationAssist; // Goto Rotation Assist toggle if AA is off
			} else if(editMenuIndex == editMenuAntiRecoil && !userData[vAntiRecoil]) {
				menuActionFailed();
			} else if((editMenuIndex == editMenuAntiRecoilStrength) && (userData[vAntiRecoil] == antiRecoilBasic)) {
				editMenuIndex = editMenuAntiRecoil;
			} else if((editMenuIndex == editMenuRotationAssist) && (userData[vRotationAssist] == assistOff)) {
				editMenuIndex = editMenuInverseAssist;
			} else if((editMenuIndex == editMenuIdleTargetAssist) && (userData[vIdleTargetAssist] == assistOff)) {
				editMenuIndex = editMenuMotionAssist;
			} else if((editMenuIndex == editMenuMotionAssist) && (userData[vMotionAssist] == assistOff)) {
				editMenuIndex = editMenuShapePulse;
			} else if((editMenuIndex == editMenuShapePulse) && (userData[vShapePulse] == assistOff)) {
				editMenuIndex = editMenuShapeSpin;
			} else if((editMenuIndex == editMenuShapeSpin) && (userData[vShapeSpin] == assistOff)) {
				editMenuIndex = editMenuAimAssist;
			} else if((editMenuIndex == editMenuAntidrift) && !userData[vAntiDrift]) {
				menuActionFailed(); // Anti-drift must be enabled to see rest of options
			} else if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				menuActionFailed(); // Cannot leave calibration menu if calibration is running
			} else if(editMenuIndex == editMenuControllerConfiguration && userData[vControllerConfiguration] == customLayout) {
				editMenuIndex = editMenuControllerADSButton;
			} else if(editMenuIndex == editMenuControllerEditHoldTime) {
				editMenuIndex = editMenuControllerConfiguration;
			} else {
				editMenuSelectedRow = 0;
				editMenuIndex = cycleListOption(editMenuIndex, cycleValueUp, editMenuItems[modMenuIndex][editMenuMax], editMenuItems[modMenuIndex][editMenuMin]);
				// Will not alert in DisplayEditMenu due to constant repeat, so enable here
				if(editMenuIndex == editMenuAntidriftTest) {
					menuActionSuccess();	
				}
			}
			break;
		} default {
			menuActionFailed();
		}
	}
}

int editMenuSelectionEditValue, editMenuSelectionEditVariable;

function dispatchAdsDualSelectionEdit(direction) {
	
	editMenuSelectionEditValue = iif(direction == XB1_UP || direction == XB1_DOWN, 10, 1);
	editMenuSelectionEditVariable = iif(!editMenuSelectedRow, editMenuVariable1, editMenuVariable2);
	
	if(direction == XB1_UP || direction == XB1_RIGHT) {
		if(userData[editMenuParent] == assistAdsOnly) {
			userData[editMenuVariable1] = cycleEditValue(userData[editMenuVariable1], cycleValueUp, editMenuSelectionEditValue, editMenuAdsMaxValue);
		} else if(userData[editMenuParent] == assistAdsOrFire || userData[editMenuParent] == assistAdsAndFireOrAds) {
			userData[editMenuSelectionEditVariable] = cycleEditValue(userData[editMenuSelectionEditVariable], cycleValueUp, editMenuSelectionEditValue, editMenuAdsMaxValue);
		} else {
			userData[editMenuVariable2] = cycleEditValue(userData[editMenuVariable2], cycleValueUp, editMenuSelectionEditValue, editMenuAdsMaxValue);
		}
	} else if(direction == XB1_DOWN || direction == XB1_LEFT) {
		if(userData[editMenuParent] == assistAdsOnly) {
			userData[editMenuVariable1] = cycleEditValue(userData[editMenuVariable1], cycleValueDown, editMenuSelectionEditValue, editMenuAdsMinValue);
		} else if(userData[editMenuParent] == assistAdsOrFire || userData[editMenuParent] == assistAdsAndFireOrAds) {
			userData[editMenuSelectionEditVariable] = cycleEditValue(userData[editMenuSelectionEditVariable], cycleValueDown, editMenuSelectionEditValue, editMenuAdsMinValue);
		} else {
			userData[editMenuVariable2] = cycleEditValue(userData[editMenuVariable2], cycleValueDown, editMenuSelectionEditValue, editMenuAdsMinValue);
		}
	} else {
		menuActionFailed();
	}
	
}

function dispatchAntiDriftCalibrate(direction) {
	if(direction == XB1_LB || direction == XB1_RB) {
		antiDriftCalibrationStick = !antiDriftCalibrationStick;
	} else {
		switch(direction) {
			case XB1_VIEW {
				if(!antiDriftCalibrationState) {
					if(antiDriftCalibrationStick == antiDriftLeftStick) {
						userData[vAntiDriftLeft + antiDriftCalibrationDirection] = 0;
					} else {
						userData[vAntiDriftRight + antiDriftCalibrationDirection] = 0;
					}
					antiDriftCalibrationCanSet = 3;
					combo_run(cboCalibrationComplete); // Alert user of status
					antiDriftCalibrationState = !antiDriftCalibrationState; // Keep process disabled as combo will flop this value positive
				}
				break;
			} case XB1_A {
				if(antiDriftCalibrationState) {
					// Only set if range was met
					if(antiDriftCalibrationCanSet) {
						determineAntidriftValue(); // Determine the value to set
					}
					combo_run(cboCalibrationComplete); // Alert user of status
				} else {
					antiDriftCalibrationState = !antiDriftCalibrationState; // Enter calibration process
				}
				break;
			} default {
				dispatchMenuAction(direction);
			}
		}
	}
}

function dispatchAdsAntiDriftCalibrate(direction) {
	switch(direction) {
		case XB1_UP {
			if(antiDriftCalibrationDirection != antiDriftUp) {
				antiDriftCalibrationDirection = antiDriftUp;
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_DOWN {
			if(antiDriftCalibrationDirection != antiDriftDown) {
				antiDriftCalibrationDirection = antiDriftDown;
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_LEFT {
			if(antiDriftCalibrationDirection != antiDriftLeft) {
				antiDriftCalibrationDirection = antiDriftLeft;
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_RIGHT {
			if(antiDriftCalibrationDirection != antiDriftRight) {
				antiDriftCalibrationDirection = antiDriftRight;
			} else {
				menuActionFailed();
			}
			break;
		} default {
			menuActionFailed()
		}
	}
}

// Cycles the edit menu
function cycleEditMenu(direction) {
	// Enable display update
	displayUpdate = TRUE;
	
	//menuType, menuAdsType, menuVariable1, menuVariable2, menuMinValue, menuMaxValue, menuAdsMinValue, menuAdsMaxValue
	editMenuHoldingADS = get_ival(XB1_LT);
	editMenuType = menuData[editMenuIndex][menuType];
	editMenuAdsType = menuData[editMenuIndex][menuAdsType];
	editMenuVariable1 = menuData[editMenuIndex][menuVariable1];
	editMenuVariable2 = menuData[editMenuIndex][menuVariable2];
	editMenuParent = menuData[editMenuIndex][menuParent];
	editMenuMinValue = menuData[editMenuIndex][menuMinValue];
	editMenuMaxValue = menuData[editMenuIndex][menuMaxValue];
	editMenuAdsMinValue = menuData[editMenuIndex][menuAdsMinValue];
	editMenuAdsMaxValue = menuData[editMenuIndex][menuAdsMaxValue];
	
	if(!editMenuHoldingADS) {
		switch(editMenuType) {
			case menuAntiDriftCalibrate {
				dispatchAntiDriftCalibrate(direction);
				break;
			} case menuAssistDualSelection {
				dispatchAssistDualSelection(direction);
				break;
			} case menuAssistRowSelection {
				dispatchAssistRowSelection(direction);
				break;
			} case menuCycleListOption {
				dispatchCycleListOption(direction);
				break;
			} case menuMultiSelection {
				dispatchMenuMultiSelection(direction);
				break;
			} case menuNone {
				dispatchMenuNone(direction);
				break;
			} case menuToggle {
				dispatchMenuToggle(direction);
				break;
			} case menuToggleOnOff {
				dispatchMenuToggleOnOff(direction);
				break;
			} default {
				dispatchMenuAction(direction);
			}
		}
	} else {
		switch(editMenuAdsType) {
			case menuAdsAntiDriftCalibrate {
				dispatchAdsAntiDriftCalibrate(direction);
				break;
			} case menuAdsAssistDualSelection {
				dispatchAdsAssistDualSelection(direction);
				break;
			} case menuAdsDualSelectionEdit {
				dispatchAdsDualSelectionEdit(direction);
				break;
			} case menuAdsCycleEditValue {
				dispatchAdsCycleEditValue(direction, editMenuVariable2, editMenuAdsMinValue, editMenuAdsMaxValue);
				break;
			} case menuAdsCycleListOption {
				dispatchAdsCycleListOption(direction);
				break;
			} case menuAdsMultiSelection {
				dispatchAdsMultiSelection(direction);
				break;
			} case menuAdsNone {
				menuActionFailed();
				break;
			} case menuAdsToggle {
				dispatchAdsToggle(direction);
				break;
			}
		}
	}
	
	return;
}

// Cycle an edit menu value by step amount with change limited to a threshold
function cycleEditValue(value, direction, step, threshold) {
	
	// See what direction we are cycling the values
	if(direction == cycleValueUp) {
		if((value + step) <= threshold) {
			return (value + step);
		} else if(value == threshold) {
			menuActionFailed();
		} else {
			return threshold;
		}
	} else {
		if((value - step) >= threshold) {
			return (value - step);
		} else if(value == threshold) {
			menuActionFailed();
		} else {
			return threshold;
		}
	}
	
	return value;
}

// Cycle a menu value
function cycleListOption(value, direction, threshold, reset_value) {
	
	// See what direction we are cycling the values
	if(direction == cycleValueUp) {
		if((value + 1) <= threshold) {
			return value + 1;
		}
	} else {
		if((value - 1) >= threshold) {
			return value - 1;
		}
	}
	
	return reset_value;
}

// Cycle mod menu value
function cycleModMenu(direction) {
	
	displayUpdate = TRUE; // Enable display update
	
	switch(direction) {
		case modMenuEnter {
			displayDepth++; // Advance to Edit Menu
			editMenuIndex = editMenuItems[modMenuIndex][editMenuMin]; // Set new edit menu index
			break;
		} case modMenuExit {
			displayDepth--; // Exit to Home Screen
			combo_run(cboSaveSettings); // Save settings upon exiting mod menu
			break;
		} case modMenuDown {
			modMenuIndex++; // Cycle to next menu
			if(modMenuIndex > modMenuToggles) { // Check boundaries
				modMenuIndex = modMenuAimAssist; // Out of bounds, set to minimum
			}
			menuActionSuccess(); // Alert for successful action
			break;
		} case modMenuUp {
			modMenuIndex--; // Cycle to previous menu
			if(modMenuIndex < modMenuAimAssist) { // Check boundaries
				modMenuIndex = modMenuToggles; // Out of bounds, set to maximum
			}
			menuActionSuccess(); // Alert for successful action
			break;
		}
	}
}

// Determines what to set the anti-drift value to, if a new value was found
function determineAntidriftValue() {
	if(antiDriftCalibrationStick == antiDriftLeftStick) {
		switch(antiDriftCalibrationDirection) {
			case antiDriftUp {
				antiDriftCalibrationValue = get_ival(POLAR_LY);
				if((antiDriftCalibrationValue < userData[vAntiDriftLeft + antiDriftUp]) || (userData[vAntiDriftLeft + antiDriftUp] == 0)) {
					userData[vAntiDriftLeft + antiDriftUp] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftDown {
				antiDriftCalibrationValue = get_ival(POLAR_LY);
				if((antiDriftCalibrationValue > userData[vAntiDriftLeft + antiDriftDown]) || (userData[vAntiDriftLeft + antiDriftDown] == 0)) {
					userData[vAntiDriftLeft + antiDriftDown] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftLeft {
				antiDriftCalibrationValue = get_ival(POLAR_LX);
				if((antiDriftCalibrationValue < userData[vAntiDriftLeft + antiDriftLeft]) || (userData[vAntiDriftLeft + antiDriftLeft] == 0)) {
					userData[vAntiDriftLeft + antiDriftLeft] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftRight {
				antiDriftCalibrationValue = get_ival(POLAR_LX);
				if((antiDriftCalibrationValue > userData[vAntiDriftLeft + antiDriftRight]) || (userData[vAntiDriftLeft + antiDriftRight] == 0)) {
					userData[vAntiDriftLeft + antiDriftRight] = antiDriftCalibrationValue;
				}
				break;
			}
		}
	} else {
		switch(antiDriftCalibrationDirection) {
			case antiDriftUp {
				antiDriftCalibrationValue = get_ival(POLAR_RY);
				if((antiDriftCalibrationValue < userData[vAntiDriftRight + antiDriftUp]) || (userData[vAntiDriftRight + antiDriftUp] == 0)) {
					userData[vAntiDriftRight + antiDriftUp] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftDown {
				antiDriftCalibrationValue = get_ival(POLAR_RY);
				if((antiDriftCalibrationValue > userData[vAntiDriftRight + antiDriftDown]) || (userData[vAntiDriftRight + antiDriftDown] == 0)) {
					userData[vAntiDriftRight + antiDriftDown] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftLeft {
				antiDriftCalibrationValue = get_ival(POLAR_RX);
				if((antiDriftCalibrationValue < userData[vAntiDriftRight + antiDriftLeft]) || (userData[vAntiDriftRight + antiDriftLeft] == 0)) {
					userData[vAntiDriftRight + antiDriftLeft] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftRight {
				antiDriftCalibrationValue = get_ival(POLAR_RX);
				if((antiDriftCalibrationValue > userData[vAntiDriftRight + antiDriftRight]) || (userData[vAntiDriftRight + antiDriftRight] == 0)) {
					userData[vAntiDriftRight + antiDriftRight] = antiDriftCalibrationValue;
				}
				break;
			}
		}
	}
}

// Handles a pressed toggle combination sequence
function dispatchToggle(id) {
	// Determine which toggle is triggered and handle it accordingly
	switch(id) {
		case toggleAutoPing {
			userData[vOptionAutoPing] = !userData[vOptionAutoPing];
			combo_restart(cboToggleAutoPing); // Update with Auto Ping alert
			break;
		} case toggleRapidFire {
			userData[vOptionRapidFire] = !userData[vOptionRapidFire];
			combo_restart(cboToggleRapidFire); // Update with Rapid Fire alert
			break;
		}
	}
}


// Displays stick values for the Anti-drift Test menu
function displayAntidriftTest(x, y, line) {
	// Build display
	insertCharacter(iif(x == POLAR_LX, ASCII_UPPER_L, ASCII_UPPER_R));
	insertCharacter(ASCII_COLON);
	insertCharacter(ASCII_SPACE);
	insertNumber(get_val(x));
	insertCharacter(ASCII_COMMA);
	insertNumber(get_val(y));
	flushBuffer(alignLeft, line, OLED_FONT_SMALL, OLED_WHITE);
}

// Displays the current anti-drift X/Y values for both sticks
function displayAntidriftValues() {
	// Draw a separator line down middle of OLED
	line_oled(OLED_WIDTH >> 1, lineNumber[0] - 4, OLED_WIDTH >> 1, OLED_HEIGHT - 2, 1, OLED_WHITE);
	// Draw each value
	for(j = 0; j < 4; j++) {
		// Left stick
		insertString(antiDriftValues[j]);
		insertNumber(userData[vAntiDriftLeft + j]);
		flushBuffer(alignLeft - 2, 21 + (j * 10), OLED_FONT_SMALL, OLED_WHITE);
		// Right stick
		insertString(antiDriftValues[j]);
		insertNumber(userData[vAntiDriftRight + j]);
		flushBuffer((OLED_WIDTH >> 1) + 3, 21 + (j * 10), OLED_FONT_SMALL, OLED_WHITE);
	}
}

// Draws a list of two items and highlights the selected item
function displayDualSelection(type, message1, message2, value1, value2) {
	// Draw selected item background
	rect_oled(alignLeft, lineNumber[editMenuSelectedRow] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
	// Generate first item
	buildSelectedItemBuffer(type, message1, value1);
	flushSelectedItemBuffer(0, lineNumber[0]);
	// Generate second item
	buildSelectedItemBuffer(type, message2, value2);
	flushSelectedItemBuffer(1, lineNumber[1]);
}

function drawResetInstructions() {
	line_oled(1, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 127, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 1, OLED_WHITE); // Draw bottom line
	printText(alignCenter, alignBottom, toggleReset[iif(get_controller() == PIO_XB1, 1, 0)], OLED_FONT_SMALL, OLED_WHITE); // Display profile name
}

// Display edit menu
function displayEditMenu() {
	// Clears the screen and draw a border to prep edit menu display
 	drawBorder();
 	
 	// Alert for success unless IgnoreAlert is enabled
 	if(!antiDriftCalibrationState && (editMenuIndex != editMenuAntidriftTest)) {
  		menuActionSuccess();
	}
	
	// Display edit menu title and draw a line beneath it for formatting
	printText(alignCenter, alignTop, editMenuNames[editMenuIndex], OLED_FONT_SMALL, OLED_WHITE);
	line_oled(1, OLED_FONT_SMALL_HEIGHT + 7, 127, OLED_FONT_SMALL_HEIGHT + 7, 1, OLED_WHITE);
	
	// See what setting we must display
	switch (editMenuIndex) {
		case editMenuAimAssist { // (Aim Assist)
			printText(alignCenter, alignCenter, assistStatus[userData[vAimAssist]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAimAssistBoost { // (Aim Assist) Type
			printText(alignCenter, alignCenter, aimAssistTypeName[userData[vAimAssistType]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAimAssistRadius { // (Aim Assist) Radius
			if(userData[vAimAssist] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vAimAssistAdsRadius], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vAimAssist] == assistAdsOrFire || userData[vAimAssist] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vAimAssistAdsRadius], userData[vAimAssistFireRadius]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vAimAssistFireRadius], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuAimAssistShape { // (Aim Assist) Shape
			if(userData[vAimAssist] == assistAdsOnly) {
				printText(alignCenter, alignCenter, aimAssistShapeName[userData[vAimAssistAdsShape]], OLED_FONT_SMALL, OLED_WHITE);
			} else if(userData[vAimAssist] == assistAdsOrFire || userData[vAimAssist] == assistAdsAndFireOrAds) {
				displayDualSelection(displayString, aimAssistTypeMsg[0], aimAssistTypeMsg[1], aimAssistShapeName[userData[vAimAssistAdsShape]], aimAssistShapeName[userData[vAimAssistFireShape]]);
			} else {
				printText(alignCenter, alignCenter, aimAssistShapeName[userData[vAimAssistFireShape]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuAimAssistSpeed { // (Aim Assist) Speed
			if(userData[vAimAssist] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vAimAssistAdsSpeed], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vAimAssist] == assistAdsOrFire || userData[vAimAssist] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vAimAssistAdsSpeed], userData[vAimAssistFireSpeed]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vAimAssistFireSpeed], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuRotationAssist { // (Aim Assist) Rotation Assist
			printText(alignCenter, alignCenter, assistStatus[userData[vRotationAssist]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuRotationShape { // (Aim Assist) Rotation Assist Shape
			if(userData[vRotationAssist] == assistAdsOnly) {
				printText(alignCenter, alignCenter, aimAssistRotationShape[userData[vRotationAdsShape]], OLED_FONT_SMALL, OLED_WHITE);
			} else if(userData[vRotationAssist] == assistAdsOrFire || userData[vRotationAssist] == assistAdsAndFireOrAds) {
				displayDualSelection(displayString, aimAssistTypeMsg[0], aimAssistTypeMsg[1], aimAssistRotationShape[userData[vRotationAdsShape]], aimAssistRotationShape[userData[vRotationFireShape]]);
			} else {
				printText(alignCenter, alignCenter, aimAssistRotationShape[userData[vRotationFireShape]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuRotationRadius { // (Aim Assist) Rotation Assist Radius
			if(userData[vRotationAssist] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vRotationAdsRadius], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vRotationAssist] == assistAdsOrFire || userData[vRotationAssist] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vRotationAdsRadius], userData[vRotationFireRadius]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vRotationFireRadius], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuRotationSpeed { // (Aim Assist) Rotation Assist Speed
			if(userData[vRotationAssist] == assistAdsOnly) {
				if(userData[vRotationAdsShape] <= rasCeorin) {
					insertNumber(userData[vRotationAdsSpeed] * (10 + vmSpeedValue[userData[vVMSpeed]]));
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
					flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
				} else {
					printNumber(alignCenter, alignCenter, userData[vRotationAdsSpeed], OLED_FONT_MEDIUM, OLED_WHITE);
				}
			} else if(userData[vRotationAssist] == assistAdsOrFire || userData[vRotationAssist] == assistAdsAndFireOrAds) {
				// Build ADS display
				insertString(aimAssistTypeMsg[0]);
				
				if(userData[vRotationAdsShape] <= rasCeorin) {
					insertNumber(userData[vRotationAdsSpeed] * (10 + vmSpeedValue[userData[vVMSpeed]]));
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
				} else {
					insertNumber(userData[vRotationAdsSpeed]);
				}
				
				// Determine if first item is selected
				if(editMenuSelectedRow == 0) {
					rect_oled(alignLeft, lineNumber[0] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
					flushBuffer(alignLeft, lineNumber[0], OLED_FONT_SMALL, OLED_BLACK);
				} else {
					flushBuffer(alignLeft, lineNumber[0], OLED_FONT_SMALL, OLED_WHITE);
				}
				
				// Build fire display
				insertString(aimAssistTypeMsg[1]);
				
				if(userData[vRotationFireShape] <= rasCeorin) {
					insertNumber(userData[vRotationFireSpeed] * (10 + vmSpeedValue[userData[vVMSpeed]]));
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
				} else {
					insertNumber(userData[vRotationFireSpeed]);
				}
				
				// Determine if second item is selected
				if(editMenuSelectedRow == 1) {
					rect_oled(alignLeft, lineNumber[1] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
					flushBuffer(alignLeft, lineNumber[1], OLED_FONT_SMALL, OLED_BLACK);
				} else {
					flushBuffer(alignLeft, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
				}
			} else {
				if(userData[vRotationFireShape] <= rasCeorin) {
					insertNumber(userData[vRotationFireSpeed] * (10 + vmSpeedValue[userData[vVMSpeed]]));
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
				} else {
					insertNumber(userData[vRotationFireSpeed]);
				}
				flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuInverseAssist { // (Aim Assist) Inverse Assist
			if(userData[vInverseAssist] == assistOff) {
				printText(alignCenter, alignCenter, assistStatus[userData[vInverseAssist]], OLED_FONT_SMALL, OLED_WHITE);
			} else {
				printText(alignCenter, lineNumber[0], assistStatus[userData[vInverseAssist]], OLED_FONT_SMALL, OLED_WHITE);
				insertString(aimAssistRotationThreshold[0]);
				if(!userData[vInverseAssistThreshold]) {
					insertString(aimAssistRotationThreshold[1]);
				} else {
					insertNumber(userData[vInverseAssistThreshold]);
					insertCharacter(ASCII_PERCENT);
				}
				flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuIdleTargetAssist { // (Aim Assist) Idle Target Assist
			printText(alignCenter, alignCenter, assistStatus[userData[vIdleTargetAssist]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuIdleTargetTime { // (Aim Assist) Idle Target Assist Time
			if(!userData[vIdleTargetTime]) {
				insertString(aimAssistIdleTarget[0]);
			} else {
				insertNumber(userData[vIdleTargetTime] * (10 + vmSpeedValue[userData[vVMSpeed]]));
				insertCharacter(ASCII_LOWER_M);
				insertCharacter(ASCII_LOWER_S);
			}
			flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuIdleTargetRadius {// (Aim Assist) Idle Target Assist Radius
			printNumber(alignCenter, alignCenter, userData[vIdleTargetRadius], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuIdleTargetShape {// (Aim Assist) Idle Target Assist Shape
			printText(alignCenter, alignCenter, aimAssistShapeName[userData[vIdleTargetShape]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuIdleTargetSpeed { // (Aim Assist) Idle Target Assist Speed
			printNumber(alignCenter, alignCenter, userData[vIdleTargetSpeed], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuMotionAssist { // (Aim Assist) Shape Motion
			printText(alignCenter, alignCenter, assistStatus[userData[vMotionAssist]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuMotionShape { // (Aim Assist) Motion Type
			if(userData[vMotionAssist] == assistAdsOnly) {
				printText(alignCenter, alignCenter, aimAssistShapeName[userData[vMotionAdsShape]], OLED_FONT_SMALL, OLED_WHITE);
			} else if(userData[vMotionAssist] == assistAdsOrFire || userData[vMotionAssist] == assistAdsAndFireOrAds) {
				displayDualSelection(displayString, aimAssistTypeMsg[0], aimAssistTypeMsg[1], aimAssistShapeName[userData[vMotionAdsShape]], aimAssistShapeName[userData[vMotionFireShape]]);
			} else {
				printText(alignCenter, alignCenter, aimAssistShapeName[userData[vMotionFireShape]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuMotionRadius { // (Aim Assist) Motion Radius
			if(userData[vMotionAssist] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vMotionAdsRadius], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vMotionAssist] == assistAdsOrFire || userData[vMotionAssist] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vMotionAdsRadius], userData[vMotionFireRadius]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vMotionFireRadius], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuMotionSpeed { // (Aim Assist) Motion Speed
			if(userData[vMotionAssist] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vMotionAdsSpeed], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vMotionAssist] == assistAdsOrFire || userData[vMotionAssist] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vMotionAdsSpeed], userData[vMotionFireSpeed]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vMotionFireSpeed], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuShapePulse { // (Aim Assist) Shape Pulse
			printText(alignCenter, alignCenter, assistStatus[userData[vShapePulse]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuShapePulseRadius { // (Aim Assist) Shape Pulse Radius
			if(userData[vShapePulse] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vShapePulseAdsRadius], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vShapePulse] == assistAdsOrFire || userData[vShapePulse] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vShapePulseAdsRadius], userData[vShapePulseFireRadius]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vShapePulseFireRadius], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuShapeSpin { // (Aim Assist) Shape Spin
			printText(alignCenter, alignCenter, assistStatus[userData[vShapeSpin]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuShapeSpinType { // (Aim Assist) Shape Spin Type
			if(userData[vShapeSpin] == assistAdsOnly) {
				printText(alignCenter, alignCenter, aimAssistSpinType[userData[vShapeSpinAdsType]], OLED_FONT_SMALL, OLED_WHITE);
			} else if(userData[vShapeSpin] == assistAdsOrFire || userData[vShapeSpin] == assistAdsAndFireOrAds) {
				displayDualSelection(displayString, aimAssistTypeMsg[0], aimAssistTypeMsg[1], aimAssistSpinType[userData[vShapeSpinAdsType]], aimAssistSpinType[userData[vShapeSpinFireType]]);
			} else {
				printText(alignCenter, alignCenter, aimAssistSpinType[userData[vShapeSpinFireType]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuShapeSpinAngle { // (Aim Assist) Shape Spin Angle
			if(userData[vShapeSpin] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vShapeSpinAdsAngle], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vShapeSpin] == assistAdsOrFire || userData[vShapeSpin] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vShapeSpinAdsAngle], userData[vShapeSpinFireAngle]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vShapeSpinFireAngle], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuAntidrift { // (Anti-drift) Toggle On/Off
			printText(alignCenter, alignCenter, toggleOffOn[userData[vAntiDrift]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAntidriftCalibration { // (Anti-drift) Calibration
			if(antiDriftCalibrationState) {
				// Calibration mode running
				printText(alignCenter, alignCenter, antiDriftCalibrationStateMsg[antiDriftCalibrationState], OLED_FONT_SMALL, OLED_WHITE);
			} else {
				// Calibration mode not running
				printText(alignCenter, lineNumber[0], antiDriftCalibrationStickPrompt[antiDriftCalibrationStick], OLED_FONT_SMALL, OLED_WHITE);
				printText(alignCenter, lineNumber[1], antiDriftCalibrationDirectionPrompt[antiDriftCalibrationDirection], OLED_FONT_SMALL, OLED_WHITE);
				rect_oled(alignLeft - 2, lineNumber[2], OLED_WIDTH - 6, OLED_FONT_SMALL_HEIGHT + 4, 1, OLED_WHITE);
				printText(alignCenter, lineNumber[2] + 3, antiDriftCalibrationStateMsg[antiDriftCalibrationState], OLED_FONT_SMALL, OLED_BLACK);
			}
			break;
		} case editMenuAntidriftTest { // (Anti-drift) Drift Test
			displayAntidriftTest(POLAR_LX, POLAR_LY, lineNumber[0]);
			displayAntidriftTest(POLAR_RX, POLAR_RY, lineNumber[1]);
			break;
		} case editMenuAntidriftValues { // (Anti-drift) Drift Values
			displayAntidriftValues();
			break;
		} case editMenuAntiRecoil { // (Anti-recoil)
			printText(alignCenter, alignCenter, antiRecoilType[userData[vAntiRecoil]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAntiRecoilStrength { // (Anti-recoil) Strength
			printNumber(alignCenter, alignCenter, userData[vAntiRecoilStrength], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuAntiRecoilKickStrength { // (Anti-recoil) Advanced Kick Strength
			printNumber(alignCenter, alignCenter, userData[vAntiRecoilKickStrength], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuAntiRecoilKickDuration { // (Anti-recoil) Advanced Kick Duration
			insertNumber(userData[vAntiRecoilKickDuration] * (10 + vmSpeedValue[userData[vVMSpeed]]));
			insertCharacter(ASCII_LOWER_M);
			insertCharacter(ASCII_LOWER_S);
			flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuControllerConfiguration { // (Controller) Button Layout
			printText(alignCenter, alignCenter, controller[userData[vControllerConfiguration]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerEditHoldTime { // (Controller) Edit Hold Time
			insertNumber(0);
			insertCharacter(ASCII_PERIOD);
			insertNumber(userData[vControllerEditHoldTime]);
			flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuControllerADSButton {
			printText(alignCenter, alignCenter, getControllerButton(userData[vControllerButton + ads_button]), OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuControllerAttackButton {
			printText(alignCenter, alignCenter, getControllerButton(userData[vControllerButton + attack_button]), OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuControllerBuildModeButton {
			printText(alignCenter, alignCenter, getControllerButton(userData[vControllerButton + build_mode_button]), OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuControllerConfirmButton {
			printText(alignCenter, alignCenter, getControllerButton(userData[vControllerButton + confirm_button]), OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuControllerEditButton {
			printText(alignCenter, lineNumber[0], getControllerButton(userData[vControllerButton + edit_button]), OLED_FONT_SMALL, OLED_WHITE);
			printText(alignCenter, lineNumber[1], buttonPressType[userData[vControllerEditPressType]], OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuControllerHarvestButton {
			printText(alignCenter, lineNumber[0], getControllerButton(userData[vControllerButton + harvest_button]), OLED_FONT_SMALL, OLED_WHITE);
			printText(alignCenter, lineNumber[1], buttonPressType[userData[vControllerHarvestPressType]], OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuControllerInventoryButton {
			printText(alignCenter, alignCenter, getControllerButton(userData[vControllerButton + inventory_button]), OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuControllerNextWeaponButton {
			printText(alignCenter, alignCenter, getControllerButton(userData[vControllerButton + next_weapon_button]), OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuControllerPingButton {
			printText(alignCenter, alignCenter, getControllerButton(userData[vControllerButton + ping_button]), OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuControllerPreviousWeaponButton {
			printText(alignCenter, alignCenter, getControllerButton(userData[vControllerButton + previous_weapon_button]), OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuControllerResetButton {
			printText(alignCenter, alignCenter, getControllerButton(userData[vControllerButton + reset_button]), OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuControllerSelectButton {
			printText(alignCenter, alignCenter, getControllerButton(userData[vControllerButton + select_button]), OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuOptionsAutoHarvest {
			printText(alignCenter, lineNumber[0], toggleOffOn[userData[vOptionAutoHarvest]], OLED_FONT_SMALL, OLED_WHITE);
			insertString(buttonToUse[0]);
			insertString(getControllerButton(userData[vOptionButton + buttonAutoHarvest]));
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuOptionsAutoPing {
			printText(alignCenter, lineNumber[0], toggleOffOn[userData[vOptionAutoPing]], OLED_FONT_SMALL, OLED_WHITE);
			if(!userData[vOptionAutoPingInterval]) {
				insertString(autoPing[1]);
			} else {
				insertString(autoPing[0]);
				insertNumber((userData[vOptionAutoPingInterval] + 1) * 120);
				insertCharacter(ASCII_LOWER_M);
				insertCharacter(ASCII_LOWER_S);
			}
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;

		} case editMenuOptionsEditAssist { // (Options) Edit Assist
			printText(alignCenter, lineNumber[0], toggleOffOn[userData[vOptionEditAssist]], OLED_FONT_SMALL, OLED_WHITE);
			insertString(buttonToUse[0]);
			insertString(getControllerButton(userData[vOptionButton + buttonEditAssist]));
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuOptionsFastReset { // (Options) Fast Reset
			printText(alignCenter, lineNumber[0], fastReset[userData[vOptionFastReset]], OLED_FONT_SMALL, OLED_WHITE);
			insertString(buttonToUse[0]);
			insertString(getControllerButton(userData[vOptionButton + buttonFastReset]));
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			drawResetInstructions();
			break;
		} case editMenuOptionsHairTriggers { // (Options) Hair Triggers
			printText(alignCenter, alignCenter, toggleOffOn[userData[vOptionHairTriggers]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuOptionsInstantPickaxe { // (Options) Instant Pickaxe
			printText(alignCenter, alignCenter, toggleOffOn[userData[vOptionInstantPickaxe]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuOptionsBuildTracker { // (Options) Build Tracker
			printText(alignCenter, alignCenter, toggleOffOn[userData[vOptionBuildTracker]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuOptionsRapidFire { // (Options) Rapid Fire
			printText(alignCenter, lineNumber[0], toggleOffOn[userData[vOptionRapidFire]], OLED_FONT_SMALL, OLED_WHITE);
			insertString(fireSpeed[0]);
			insertNumber(userData[vOptionRapidFireSpeed]);
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuSettingsBlockRumble { // (Settings) Block Rumble
			printText(alignCenter, alignCenter, toggleOffOn[userData[vBlockRumble]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuSettingsDeadzone { // (Settings) Deadzone
			displayDualSelection(displayNumber, stickName[deadzoneLeft], stickName[deadzoneRight], userData[vDeadzone + deadzoneLeft], userData[vDeadzone + deadzoneRight]);
			break;
		} case editMenuSettingsInverted { // (Settings) Inverted
			printText(alignCenter, alignCenter, toggleOffOn[userData[vInverted]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuSettingsScreenSaver { // (Settings) Screen saver
			printText(alignCenter, alignCenter, screenSaver[userData[vScreenSaver]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuSettingsSmoothing { // (Settings) Smoothing
			printText(alignCenter, alignCenter, toggleOffOn[userData[vSmoothing]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuSettingsVMSpeed { // (Settings) VM speed
			printText(alignCenter, alignCenter, vmSpeed[userData[vVMSpeed]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuToggleAutoPing { // (Toggles) Auto Ping
			displayToggle(toggleAutoPing);
			drawResetInstructions();
			break;
		} case editMenuToggleRapidFire { // (Toggles) Rapid Fire
			displayToggle(toggleRapidFire);
			drawResetInstructions();
			break;
		}
	}
	
	// Disable display update
	displayUpdate = FALSE;
 }

// Display home screen
function displayHomeScreen() {

 	drawBorder(); // Clears the screen and draws a border
 	
	// Show home screen
	printText(alignCenter, 10, script[0], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, 26, version[0], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, 42, author[0], OLED_FONT_SMALL, OLED_WHITE);
 }
 
 // Display mod menu
 function displayModMenu() {
 	
 	drawBorder(); // Clears the screen and draws a border
  	menuActionSuccess(); // Alert for successful action
	
 	// Display the mod menu
	printText(alignCenter, alignTop, modMenuNames[modMenuItems[modMenuIndex][modMenuPrevious]], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, alignCenter, modMenuNames[modMenuItems[modMenuIndex][modMenuCurrent]], OLED_FONT_MEDIUM, OLED_WHITE);
	printText(alignCenter, alignBottom, modMenuNames[modMenuItems[modMenuIndex][modMenuNext]], OLED_FONT_SMALL, OLED_WHITE);
	
 	// Disable update
 	displayUpdate = FALSE;
 }

// Display screen saver
function displayScreenSaver() {
	// TODO: is this really necessary will there ever be more screensavers?
	switch(userData[vScreenSaver]) {	
		case screenSaverUptime {
			cls_oled(OLED_BLACK); // Clear screen
			printUptime();
			break;
		}
	}
}

// Displays 'Button 1 & 2' messages and the proper controller buttons when editing toggles
function displayToggle(id) {
	displayDualSelection(displayString, toggles[0], toggles[1], iif(get_controller() == PIO_PS4, controllerButtonsPS4[userData[vToggleButton + id]], controllerButtonsXBOX[userData[vToggleButton + id]]), iif(get_controller() == PIO_PS4, controllerButtonsPS4[userData[vToggleButton + id + 1]], controllerButtonsXBOX[userData[vToggleButton + id + 1]]));
}

// Clears the screen and draws a border around the OLED
function drawBorder() {
	cls_oled(OLED_BLACK); // Clear screen
	rect_oled(0, 0, 128, 63, 0, OLED_WHITE); // Draw border around OLED
}

// Calculates the "shape pulse" radius
function calculatePulseRadius() {
	if(userData[vShapePulse]) {
		if(!pulseDirection) {
			if(iif(!holdingFire, userData[vAimAssistAdsRadius], userData[vAimAssistFireRadius]) < iif(!holdingFire, userData[vShapePulseAdsRadius], userData[vShapePulseFireRadius])) {
				if(aimAssistRadius == iif(!holdingFire, userData[vShapePulseAdsRadius], userData[vShapePulseFireRadius])) {
					pulseDirection = 1; // go backwards
				} else if(aimAssistRadius + 1 <= iif(!holdingFire, userData[vShapePulseAdsRadius], userData[vShapePulseFireRadius])) {
					pulseRadius++;
				}
			} else {
				if(aimAssistRadius == iif(!holdingFire, userData[vShapePulseAdsRadius], userData[vShapePulseFireRadius])) {
					pulseDirection = 1; // go backwards
				} else if(aimAssistRadius + 1 >= iif(!holdingFire, userData[vShapePulseAdsRadius], userData[vShapePulseFireRadius])) {
					pulseRadius--;
				}
			}
		} else {
			if(iif(!holdingFire, userData[vAimAssistAdsRadius], userData[vAimAssistFireRadius]) < iif(!holdingFire, userData[vShapePulseAdsRadius], userData[vShapePulseFireRadius])) {
				if(aimAssistRadius == iif(!holdingFire, userData[vAimAssistAdsRadius], userData[vAimAssistFireRadius])) {
					pulseDirection = 0; // go upwards
				} else if(aimAssistRadius >= iif(!holdingFire, userData[vAimAssistAdsRadius], userData[vAimAssistFireRadius])) {
					pulseRadius--;
				}
			} else {
				if(aimAssistRadius == iif(!holdingFire, userData[vAimAssistAdsRadius], userData[vAimAssistFireRadius])) {
					pulseDirection = 0; // go upwards
				} else if(aimAssistRadius <= iif(!holdingFire, userData[vAimAssistAdsRadius], userData[vAimAssistFireRadius])) {
					pulseRadius++;
				}
			}
		}
	}
}

// Executes main Aim Assist, Idle Target assist, and radius adjustment
function executeAimAssist() {
	// If not firing (ADS only)
	if(!holdingFire) {
		checkShapeChange(userData[vAimAssistAdsShape]); // Check if shape has changed
		// Retrieve ADS values
		aimAssistShape = userData[vAimAssistAdsShape];
		aimAssistRadius = userData[vAimAssistAdsRadius];
		aimAssistSpeed = userData[vAimAssistAdsSpeed];
		spinType = userData[vShapeSpinAdsType];
		spinSpeed = userData[vShapeSpinAdsAngle];
		idleTargetTimer = 0; // Reset Idle Target Timer
	} else {
		// If IdleTarget engaged, no need to check for a shape change
		if(!idleTargetEngaged) {
			checkShapeChange(userData[vAimAssistFireShape]); // Check if shape has changed
		}
		// Retrieve Fire values
		aimAssistShape = userData[vAimAssistFireShape];
		aimAssistRadius = userData[vAimAssistFireRadius];
		aimAssistSpeed = userData[vAimAssistFireSpeed];
		spinType = userData[vShapeSpinFireType];
		spinSpeed = userData[vShapeSpinFireAngle];
		
		// Determine Idle Target Assist and any radius/speed adjustments
		getPolarStickValues(); // Get stick values
		executeIdleTargetAssist(); // Execute Idle Target Assist
		executeAimAssistAdjustment(); // Execute aim assist radius adjustment (aim assist type)
	}
	
	// Determine if "shape pulse" is enabled
	if(checkActivation(userData[vShapePulse])) {
		aimAssistRadius += pulseRadius;
	}
	
	if(aimAssistShape == aasEcstasy) {
		if((aimAssistAngle + aimAssistSpeed >= 360) || !aimAssistRandomShape) {
			aimAssistShape = random(aimAssistShapeMin, aimAssistShapeMax - 1);
			aimAssistRandomShape = aimAssistShape;
		} else {
			aimAssistShape = aimAssistRandomShape;
		}
	}
	
	// Determine which shape to draw
	switch(aimAssistShape) {
		case aasCircle {
			// Calculate the coordinates using the mathematical equations for a circle
			aimAssistX = aimAssistRadius * cos[aimAssistAngle];
			aimAssistY = aimAssistRadius * sin[aimAssistAngle];
			break;
		} case aasOval {
			// Calculate the coordinates using the mathematical equations for a ov
			aimAssistX = (aimAssistRadius >> 1) * cos[aimAssistAngle];
			aimAssistY = aimAssistRadius * sin[aimAssistAngle];
			break;
		} case aasEllipse {
			// Calculate the coordinates using the mathematical equations for an ellipse
			aimAssistX = aimAssistRadius * cos[aimAssistAngle];
			aimAssistY = (aimAssistRadius >> 1) * sin[aimAssistAngle];
			break;
		} case aasLemniscate {
			// Calculate the coordinates using the mathematical equations for a lemniscate
			aimAssistX = aimAssistRadius * lemniscateX[aimAssistAngle];
			aimAssistY = aimAssistRadius * lemniscateY[aimAssistAngle];
			break;
		} case aasDiamond {
			// Calculate the coordinates for a diamond shape
			aimAssistX = aimAssistRadius * diamondX[aimAssistAngle];
			aimAssistY = aimAssistRadius * diamondY[aimAssistAngle];
			break;
		} case aasHorizon {
			aimAssistX = aimAssistRadius * horizonX[aimAssistAngle];
			aimAssistY = 0;
			break;
		} case aasRose {
			// Calculate the coordinates using the mathematical equations for a Rose (5 pedal Rose Curve)
			aimAssistX = aimAssistRadius * roseX[aimAssistAngle];
			aimAssistY = aimAssistRadius * roseY[aimAssistAngle];
			break;
		} case aasHeart {
			// Calculate the coordinates using the mathematical equations for a Heart Curve
			aimAssistX = aimAssistRadius * heartX[aimAssistAngle];
			aimAssistY = aimAssistRadius * heartY[aimAssistAngle];
			break;
		} case aasFlower {
			// Calculate the coordinates using the mathematical equations for a flower shape
			aimAssistX = aimAssistRadius * flowerX[aimAssistAngle];
			aimAssistY = aimAssistRadius * flowerY[aimAssistAngle];
			break;
		} case aasOrbit {
			// Calculate the coordinates for a "Orbit" shape
			aimAssistX = aimAssistRadius * orbitX[aimAssistAngle];
			aimAssistY = aimAssistRadius * orbitY[aimAssistAngle];
			break;
		} case aasSpiral {
			// Calculate the coordinates using the mathematical equations for an Archimedes' spiral
			aimAssistX = (aimAssistRadius * aimAssistAngle * cos[aimAssistAngle]) / 328;
			aimAssistY = (aimAssistRadius * aimAssistAngle * sin[aimAssistAngle]) / 328;
			break;
		}
	}
	
	if(checkActivation(userData[vMotionAssist])) {
		if(!holdingFire) {
			// Retrieve ADS motion values
			motionShape = userData[vMotionAdsShape];
			motionRadius = userData[vMotionAdsRadius];
			motionSpeed = userData[vMotionAdsSpeed];
		} else {
			// Retrieve Fire motion values
			motionShape = userData[vMotionFireShape];
			motionRadius = userData[vMotionFireRadius];
			motionSpeed = userData[vMotionFireSpeed];
		}
		
		switch(motionShape) {
			case aasCircle {
				// Calculate the coordinates using the mathematical equations for a circle
				motionX = motionRadius * cos[motionAngle];
				motionY = motionRadius * sin[motionAngle];
				break;		
			} case aasOval {
				// Calculate the coordinates using the mathematical equations for a ov
				motionX = (motionRadius >> 1) * cos[motionAngle];
				motionY = motionRadius * sin[motionAngle];
				break;
			} case aasEllipse {
				// Calculate the coordinates using the mathematical equations for an ellipse
				motionX = motionRadius * cos[motionAngle];
				motionY = (motionRadius >> 1) * sin[motionAngle];
				break;
			} case aasLemniscate {
				// Calculate the coordinates using the mathematical equations for a lemniscate
				motionX = motionRadius * lemniscateX[motionAngle];
				motionY = motionRadius * lemniscateY[motionAngle];
				break;
			} case aasDiamond {
				// Calculate the coordinates for a diamond shape
				motionX = motionRadius * diamondX[motionAngle];
				motionY = motionRadius * diamondY[motionAngle];
				break;
			} case aasHorizon {
				motionX = motionRadius * horizonX[motionAngle];
				motionY = 0;
				break;
			}
		}
		// Output
		set_val(stick[aimX], clamp(get_val(stick[aimX]) + motionX, -32768, 32767));
		set_val(stick[aimY], clamp(get_val(stick[aimY]) + motionY, -32768, 32767));
	}
	
	aimAssistAngle += aimAssistSpeed; // Step to next angle
	
	if(checkActivation(userData[vShapeSpin])) {
		// Offset
		// Spinning
		if(spinType == spinOffset) {
			spinAngle = spinSpeed;
		}
	  	spinX = ((aimAssistX * cos[spinAngle]) / 328) - ((aimAssistY * sin[spinAngle]) / 328);
	  	spinY = ((aimAssistX * sin[spinAngle]) / 328) + ((aimAssistY * cos[spinAngle]) / 328); 
	  	
	  	// Prepare to output
	  	aimAssistX = spinX;
	  	aimAssistY = spinY;
  	}

	motionAngle += motionSpeed; // Step to next motion angle
	
	// Check if angle must be corrected
	if(motionAngle >= 360) {
		motionAngle -= 360; // Correct angle
	}
		
	// Check if angle must be corrected
	if(aimAssistAngle >= 360) {
		aimAssistAngle -= 360; // Correct angle
		
		/*motionAngle += motionSpeed; // Step to next motion angle
		
		// Check if angle must be corrected
		if(motionAngle >= 360) {
			motionAngle -= 360; // Correct angle
		}*/
		
		// Check for Shape Pulse
		if(checkActivation(userData[vShapePulse])) {
			calculatePulseRadius(); // Calculate pulse radius
		}
		
		// See if screen saver needs to be cleared
		clearVisualizer(); 
		
		if(checkActivation(userData[vShapeSpin])) {
			if(spinType == spinSpinning) {
			  	spinAngle += spinSpeed;
			  	
			  	if(spinAngle >= 360) {
			  		spinAngle -= 360;
			  	}
			}
		}
	}
  	
	// Determine how values should be output to stick
	if(holdingADS && !holdingFire) {
		// If only aiming and not firing, gradually reduce output as it approaches 100
		output(stick[aimX], aimAssistX);
		output(stick[aimY], aimAssistY);
	} else {
		// Otherwise, output values as they are
		set_val(stick[aimX], clamp(get_val(stick[aimX]) + aimAssistX, -32768, 32767));
		set_val(stick[aimY], clamp(get_val(stick[aimY]) + aimAssistY, -32768, 32767));
	}
	
	// Check for visualizer screen saver
	if(screenSaverEnabled && (userData[vScreenSaver] == screenSaverVisualizer)) {
		// Draw aim assist shape to OLED
		pixel_oled(64 + (((aimAssistX / aimAssistRadius) * 30) / 327), 32 + (((aimAssistY / aimAssistRadius) * 30) / 327), OLED_WHITE);
	}
}

// Adjusts the radius based on % of stick movement
// - adjustment ranges from -10 (reducing) to +10 (expanding)
function executeAimAssistAdjustment() {
	// Check for adjustment type
	if(userData[vAimAssistType] != aatSteady) {
		// Check for aim assist radius boost
		switch(userData[vAimAssistType]) {
			case aat_mRadius { // Subtract Radius
				// Decrements radius per 10% of aim stick move, limited to 50% of radius value
				if((aimAssistRadius >> 1) <= polarValue) {
					aimAssistRadius = aimAssistRadius >> 1;
				} else {
					aimAssistRadius -= polarValue;
				}
				break;
			} case aat_mSpeed { // Subtract Speed
				// Decrements radius per 10% of aim stick move, limited to 50% of radius value
				if((aimAssistSpeed >> 1) <= polarValue) {
					aimAssistSpeed = aimAssistSpeed >> 1;
				} else {
					aimAssistSpeed -= polarValue;
				}
				break;
			} case aat_mRadius_mSpeed { // Minus Radius & Minus Speed
				// Subtract Speed
				if((aimAssistSpeed >> 1) <= polarValue) {
					aimAssistSpeed = aimAssistSpeed >> 1;
				} else {
					aimAssistSpeed -= polarValue;
				}
				// Subtract Radius
				if((aimAssistRadius >> 1) <= polarValue) {
					aimAssistRadius = aimAssistRadius >> 1;
				} else {
					aimAssistRadius -= polarValue;
				}
				break;
			} case aat_mRadius_pSpeed { // Minus Radius & Plus Speed
				// Subtract Radius
				if((aimAssistRadius >> 1) <= polarValue) {
					aimAssistRadius = aimAssistRadius >> 1;
				} else {
					aimAssistRadius -= polarValue;
				}
				// Add Speed
				aimAssistSpeed += polarValue;
				break;
			} case aat_pRadius_mSpeed { // Plus Radius & Minus Speed
				// Add Radius
				aimAssistRadius += polarValue;
				// Subtract Speed
				if((aimAssistSpeed >> 1) <= polarValue) {
					aimAssistSpeed = aimAssistSpeed >> 1;
				} else {
					aimAssistSpeed -= polarValue;
				}
				break;
			} case aat_pRadius_pSpeed { // Plus Radius & Plus Speed
				aimAssistSpeed += polarValue; // Add Speed
				aimAssistRadius += polarValue; // Add Radius
				break;
			} case aat_pSpeed { // Add Speed
				aimAssistSpeed += polarValue;
				break;
			} case aat_pRadius { // Add Radius
				aimAssistRadius += polarValue; // Increment radius per 10% aim stick move
				break;
			}
		}
	}
}

// Executes anti-recoil
function executeAntiRecoil() {
	switch(userData[vAntiRecoil]) {
		case antiRecoilBasic {
			antiRecoilY = userData[vAntiRecoilStrength];
			break;
		} case antiRecoilAdvanced {
			antiRecoilY = iif(antiRecoilCounterY <= (userData[vAntiRecoilKickDuration] * (10 + vmSpeedValue[userData[vVMSpeed]])), userData[vAntiRecoilKickStrength], userData[vAntiRecoilStrength]);
			antiRecoilCounterY += get_rtime(); // Increase vertical duration counter
			break;
		}
	}
	
	// Output vertical value
	output(stick[aimY], polarValues[antiRecoilY] * iif(userData[vInverted], -1, 1));
}

// Executes idle target assist
// - if stick movement is less than 10.24% and timer met,
// 	 set new aim assist values until the stick is moved
function executeIdleTargetAssist() {
	// Check if idle target assist is enabled
	if(userData[vIdleTargetAssist] == assistOn) {
		if(polarValue < 1) { // If stick is not moving
			if(idleTargetTimer >= (userData[vIdleTargetTime] * (10 + vmSpeedValue[userData[vVMSpeed]]))) { // See if we have met the timer
				// If this is first time Idle Target Assist is engaged, reset the angle
				if(!idleTargetEngaged) {
					aimAssistAngle = 0; // Reset angle for new shape
				}
				aimAssistShape = userData[vIdleTargetShape]; // Set aim assist shape to idle target shape
				aimAssistRadius = userData[vIdleTargetRadius]; // Set aim assist radius to idle target radius
				aimAssistSpeed = userData[vIdleTargetSpeed]; // Set aim assist speed to idle target speed
				idleTargetEngaged = TRUE;
			} else {
				idleTargetTimer += get_rtime(); // Add time elapsed to counter
				idleTargetEngaged = FALSE;
			}
		} else { // Stick has moved
			idleTargetTimer = 0; // Reset idle target timer if there is movement
			if(idleTargetEngaged) { // If idle target assist was engaged, reset aim assist
				aimAssistAngle = 0;
				idleTargetEngaged = FALSE;
			}
		}
	}
}

// Executes the inverse aimer movement rotational aim assist
function executeInverseAssist() {
	if((abs(get_val(stick[aimX])) >= polarValues[userData[vInverseAssistThreshold]])) {
		output(stick[moveX], calculateRotationThresholdAdjustment(get_val(stick[aimX])));
	}
}

// Executes the rotational aim assist (left stick "strafe" or shape)
function executeRotationAssist() {
	
	// Get rotational shape
	rotationType  = iif(holdingFire, userData[vRotationFireShape], userData[vRotationAdsShape]);
	
	if(rotationType <= rasCeorin) {
		rotationRadius = iif(holdingFire, polarValues[userData[vRotationFireRadius]], polarValues[userData[vRotationAdsRadius]]);
		rotationSpeed = iif(holdingFire, userData[vRotationFireSpeed], userData[vRotationAdsSpeed]) * (10 + vmSpeedValue[userData[vVMSpeed]]);
		
		// If counter is greater or equal to delay...change direction
		if(rotationCounter >= rotationSpeed) {
			rotationCounter = 0; // Set counter to any remainder
			if(rotationType == rasStrafe) {
				rotationDirection = !rotationDirection; // Change direction
			} else {
				rotationDirection = cycleListOption(rotationDirection, cycleValueUp, 4, 1);
			}
		} else {
			rotationCounter += get_rtime(); // Add # milliseconds since last loop
		}
		
		// Determine which direction to move stick
		if(rotationType == rasStrafe) {
			output(stick[moveX], iif(rotationDirection, inv(rotationRadius), rotationRadius));
		} else {
			switch(rotationDirection) {
				case 1 {
					aimAssistX = rotationRadius;
					aimAssistY = inv(rotationRadius);
					break;		
				} case 2 {
					aimAssistX = inv(rotationRadius);
					aimAssistY = rotationRadius;
					break;	
				} case 3 {
					aimAssistX = rotationRadius;
					aimAssistY = rotationRadius;
					break;	
				} case 4 {
					aimAssistX = inv(rotationRadius);
					aimAssistY = inv(rotationRadius);
					break;
				}
			}
			output(stick[moveX], aimAssistX);
			output(stick[moveY], aimAssistY);
		}
	} else { 
		rotationRadius = iif(holdingFire, userData[vRotationFireRadius], userData[vRotationAdsRadius]);
		rotationSpeed = iif(holdingFire, userData[vRotationFireSpeed], userData[vRotationAdsSpeed]);
		
		if(rotationType == rasRandom) {
			if((rotationAngle + rotationSpeed >= 360) || !rotationRandomShape) {
				rotationType = random(rasCircle, rasRandom - 1);
				rotationRandomShape = rotationType;
			} else {
				rotationType = rotationRandomShape;
			}
		}
		
		// Determine which shape to draw
		switch(rotationType) {
			case rasCircle {
				// Calculate the coordinates using the mathematical equations for a circle
				aimAssistX = rotationRadius * cos[rotationAngle];
				aimAssistY = rotationRadius * sin[rotationAngle];
				break;		
			} case rasOval {
				// Calculate the coordinates using the mathematical equations for a ov
				aimAssistX = (rotationRadius >> 1) * cos[rotationAngle];
				aimAssistY = rotationRadius * sin[rotationAngle];
				break;
			} case rasEllipse {
				// Calculate the coordinates using the mathematical equations for an ellipse
				aimAssistX = rotationRadius * cos[rotationAngle];
				aimAssistY = (rotationRadius >> 1) * sin[rotationAngle];
				break;
			} case rasLemniscate {
				// Calculate the coordinates using the mathematical equations for a lemniscate
				aimAssistX = rotationRadius * lemniscateX[rotationAngle];
				aimAssistY = rotationRadius * lemniscateY[rotationAngle];
				break;
			}case rasDiamond {
				// Calculate the coordinates for a diamond shape
				aimAssistX = rotationRadius * diamondX[rotationAngle];
				aimAssistY = rotationRadius * diamondY[rotationAngle];
				break;
			}
		}
		
		// Step to next angle
		rotationAngle += rotationSpeed;
		
		// Check if angle must be corrected
		if(rotationAngle >= 360) {
			rotationAngle -= 360;
		}
		
		output(stick[moveX], aimAssistX);
		output(stick[moveY], aimAssistY);
	}
}

// Displays the initial greeting
function executeGreeting() {
	// Must be a minimum of 2
	aimAssistRadius = 3;
	
	// Get coordinates
	//aimAssistX = (aimAssistRadius >> 1) * cos[aimAssistAngle];
	//aimAssistY = aimAssistRadius * sin[aimAssistAngle];
	aimAssistX = aimAssistRadius * lemniscateX[aimAssistAngle];
	aimAssistY = aimAssistRadius * lemniscateY[aimAssistAngle];
	
	// Calculate offset
  	spinX = ((aimAssistX * cos[spinAngle]) / 328) - ((aimAssistY * sin[spinAngle]) / 328);
  	spinY = ((aimAssistX * sin[spinAngle]) / 328) + ((aimAssistY * cos[spinAngle]) / 328); 
  	
  	// Prepare to output
  	aimAssistX = spinX;
  	aimAssistY = spinY;
  	
  	// Step ahead 
	aimAssistAngle += 1;
	spinAngle += 45;
	
	if(aimAssistAngle >= 360) {
		aimAssistAngle %= 360;
	}
	
	if(spinAngle >= 360) {
		spinAngle %= 360;
	}
	
	// Print to OLED
	pixel_oled(64 + (((aimAssistX / aimAssistRadius) * 30) / 328), 32 + (((aimAssistY / aimAssistRadius) * 30) / 328), OLED_WHITE);
}

// Applies Exponential Smoothing to smoothen out rapid stick movement
function exponentialSmoothing(current_value, previous_forecast) {
  return (((current_value << 1) + 8 * previous_forecast) + 5) / 10;
}

// Flushes the display buffer
function flushBuffer(x, y, size, color) {
	// Decrement display buffer value for proper arithmetic
	displayBuffer--; 
	
	// Check horizontal alignment
	switch(x) { 
		case alignRight {
			x = OLED_WIDTH - (displayBuffer * fontWidth[size]) - 4; // Additional 4 for padding from border
			break;	
		} case alignCenter {
			x = (OLED_WIDTH >> 1) - ((displayBuffer * fontWidth[size]) >> 1);
			break;
		}
		// No alignLeft case is needed because alignLeft is set to the proper left alignment already
	}
	
	// Check vertical alignment
	switch(y) { 
		case alignCenter {
			y = (OLED_HEIGHT >> 1) - (fontHeight[size] >> 1);
			break;
		} case alignBottom {
			y = OLED_HEIGHT - fontHeight[size] - 4; // Additional 4 for padding from border
			break;	
		}
		// No alignTop case is needed because alignTop is set to the proper top alignment already
	}
	
	puts_oled(x, y, size, displayBuffer, color); // Output display buffer
	displayBuffer = 1; // Reset display buffer
}

// Flushes the display buffer for a multiple item menu
function flushSelectedItemBuffer(item, line) {
	flushBuffer(alignLeft, line, OLED_FONT_SMALL, iif(editMenuSelectedRow == item, OLED_BLACK, OLED_WHITE));
}

// Format and append the display buffer for displaying the script uptime
function generateUptime(value, character) {
	insertNumber(value);
	insertCharacter(character);
}

// Returns a string of the button requested based on the controller used
function getControllerButton(b) {
	return iif(get_controller() == PIO_PS4, controllerButtonsPS4[b], controllerButtonsXBOX[b])
}

// Get stick polar radius based on the aiming stick that is used
// Basically gets "the stick to use" for calculating difference/addition
// for Aim Assist Type setting (increasing/decreasing)
function getPolarStickValues() {
	// Determine which stick radius to use for calculating aim assist radius boost/idle target assist
	polarStick = POLAR_RS;
	// Set value to % the stick is moved (sets of 10)
	polarValue = get_polar(polarStick, POLAR_RADIUS) / 1000;
}

// Alternative for the ternary operator
function iif(expression, truepart, falsepart) {
	// evaluate if expression is true
	if(expression) {
		return truepart; // Return truepart
	}
	
	// Else, return falsepart
	return falsepart;
}

// Inserts a character into the display buffer
function insertCharacter(int value) {
	putc_oled(displayBuffer, value);
	displayBuffer++;
}

// Inserts a number into the display buffer
function insertNumber(int value) {
	// Check if value is negative
	if(value < 0) {
		insertCharacter(ASCII_MINUS); // Insert '-' into the display buffer
		value = abs(value); // Convert value to positive
	}
	
	displayBufferInsertCopyValue = value; // Create a copy of value to perform work on
	displayBufferInsertNumberOfDigits = 0; // Reset number of digits to 0
	
    // Determine the number of digits in the number by
    // dividing it by 10 repeatedly until it becomes 0
    // while not ignoring a value of 0
    do {
        displayBufferInsertCopyValue /= 10;
        displayBufferInsertNumberOfDigits++;
    } while(displayBufferInsertCopyValue)
    
    // Extract each digit of the number and store it in an array
    for(i = 0; i < displayBufferInsertNumberOfDigits; i++) {
        displayBufferInsertDigits[i] = (value % 10) + 48;
        value /= 10;
    }
    
    // Insert the digits in the order that they appear in the number
    for(i = displayBufferInsertNumberOfDigits - 1; i >= 0; i--) {
        insertCharacter(displayBufferInsertDigits[i]);
    }
}

// Inserts a string into the display buffer
function insertString(s) {
	// Loop through each character of the string
    do {
    	insertCharacter(dint8(s)); // Insert character into display buffer
    	s++; // Move to next character of the string
    } while(dint8(s)) // Check if a next character exists
}

// Menu action allowed
function menuActionSuccess() {
	// Make sure it is not running, if so, terminate it
	if(combo_running(cboActionSuccess)) { 
		combo_stop(cboActionSuccess);
	}
	
	combo_run(cboActionSuccess); // Execute alert
}

// Edit menu action not allowed
function menuActionFailed() {
	// Make sure it is not running, if so, terminate it
	if(combo_running(cboActionFailed)) { 
		combo_stop(cboActionFailed);
	}
	
	displayUpdate = FALSE;
	combo_run(cboActionFailed); // Execute alert
}

// Output value to stick and gradually reduce it as it approaches maximum movement
function output(stick, value) {
	//if(value) {
		set_val(stick, clamp(value * (32767 - abs(get_val(stick))) / 32767 + get_val(stick), -32768, 32767));
	//} else {
	//	set_val(stick, clamp(value * (-32768 + abs(get_val(stick))) / -32768 + get_val(stick), -32768, 32767));
	//}
}

// Prints a number to the screen
function printNumber(x, y, number, size, color) {
	insertNumber(number);
	flushBuffer(x, y, size, color);
}

 // Prints text to the screen
 function printText(x, y, text, size, color) {
	insertString(text);
	flushBuffer(x, y, size, color);
}

// Print the uptime to the OLED display
function printUptime() {
	// Check days
	if(uptimeDays) {
		generateUptime(uptimeDays, ASCII_LOWER_D);
	}
	// Check hours
	if(uptimeHours) {
		generateUptime(uptimeHours, ASCII_LOWER_H);
	}
	// Check minutes
	if(uptimeMinutes) {
		generateUptime(uptimeMinutes, ASCII_LOWER_M);
	}
	// Check seconds
	if(uptimeSeconds) {
		generateUptime(uptimeSeconds, ASCII_LOWER_S);
	}
	
	// Print centered to OLED the script uptime
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE); 
}

// Removes any "movement" inside calibrated drift area and applies a deadzone
function removeDriftAndApplyDeadzone() {
	// If anti-drift is not enabled, we use 0 for low/high values.  Deadzone doesn't matter
	if(userData[vAntiDrift]) {
		correctStickInput(userData[vAntiDriftLeft + antiDriftLeft], userData[vAntiDriftLeft + antiDriftRight], userData[vDeadzone + deadzoneLeft], stick[moveX]);
		correctStickInput(userData[vAntiDriftLeft + antiDriftUp], userData[vAntiDriftLeft + antiDriftDown], userData[vDeadzone + deadzoneLeft], stick[moveY]);
		correctStickInput(userData[vAntiDriftRight + antiDriftLeft], userData[vAntiDriftRight + antiDriftRight], userData[vDeadzone + deadzoneRight], stick[aimX]);
		correctStickInput(userData[vAntiDriftRight + antiDriftUp], userData[vAntiDriftRight + antiDriftDown], userData[vDeadzone + deadzoneRight], stick[aimY]);
	} else {
		// This is done because it's possible user has values saved
		// but for whatever reason wants anti-drift off
		// Deadzone doesn't matter, if user doesn't want to use script deadzone
		// they can leave it at 0
		correctStickInput(0, 0, userData[vDeadzone + deadzoneLeft], stick[moveX]);
		correctStickInput(0, 0, userData[vDeadzone + deadzoneLeft], stick[moveY]);
		correctStickInput(0, 0, userData[vDeadzone + deadzoneRight], stick[aimX]);
		correctStickInput(0, 0, userData[vDeadzone + deadzoneRight], stick[aimY]);
	}
}

// Resets aim assist-related values
function resetAimAssist() {
	spinAngle = 0; // Reset spin angle
	pulseDirection = 0; // Reset pulse diretion
	pulseRadius = 0; // Reset pulse count
	motionAngle = 0; // Reset motion shape angle
	aimAssistAngle = 0; // Reset aim assist shape angle
	idleTargetTimer = 0; // Reset idle target timer
	clearVisualizer(); // Check if Visualizer is running and if so, clear the screen since Aim Assist is disengaged
}

// Sets button variables based on in-game settings
function setButtonLayout() {
	// Set Combat Controls
	combat[ads] = combatLayoutMap[userData[vControllerConfiguration]][ads];
	combat[attack] = combatLayoutMap[userData[vControllerConfiguration]][attack];
	combat[previous_weapon] = combatLayoutMap[userData[vControllerConfiguration]][previous_weapon];
	combat[next_weapon] = combatLayoutMap[userData[vControllerConfiguration]][next_weapon];
	combat[harvest] = combatLayoutMap[userData[vControllerConfiguration]][harvest];
	combat[interact] = combatLayoutMap[userData[vControllerConfiguration]][interact];
	combat[build_mode] = combatLayoutMap[userData[vControllerConfiguration]][build_mode];
	combat[jump] = combatLayoutMap[userData[vControllerConfiguration]][jump];
	combat[slide] = combatLayoutMap[userData[vControllerConfiguration]][slide];
	combat[sprint] = combatLayoutMap[userData[vControllerConfiguration]][sprint];
	combat[inventory] = combatLayoutMap[userData[vControllerConfiguration]][inventory];
	combat[emote] = combatLayoutMap[userData[vControllerConfiguration]][emote];
	combat[ping] = combatLayoutMap[userData[vControllerConfiguration]][ping];
	combat[augment] = combatLayoutMap[userData[vControllerConfiguration]][augment];
	// Set Build Controls
	build[stair] = buildLayoutMap[userData[vControllerConfiguration]][stair];
	build[roof] = buildLayoutMap[userData[vControllerConfiguration]][roof];
	build[wall] = buildLayoutMap[userData[vControllerConfiguration]][wall];
	build[floor] = buildLayoutMap[userData[vControllerConfiguration]][floor];
	build[trap] = buildLayoutMap[userData[vControllerConfiguration]][trap];
	build[edit] = buildLayoutMap[userData[vControllerConfiguration]][edit];
	build[rotate_repair_reset] = buildLayoutMap[userData[vControllerConfiguration]][rotate_repair_reset];
	// Check for custom
	
	if(userData[vControllerConfiguration] == customLayout) {
		build[edit] = userData[vControllerButton + edit_button];
		build[rotate_repair_reset] = userData[vControllerButton + reset_button];
		combat[ads] = userData[vControllerButton + ads_button];
		combat[attack] = userData[vControllerButton + attack_button];
		combat[build_mode] = userData[vControllerButton + build_mode_button];
		combat[harvest] = userData[vControllerButton + harvest_button];
		combat[inventory] = userData[vControllerButton + inventory_button];
		combat[next_weapon] = userData[vControllerButton + next_weapon_button];
		combat[ping] = userData[vControllerButton + ping_button];
		combat[previous_weapon] = userData[vControllerButton + previous_weapon_button];
	}
}

// Set controller configuration
function setControllerConfig() {
	setButtonLayout();
	setStickLayout();
	//getPolarStickValues(); // Determine proper Sprint stick
}

// Sets the LED to the color provided as the parameter
function setLedColor(color) {
	set_hsb(colorValues[color][hue], colorValues[color][saturation], colorValues[color][brightness]);
}

// Sets joystick variables based on in-game settings
function setStickLayout() {
	// Determine movement and aiming sticks
	stick[aimX] = POLAR_RX;
	stick[aimY] = POLAR_RY;
	stick[moveX] = POLAR_LX;
	stick[moveY] = POLAR_LY;
}


// Attempts to bind button_to_set to a toggle combination
function setToggleButton(button_to_use, button_to_set, button_to_compare) {
	// Holding 'View' button will undo a previously set toggle combination button
	if(button_to_set == XB1_VIEW) {
		// Check if a buttin is set
		if(button_to_use) {
			button_to_use = 0; // Reset value
			displayUpdate = TRUE; // Enable display update
		} else {
			combo_run(cboActionFailed); // Cannot map same buttons
		}
	} else if(button_to_set != button_to_use) { // Check if value to set is different than current stored value for toggle
		if(button_to_set == button_to_compare) { // Make sure toggle combination [hold] button #1 does not equal [press] button #2
			combo_run(cboActionFailed); // Cannot map same buttons
		} else {
			button_to_use = button_to_set; // Set toggle button
		}
	}
	
	return button_to_use;
}

// Sets the LED color and displays a message based on Build Tracker state
function setTrackerPrompt(color, id) {
	setLedColor(color);
	if(displayUpdate) {
		cls_oled(OLED_BLACK);
		printText(alignCenter, alignCenter, trackerMsg[id], OLED_FONT_SMALL, OLED_WHITE);
		displayUpdate = FALSE;
	}
}

// Fix PS4 controller issue (from TD21)
function swapPS4() {
    if(get_console() == PIO_PS4) {
        if(get_controller() != PIO_PS4) {
            if(get_ival(PS4_SHARE)) {
                if(get_ival(PS4_R3)) {
                    set_val(PS4_SHARE, 100);
                    set_val(PS4_TOUCH, 0);
                    set_val(PS4_R3, 0);
                } else {
                    set_val(PS4_TOUCH, 100);
                    set_val(PS4_SHARE, 0);
                }
            }
        }
    } else if(get_console() == PIO_XB360) {
        if(get_controller() == PIO_PS4) {
            swap(PS4_TOUCH, PS4_SHARE);
        }
    }
}

// Verifies that a toggle button is not already set
function verifyToggleButton(verify_button, index) {

	// Loop through each set of toggle buttons
	for(j = 0; j < 3; j++) {
		if(((j != buttonAutoHarvest) && (modMenuIndex == modMenuOptions)) && userData[vOptionButton + j]) { // Make sure the buttons are accepted (0 = rejected from prior function)
			if(j != index) { // Do not compare against self, is already done in prior function
				if(userData[vOptionButton + j] == userData[vOptionButton + index]) {
					combo_run(cboActionFailed);
					displayUpdate = TRUE; // Enable display update
					return 0;
				}
			}
		}
	}
	
	// Make sure we are not resetting
	if(verify_button != XB1_VIEW) {
		displayUpdate = TRUE; // Enable display update
		combo_run(cboActionSuccess); // Notify user of success setting toggle button
	}
	
	return verify_button; // Return button
}

// Verifies that a toggle combination is not already set
function verifyToggleCombo(verify_button, index) {
	// Loop through each set of toggle buttons
	for(j = 0; j < 4; j += 2) {
		if(userData[vToggleButton + j] && userData[vToggleButton + j + 1]) { // Make sure the buttons are accepted (0 = rejected from prior function)
			if(j != index) { // Do not compare against self, is already done in prior function
				if(userData[vToggleButton + j] == userData[vToggleButton + index] && userData[vToggleButton + j + 1] == userData[vToggleButton + index + 1]) {
					combo_run(cboActionFailed);
					return 0;
				}
			}
		}
	}
	
	// Make sure we are not resetting
	if(verify_button != XB1_VIEW) {
		displayUpdate = TRUE; // Enable display update
		combo_run(cboActionSuccess); // Notify user of success setting toggle button
	}
	
	return verify_button; // Return button
}

/**************************************************************/
// User-defined settings
/**************************************************************/
// Load user-defined configuration settings

int spvar_current_bit, spvar_current_slot, spvar_current_value, spvar_tmp, spvar_bits;

function reset_spvar() {

	 // Change this to say where it's safe to Roset storing data
	spvar_current_slot = SPVAR_1; 
	
	// Should always be 0, unless you're using part of the first SPVAR 
	// in which case you should also change the next line to include the 
	// value you are storing in the bits you are using
	
	spvar_current_bit = 0; 
	spvar_current_value = 0;
}

// Function used to count the number of bits used by the given value
function get_bit_count(v) {
	
	// We need to Roset at 0, we use spvar_tmp here as we need to track
	// the bits during our loop below
	spvar_tmp = 0; 
	
	// Loop while v is anything but 0
	while (v) { 
		// Increment the bit count by 1
		spvar_tmp++; 
		
		// Shift the value down 1 bit, once we have no more bits set this
		// will r in 0, unless the value is negative - in which case
		// this will be endless, we do abs here to make it always
		v = abs(v >> 1);
	}
	return spvar_tmp;
}

// Function used to count the number of bits used by 2 given values
function get_bit_count2(v1, v2) {

	// Get the highest bit count required for either min or max
	spvar_tmp = max(get_bit_count(v1), get_bit_count(v2));
	
	// Check if we need to know if the value is negative or not
	if (is_signed2(v1, v2)) {
		// If we need to track if the saved value is negative, we need 1 bit
		// for that specifically - the others are used to store the actual value
		spvar_tmp++;
	}
	return spvar_tmp;
}

// Function used to determine if either of 2 given values is negative
function is_signed2(v1, v2) {
	return (v1 < 0) || (v2 < 0);
}

// Function used to generate a bitmask for the sign bit, this will always be
// the highest bit in the range we're requesting it for, to do that - we need
// to Roset with the lowest bit set and move it up the number of steps there
// is between 1 and the bits we need, this needs to be a maximum of 31 but can
// never be negative
function make_sign(bits) { 
	return 1 << clamp(bits - 1, 0, 31);
}

// Function used to generate a full bitmask (essentially all bits set up to
// and including the number of bits given)
function make_full_mask(bits) {	

	// If we're wanting a bitmask for all bits, we can simply return -1
	// (which is all bits set to 1)
	if (bits == 32) { 
		return -1;
	}
	
	// What we do here is basically take a value with all bits except the highest
	// set and shift them down as many times as we need to get a mask that fits
	// the bit count we're looking for
	return 0x7FFFFFFF >> (31 - bits);
}

// Function used to generate a bitmask for just the bits required for the value
// part of a signed range, this means all the bits below the sign bit
function make_sign_mask(bits) {
	return make_full_mask(bits - 1);
}

// Function used to pack a value that has potential for being negative in a way
// that we use the least number of bits we really need to represent the value
function pack_i(v, bits) {

	// Check if we have a negative value, if so - handle it accordingly
	if (v < 0) { 
		// Get the positive version of the value and keep the bits that are within
		// range of what we're doing and add the sign bit since we have a negative
		// value and return the r
		return (abs(v) & make_sign_mask(bits)) | make_sign(bits);
	}
	
	// Get the bits that are within our range
	return v & make_sign_mask(bits); 
}

// Function used to unpack (restore) a value that has potential for being negative,
// essentially reversing what pack_i does above
function unpack_i(v, bits) {

	// Check if the stored value is supposed to be negative
	if (v & make_sign(bits)) {
		// Retrieve the stored positive value and subtract it from 0 (ring in
		// the same value except negative), return the r
		return 0 - (v & make_sign_mask(bits));
	}
	
	// Retrieve the stored positive value and return it
	return v & make_sign_mask(bits);
}

// Function used to read the value of a SPVAR without any limits
function read_spvar_slot(slot) {
	return get_pvar(slot, 0x80000000, 0x7FFFFFFF, 0);
}

// Function used to save your value in the SPVARs, this is the function you'll be
// calling when saving a value. You need to provide the value to save aswell as
// the range (minimum and maximum value, this is how we determine how many bits
// to use when saving this value)
function save_spvar(v, min, max) {

	// Set spvar_bits to the number of bits we need for this range
	spvar_bits = get_bit_count2(min, max); 
	
	// Make sure the value is within our defined range to begin with
	v = clamp(v, min, max); 
	
	// If either min or max is negative, we need to pack this value as a
	// possibly negative value
	if (is_signed2(min, max)) { 
		// Pack as signed value (possibly negative)
		v = pack_i(v, spvar_bits);
	}
	
	// Pack as unsigned value (always positive), this essentially just makes the
	// ring value not have any extra bits set - it's safe to use after the
	// signed packing since we're not using any bits outside of the unsigned range anyways
	v = v & make_full_mask(spvar_bits); 
	
	// Check if there is not enough bits remaining to save this value as-is. if
	// there aren't enough bits, we save what we can here and store the remaining
	// bits in the next spvar, if this means we're hitting the end, we can make
	// this smaller by handling the case where we use all bits here aswell
	if (spvar_bits >= 32 - spvar_current_bit) { 
		// Add what we can to the current value where there is bits available to use
		spvar_current_value = spvar_current_value | (v << spvar_current_bit); 
		// Save the current SPVAR before advancing to the next one
		set_pvar(spvar_current_slot, spvar_current_value); 
		// Move to the next slot
		spvar_current_slot++; 
		// Update the required bits according to our needs for the next slot, 
		// if we don't do this here, we'll screw up the saved value by moving
		// it too far out of range
		spvar_bits -= (32 - spvar_current_bit);
		// Move the remaining bits down, discarding the bits we've already saved
		v = v >> (32 - spvar_current_bit); 
		// Reset the current bit counter since we're Roseting with a new SPVAR
		spvar_current_bit = 0; 
		// Reset our value so we Roset clean, we aren't currently using any bits anyways
		spvar_current_value = 0; 
	}
	
	// Merge the current SPVAR value with our currently value where there is space to keep our value
	spvar_current_value = spvar_current_value | (v << spvar_current_bit); 
	// Move up the counter of next available bit to where we are currently saving data at
	spvar_current_bit += spvar_bits; 
	
	if (!spvar_current_bit) {
		// Reset our value so we Roset clean, we aren't currently using any bits anyways
		spvar_current_value = 0; 
	}
	
	// Save the SPVAR with the current value, this won't write anything to flash unless
	//the value changed - so we can do this for each variable saved to no risk missing anything
	set_pvar(spvar_current_slot, spvar_current_value); 
}

// Function used to read your value from the SPVARs, this is the function you'll be
// calling when reading a value. You need to provide the range (minimum and maximum
// value, this is how we determine how many bits to use when reading the value) aswell
// as a default value if what we read is out of range
function read_spvar(min, max) {

	// Set spvar_bits to the number of bits we need for this range
	spvar_bits = get_bit_count2(min, max); 
	
	// Read the current SPVAR value from flash and shift them into position,
	// we'll handle split values next
	spvar_current_value = (read_spvar_slot(spvar_current_slot) >> spvar_current_bit) & make_full_mask(spvar_bits);
	
	// Check if we are dealing with a split SPVAR value, essentially if the current
	// position means we're using more than 32 bits in the SPVAR, we need to retrieve
	// the missing bits from the next SPVAR and put them back to our current value,
	// we use the same space saving trick here as in the save function
	if (spvar_bits >= 32 - spvar_current_bit) {
		spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | ((read_spvar_slot(spvar_current_slot + 1) & make_full_mask(spvar_bits - (32 - spvar_current_bit))) << (32 - spvar_current_bit));
		//Below is a breakdown of the line above, with each step done one at a time instead of all at once - this however increases codesize - the below code is to explain how it all works tho
		//spvar_tmp = read_spvar_slot(spvar_current_slot + 1); // Read the SPVAR slot coming after the initial one we used to spvar_tmp from flash, we need to maintain the data we've read thus far, but also add on what we have in flash for the next SPVAR
		//spvar_tmp = spvar_tmp & make_full_mask(spvar_bits - (32 - spvar_current_bit)); // Extract the bits we need need (the ones that didn't fit in the previous SPVAR)
		//spvar_tmp = spvar_tmp << (32 - spvar_current_bit); // Move the bits into their original position, they were stored at the beginning of the new SPVAR but belong at the top of the currently read value
		//spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | spvar_tmp; // put all bits together again with the part read from the first SPVAR cleaned up to only include the bits from this variable/value and not all bits set in the upper range like they normally are
	}
	
	// Move up the counter of next available bit to where we are will be reading data from next
	spvar_current_bit += spvar_bits;
	// Extract all bits included for this value and discard any other bits
	spvar_current_value = spvar_current_value & make_full_mask(spvar_bits); 
	
	if (spvar_current_bit >= 32) {
		// Move to the next SPVAR slot
		spvar_current_slot++;
		// Remove 32 from the spvar_current_bit tracker since we've gone beyond what we can do here
		spvar_current_bit -= 32;
	}
	
	// Check if the value can be negative and handle it accordingly
	if (is_signed2(min, max)) { 
		// Restore the signed, possibly negative value
		spvar_current_value = unpack_i(spvar_current_value, spvar_bits); 
	}
	
	// Check if the value is below our specified min or above our specified max,
	// if so - return the default value instead
	if (spvar_current_value < min || spvar_current_value > max) { 
		// This can be changed to min instead as a reasonable default with the
		// default parameter being removed if you don't need to have a override
		// value for the default when out of range, that will save a bit of code size
		return 0; // edited
	}
	
	// Return the retrieved value to the user since it's within the expected range
	return spvar_current_value;
}


function loadSettings() {

	reset_spvar();
	
	// Read and check the first bit, if it is set, we know something should have been saved, otherwise we fall back on our default setting
	if(read_spvar(0, 1)) {
		/* Aim Assist */
		userData[vAimAssist]								= read_spvar(assistOff, assistAdsAndFireOrAds);
		userData[vAimAssistType]							= read_spvar(aat_mRadius, aat_pRadius);
		userData[vAimAssistAdsShape]						= read_spvar(aimAssistShapeMin, aimAssistShapeMax);
		userData[vAimAssistAdsRadius]						= read_spvar(1, 100);
		userData[vAimAssistAdsSpeed]						= read_spvar(1, 100);
		userData[vAimAssistFireShape]						= read_spvar(aimAssistShapeMin, aimAssistShapeMax);
		userData[vAimAssistFireRadius]						= read_spvar(1, 100);
		userData[vAimAssistFireSpeed]						= read_spvar(1, 100);
		userData[vRotationAssist]							= read_spvar(assistOff, assistAdsAndFireOrAds);
		userData[vRotationAdsShape]							= read_spvar(rasStrafe, rasRandom);
		userData[vRotationFireShape]						= read_spvar(rasStrafe, rasRandom);
		userData[vRotationAdsRadius]						= read_spvar(1, 100);
		userData[vRotationAdsSpeed]							= read_spvar(1, 120);
		userData[vRotationFireRadius]						= read_spvar(1, 100);
		userData[vRotationFireSpeed]						= read_spvar(1, 120)
		userData[vInverseAssist]							= read_spvar(assistOff, assistAdsAndFireOrAds);
		userData[vInverseAssistThreshold]					= read_spvar(0, 100);
		userData[vIdleTargetAssist]							= read_spvar(assistOff, assistOn);
		userData[vIdleTargetShape]							= read_spvar(aimAssistShapeMin, aimAssistShapeMax);
		userData[vIdleTargetTime]							= read_spvar(0, 100);
		userData[vIdleTargetRadius]							= read_spvar(1, 100);
		userData[vIdleTargetSpeed]							= read_spvar(1, 100);
		userData[vMotionAssist]								= read_spvar(assistOff, assistOn);
		userData[vMotionAdsShape]							= read_spvar(aimAssistShapeMin, aasHorizon);
		userData[vMotionAdsRadius]							= read_spvar(1, 100);
		userData[vMotionAdsSpeed]							= read_spvar(1, 100);
		userData[vMotionFireShape]							= read_spvar(aimAssistShapeMin, aasHorizon);
		userData[vMotionFireRadius]							= read_spvar(1, 100);
		userData[vMotionFireSpeed]							= read_spvar(1, 100);
		userData[vShapePulse]								= read_spvar(assistOff, assistOn);
		userData[vShapePulseAdsRadius]						= read_spvar(1, 100);
		userData[vShapePulseFireRadius]						= read_spvar(1, 100);
		userData[vShapeSpin]								= read_spvar(assistOff, assistAdsAndFireOrAds);
		userData[vShapeSpinAdsType]							= read_spvar(0, 1);
		userData[vShapeSpinFireType]						= read_spvar(0, 1);
		userData[vShapeSpinAdsAngle]						= read_spvar(1, 180);
		userData[vShapeSpinFireAngle]						= read_spvar(1, 180);
		
		/* Anti-drift */
		userData[vAntiDrift]								= read_spvar(0, 1);
		userData[vAntiDriftLeft + antiDriftUp]				= read_spvar(-8191, 8191);
		userData[vAntiDriftLeft + antiDriftDown]			= read_spvar(-8191, 8191);
		userData[vAntiDriftLeft + antiDriftLeft]			= read_spvar(-8191, 8191);
		userData[vAntiDriftLeft + antiDriftRight]			= read_spvar(-8191, 8191);
		userData[vAntiDriftRight + antiDriftUp]				= read_spvar(-8191, 8191);
		userData[vAntiDriftRight + antiDriftDown]			= read_spvar(-8191, 8191);
		userData[vAntiDriftRight + antiDriftLeft]			= read_spvar(-8191, 8191);
		userData[vAntiDriftRight + antiDriftRight]			= read_spvar(-8191, 8191);
		
		/* Anti-recoil */
		userData[vAntiRecoil]								= read_spvar(antiRecoilOff, antiRecoilAdvanced);
		userData[vAntiRecoilStrength]						= read_spvar(1, 100);
		userData[vAntiRecoilKickStrength]					= read_spvar(1, 100);
		userData[vAntiRecoilKickDuration]					= read_spvar(1, 200);
						
		/* Controller */
		userData[vControllerConfiguration] 					= read_spvar(oldSchool, customLayout);
		userData[vControllerEditHoldTime]					= read_spvar(100, 250);
		userData[vControllerEditPressType]					= read_spvar(buttonTap, buttonHold);
		userData[vControllerHarvestPressType]				= read_spvar(buttonTap, buttonHold);
		
		userData[vControllerButton + ads_button]			= read_spvar(0, XB1_X);
		userData[vControllerButton + attack_button]			= read_spvar(0, XB1_X);
		userData[vControllerButton + build_mode_button]		= read_spvar(0, XB1_X);
		userData[vControllerButton + confirm_button]		= read_spvar(0, XB1_X);
		userData[vControllerButton + edit_button]			= read_spvar(0, XB1_X);
		userData[vControllerButton + harvest_button]		= read_spvar(0, XB1_X);
		userData[vControllerButton + inventory_button]		= read_spvar(0, XB1_X);
		userData[vControllerButton + next_weapon_button]	= read_spvar(0, XB1_X);
		userData[vControllerButton + ping_button]			= read_spvar(0, XB1_X);
		userData[vControllerButton + previous_weapon_button]= read_spvar(0, XB1_X);
		userData[vControllerButton + reset_button]			= read_spvar(0, XB1_X);
		userData[vControllerButton + select_button]			= read_spvar(0, XB1_X);
		
		/* Options */
		userData[vOptionAutoHarvest]						= read_spvar(0, 1);
		userData[vOptionAutoPing]							= read_spvar(0, 1);
		userData[vOptionAutoPingInterval]					= read_spvar(0, 8);
		userData[vOptionBuildTracker]						= read_spvar(0, 1);
		userData[vOptionEditAssist]							= read_spvar(0, 1);
		userData[vOptionFastReset]							= read_spvar(resetOff, resetRepeat);
		userData[vOptionHairTriggers]						= read_spvar(0, 1);
		userData[vOptionInstantPickaxe]						= read_spvar(0, 1);
		userData[vOptionRapidFire]							= read_spvar(0, 1);
		userData[vOptionRapidFireSpeed]						= read_spvar(1, 60);
	
		/* Options Buttons */
		userData[vOptionButton + buttonAutoHarvest]			= read_spvar(0, XB1_X);
		userData[vOptionButton + buttonEditAssist]			= read_spvar(0, XB1_X);
		userData[vOptionButton + buttonFastReset]			= read_spvar(0, XB1_X);
		
		/* Settings */
		userData[vBlockRumble] 								= read_spvar(0, 1);
		userData[vDeadzone + deadzoneLeft]					= read_spvar(5, 15);
		userData[vDeadzone + deadzoneRight]					= read_spvar(5, 15);
		userData[vInverted] 								= read_spvar(0, 1);
		userData[vScreenSaver] 								= read_spvar(screenSaverOff, screenSaverVisualizer);
		userData[vSmoothing] 								= read_spvar(0, 1);
		userData[vVMSpeed]									= read_spvar(vmSpeed4, vmSpeed10);
		
		/* Toggles */
		for(i = 0; i < 4; i++) {
			userData[vToggleButton + i] = read_spvar(0, XB1_X);
		}
	} else {
		/* Aim Assist */
		userData[vAimAssist]						= assistOff;
		userData[vAimAssistType]					= aat_pRadius;
		userData[vAimAssistAdsShape] 				= aasDiamond;
		userData[vAimAssistAdsRadius]				= 13;
		userData[vAimAssistAdsSpeed]				= 30;
		userData[vAimAssistFireShape] 				= aasLemniscate;
		userData[vAimAssistFireRadius]				= 12;
		userData[vAimAssistFireSpeed]				= 20;
		userData[vRotationAssist]					= assistOff;
		userData[vRotationAdsShape]					= rasCircle;
		userData[vRotationFireShape]				= rasStrafe;
		userData[vRotationAdsRadius]				= 35;
		userData[vRotationAdsSpeed]					= 45;
		userData[vRotationFireRadius]				= 30;
		userData[vRotationFireSpeed]				= 12; // 80ms on -2 VM
		userData[vInverseAssist]					= assistOff;
		userData[vInverseAssistThreshold]			= 0;
		userData[vIdleTargetAssist]					= assistOff;
		userData[vIdleTargetShape]					= aasHorizon;
		userData[vIdleTargetTime]					= 35; // 280ms on -2 VM
		userData[vIdleTargetRadius]					= 12;
		userData[vIdleTargetSpeed]					= 26;
		userData[vMotionAssist]						= assistOff;
		userData[vMotionAdsShape]					= aasCircle;
		userData[vMotionAdsRadius]					= 5;
		userData[vMotionAdsSpeed]					= 15;
		userData[vMotionFireShape]					= aasLemniscate;
		userData[vMotionFireRadius]					= 9;
		userData[vMotionFireSpeed]					= 45;
		userData[vShapePulse]						= assistOff;
		userData[vShapePulseAdsRadius]				= userData[vAimAssistAdsRadius] + 2;
		userData[vShapePulseFireRadius]				= userData[vAimAssistFireRadius] + 2;
		userData[vShapeSpin]						= assistOff;
		userData[vShapeSpinAdsType]					= 1;
		userData[vShapeSpinFireType]				= 1;
		userData[vShapeSpinAdsAngle]				= 45;
		userData[vShapeSpinFireAngle]				= 90;
		
		/* Anti-drift */
		userData[vAntiDrift]							= 0;
		userData[vAntiDriftLeft + antiDriftUp]			= 0;
		userData[vAntiDriftLeft + antiDriftDown]		= 0;
		userData[vAntiDriftLeft + antiDriftLeft]		= 0;
		userData[vAntiDriftLeft + antiDriftRight]		= 0;
		userData[vAntiDriftRight + antiDriftUp]			= 0;
		userData[vAntiDriftRight + antiDriftDown]		= 0;
		userData[vAntiDriftRight + antiDriftLeft]		= 0;
		userData[vAntiDriftRight + antiDriftRight]		= 0;
		
		/* Anti-recoil */
		userData[vAntiRecoil]							= antiRecoilOff;
		userData[vAntiRecoilStrength]					= 20;
		userData[vAntiRecoilKickStrength]				= 22;
		userData[vAntiRecoilKickDuration]				= 10;
		
		/* Controller */
		userData[vControllerConfiguration] 				= oldSchool;
		userData[vControllerEditHoldTime]				= 200;
		
		/* Options */
		userData[vOptionAutoPing]						= 0;
		userData[vOptionAutoPingInterval]				= 0;
		userData[vOptionRapidFire]						= 0;
		userData[vOptionRapidFireSpeed]					= 12;
		userData[vOptionHairTriggers]					= 0;
		
		/* Settings */
		userData[vBlockRumble] 							= 0;
		userData[vDeadzone + deadzoneLeft] 				= 5;
		userData[vDeadzone + deadzoneRight] 			= 5;
		userData[vInverted]								= 0;
		userData[vScreenSaver] 							= screenSaverBlank;
		userData[vSmoothing] 							= 0;
		userData[vVMSpeed]								= vmSpeed10;
		
		/* Toggles */
		for(i = 0; i < 4; i++) {
			userData[vToggleButton + i] = 0;
		}
		
		if(DEVELOPER) {
			userData[vAntiDrift]							= 1;
			userData[vAntiDriftLeft + antiDriftUp]			= -2666;
			userData[vAntiDriftLeft + antiDriftDown]		= 763;
			userData[vAntiDriftLeft + antiDriftLeft]		= 683;
			userData[vAntiDriftLeft + antiDriftRight]		= 3160;
			userData[vAntiDriftRight + antiDriftUp]			= -4078;
			userData[vAntiDriftRight + antiDriftDown]		= -2735;
			userData[vAntiDriftRight + antiDriftLeft]		= 2528;
			userData[vAntiDriftRight + antiDriftRight]		= 4523;
			userData[vBlockRumble] 							= 1;
			userData[vControllerConfiguration]				= customLayout;
			userData[vControllerButton + ads_button]		= XB1_LT;
			userData[vControllerButton + attack_button]		= XB1_RT;
			userData[vControllerButton + build_mode_button]	= XB1_RS;
			userData[vControllerButton + confirm_button]	= XB1_B;
			userData[vControllerButton + edit_button]		= XB1_LS;
			userData[vControllerButton + harvest_button]	= XB1_Y;
			userData[vControllerButton + inventory_button]	=XB1_DOWN;
			userData[vControllerButton + next_weapon_button]=XB1_RB;
			userData[vControllerButton + previous_weapon_button] = XB1_LB;
			userData[vControllerButton + reset_button]		= XB1_RS;
			userData[vControllerButton + select_button]		= XB1_RT;
			userData[vDeadzone + deadzoneLeft] 				= 8;
			userData[vDeadzone + deadzoneRight] 			= 8;
			userData[vInverted]								= 1;
		}
	}
	setControllerConfig(); // Set controller configuration
}

function initReadWrite() {
	spvar_index = SPVAR_1;
	bit_position = unpacked_bits = spvar_data = 0;
}

// Save user-defined configuration settings
function saveSettings() {

	reset_spvar();
	
	// Save a constant 1 to denote previously saved data, this range uses 1 bit
	save_spvar(1, 0, 1);
	/* Aim Assist */
	save_spvar(userData[vAimAssist], assistOff, assistAdsAndFireOrAds);
	save_spvar(userData[vAimAssistType], aat_mRadius, aat_pRadius);
	save_spvar(userData[vAimAssistAdsShape], aimAssistShapeMin, aimAssistShapeMax);
	save_spvar(userData[vAimAssistAdsRadius], 1, 100);
	save_spvar(userData[vAimAssistAdsSpeed], 1, 100);
	save_spvar(userData[vAimAssistFireShape], aimAssistShapeMin, aimAssistShapeMax);
	save_spvar(userData[vAimAssistFireRadius], 1, 100);
	save_spvar(userData[vAimAssistFireSpeed], 1, 100);
	save_spvar(userData[vRotationAssist], assistOff, assistAdsAndFireOrAds);
	save_spvar(userData[vRotationAdsShape], rasStrafe, rasRandom);
	save_spvar(userData[vRotationFireShape], rasStrafe, rasRandom);
	save_spvar(userData[vRotationAdsRadius], 1, 100);
	save_spvar(userData[vRotationAdsSpeed], 1, 120);
	save_spvar(userData[vRotationFireRadius], 1, 100);
	save_spvar(userData[vRotationFireSpeed], 1, 120);
	save_spvar(userData[vInverseAssist], assistOff, assistAdsAndFireOrAds);
	save_spvar(userData[vInverseAssistThreshold], 0, 100);
	save_spvar(userData[vIdleTargetAssist], assistOff, assistOn);
	save_spvar(userData[vIdleTargetShape], aimAssistShapeMin, aimAssistShapeMax);
	save_spvar(userData[vIdleTargetTime], 0, 100);
	save_spvar(userData[vIdleTargetRadius], 1, 100);
	save_spvar(userData[vIdleTargetSpeed], 1, 100);
	save_spvar(userData[vMotionAssist], assistOff, assistAdsAndFireOrAds);
	save_spvar(userData[vMotionAdsShape], aimAssistShapeMin, aasHorizon);
	save_spvar(userData[vMotionAdsRadius], 1, 100);
	save_spvar(userData[vMotionAdsSpeed], 1, 100);
	save_spvar(userData[vMotionFireShape], assistOff, assistAdsAndFireOrAds);
	save_spvar(userData[vMotionFireRadius], 1, 100);
	save_spvar(userData[vMotionFireSpeed], 1, 100);
	save_spvar(userData[vShapePulse], assistOff, assistAdsAndFireOrAds);
	save_spvar(userData[vShapePulseAdsRadius], 1, 100);
	save_spvar(userData[vShapePulseFireRadius], 1, 100);
	save_spvar(userData[vShapeSpin], assistOff, assistAdsAndFireOrAds);
	save_spvar(userData[vShapeSpinAdsType], 0, 1);
	save_spvar(userData[vShapeSpinFireType], 0, 1);
	save_spvar(userData[vShapeSpinAdsAngle], 1, 180);
	save_spvar(userData[vShapeSpinFireAngle], 1, 180);
	
	/* Anti-drift */
	save_spvar(userData[vAntiDrift], 0, 1);
	save_spvar(userData[vAntiDriftLeft + antiDriftUp], -8191, 8191);
	save_spvar(userData[vAntiDriftLeft + antiDriftDown], -8191, 8191);
	save_spvar(userData[vAntiDriftLeft + antiDriftLeft], -8191, 8191);
	save_spvar(userData[vAntiDriftLeft + antiDriftRight], -8191, 8191);
	save_spvar(userData[vAntiDriftRight + antiDriftUp], -8191, 8191);
	save_spvar(userData[vAntiDriftRight + antiDriftDown], -8191, 8191);
	save_spvar(userData[vAntiDriftRight + antiDriftLeft], -8191, 8191);
	save_spvar(userData[vAntiDriftRight + antiDriftRight], -8191, 8191);
	
	/* Anti-recoil */
	save_spvar(userData[vAntiRecoil], antiRecoilOff, antiRecoilAdvanced);
	save_spvar(userData[vAntiRecoilStrength], 1, 100);
	save_spvar(userData[vAntiRecoilKickStrength], 1, 100);
	save_spvar(userData[vAntiRecoilKickDuration], 1, 200);
	
	/* Controller */
	save_spvar(userData[vControllerConfiguration], oldSchool, customLayout);
	save_spvar(userData[vControllerEditHoldTime], 100, 250);
	save_spvar(userData[vControllerEditPressType], buttonTap, buttonHold);
	save_spvar(userData[vControllerHarvestPressType], buttonTap, buttonHold);
	save_spvar(userData[vControllerButton + ads_button], 0, XB1_X);
	save_spvar(userData[vControllerButton + attack_button], 0, XB1_X);
	save_spvar(userData[vControllerButton + build_mode_button], 0, XB1_X);
	save_spvar(userData[vControllerButton + confirm_button], 0, XB1_X);
	save_spvar(userData[vControllerButton + edit_button], 0, XB1_X);
	save_spvar(userData[vControllerButton + harvest_button], 0, XB1_X);
	save_spvar(userData[vControllerButton + inventory_button], 0, XB1_X);
	save_spvar(userData[vControllerButton + next_weapon_button], 0, XB1_X);
	save_spvar(userData[vControllerButton + ping_button], 0, XB1_X);
	save_spvar(userData[vControllerButton + previous_weapon_button], 0, XB1_X);
	save_spvar(userData[vControllerButton + reset_button], 0, XB1_X);
	save_spvar(userData[vControllerButton + select_button], 0, XB1_X);
		
	/* Options */
	save_spvar(userData[vOptionAutoHarvest], 0, 1);
	save_spvar(userData[vOptionAutoPing], 0, 1);
	save_spvar(userData[vOptionAutoPingInterval], 0, 8);
	save_spvar(userData[vOptionBuildTracker], 0, 1);
	save_spvar(userData[vOptionEditAssist], 0, 1);
	save_spvar(userData[vOptionFastReset], resetOff, resetRepeat);
	save_spvar(userData[vOptionHairTriggers], 0, 1);
	save_spvar(userData[vOptionInstantPickaxe], 0, 1);
	save_spvar(userData[vOptionRapidFire], 0, 1);
	save_spvar(userData[vOptionRapidFireSpeed], 1, 60);
	
	/* Options Buttons */
	save_spvar(userData[vOptionButton + buttonAutoHarvest], 0, XB1_X);
	save_spvar(userData[vOptionButton + buttonEditAssist], 0, XB1_X);
	save_spvar(userData[vOptionButton + buttonFastReset], 0, XB1_X);
		
	/* Settings */
	save_spvar(userData[vBlockRumble], 0, 1);
	save_spvar(userData[vDeadzone + deadzoneLeft], 5, 15);
	save_spvar(userData[vDeadzone + deadzoneRight], 5, 15);
	save_spvar(userData[vInverted], 0, 1);
	save_spvar(userData[vScreenSaver], screenSaverOff, screenSaverVisualizer);
	save_spvar(userData[vSmoothing], 0, 1);
	save_spvar(userData[vVMSpeed], vmSpeed4, vmSpeed10);

	/* Toggles */
	for(i = 0; i < 4; i++) {
		save_spvar(userData[vToggleButton + i], 0, XB1_X);
	}
	
	setControllerConfig();

	// Debug purposes (make sure we have enough memory)
	set_val(TRACE_1, spvar_current_slot);
}

/**************************************************************/
// Combos
/**************************************************************/
combo cboActionSuccess {
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	set_rumble(RUMBLE_B, 80);
	wait(240);
	reset_rumble();
}

combo cboActionFailed {
	set_hsb(colorValues[red][hue], colorValues[red][saturation], colorValues[red][brightness]);
	set_rumble(RUMBLE_A, 80);
	wait(240);
	reset_rumble();
}

combo cboAlertRapidFire {
	setLedColor(yellow);
	wait(240);
	set_hsb(0, 0, 0); // Off
	wait(240);
}

combo cboAlertScriptPaused {
	set_rgb(255, 30, 0);
	wait(120);
	set_rgb(0, 0, 0);
	wait(120);
}

combo cboCalibrationComplete {
	// Notify user of status
	cls_oled(OLED_BLACK);
	set_rumble(RUMBLE_B, 100);
	setLedColor(iif(antiDriftCalibrationCanSet == 2, yellow, iif(antiDriftCalibrationCanSet, green, red)));
	printText(alignCenter, alignCenter, antiDriftCalibrationResult[antiDriftCalibrationCanSet], OLED_FONT_SMALL, OLED_WHITE);
	wait(1440);
	reset_rumble();
	// Clear calibration state
	antiDriftCalibrationState = !antiDriftCalibrationState; 
	// Enable display update
	displayUpdate = TRUE; 
	// Reset calibration variables
	antiDriftCalibrationCanSet = FALSE;
	antiDriftCalibrationInRange = FALSE;
}

combo cboClearScreen {
	cls_oled(OLED_BLACK);
}

combo cboGreeting {
	call(cboClearScreen);
	executeGreeting();
	wait(2400);
	call(cboGreetingText);
}

combo cboGreetingText {
	wait(360);
	printText(alignCenter, alignCenter, apollo[0], OLED_FONT_MEDIUM, OLED_WHITE);
	set_rumble(RUMBLE_A, 50);
	wait(720);
	set_rumble(RUMBLE_A, 50);
	set_rumble(RUMBLE_B, 100);
	wait(720);
	reset_rumble();
	wait(1560);
	
}

combo cboOptionAutoPing {
	call(cboOptionAutoPingOnce);
	set_val(combat[ping], 0);
	wait(userData[vOptionAutoPingInterval] * 120);
}

combo cboOptionAutoPingOnce {
	set_val(combat[ping], 100);
	wait(120);
}

combo cboOptionEditAssist {
	set_val(userData[vOptionButton + buttonEditAssist], 0);
	set_val(build[edit], 100);
	wait(iif(userData[vControllerConfiguration] != customLayout, userData[vControllerEditHoldTime] + 20, 20));
}

combo cboOptionFastReset {
	if(userData[vOptionButton + buttonFastReset] == build[rotate_repair_reset]) {
		set_val(build[rotate_repair_reset], 0);
	}
	set_val(build[edit], 100);
	wait(iif(userData[vControllerConfiguration] != customLayout, userData[vControllerEditHoldTime] + 20, 20));
	set_val(build[rotate_repair_reset], 100);
	wait(40);
	set_val(userData[vControllerButton + confirm_button], 100);
	wait(40);
}

combo cboOptionRapidFire {
	// Low value (LCM of possible VM speeds) for immediate fire
	wait(120 / userData[vOptionRapidFireSpeed]);
	set_val(combat[attack], 0);
	wait(880 / userData[vOptionRapidFireSpeed]);
}


combo cboResetRepair {
	set_val(build[rotate_repair_reset], 0);
	wait(40);
	set_val(build[rotate_repair_reset], 100);
	wait(40);
}

combo cboSaveSettings {
	cls_oled(OLED_BLACK);
	printText(alignCenter, alignCenter, settingsSaved[0], OLED_FONT_SMALL, OLED_WHITE);
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	set_rumble(RUMBLE_B, 100);
	wait(480);
	reset_rumble(); // Reset rumble state
	saveSettings(); // Save settings
	displayUpdate = TRUE; // Enable display update
}

combo cboToggleAutoPing {
	if(userData[vOptionAutoPing]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[0]);
	insertString(toggleOffOn[userData[vOptionAutoPing]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleRapidFire {
	if(userData[vOptionRapidFire]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[1]);
	insertString(toggleOffOn[userData[vOptionRapidFire]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleOff {
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	set_hsb(colorValues[red][hue], colorValues[red][saturation], colorValues[red][brightness]);
	wait(240);
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	reset_rumble();
}

combo cboToggleOn {
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_B, 75);
	wait(120);
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	wait(240);
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	reset_rumble();
}

/**************************************************************/
// Tables
/**************************************************************/
//
// Polar stick values (0 - 100)
const int16 polarValues[] = {
    0,
	328, 655, 983, 1311, 1638, 1966, 2294, 2621, 2949, 3277,
    3604, 3932, 4260, 4587, 4915, 5243, 5570, 5898, 6226, 6553,
    6881, 7209, 7536, 7864, 8192, 8519, 8847, 9175, 9502, 9830,
    10158, 10485, 10813, 11141, 11468, 11796, 12124, 12451, 12779, 13107,
    13434, 13762, 14090, 14417, 14745, 15073, 15400, 15728, 16056, 16384,
    16711, 17039, 17367, 17694, 18022, 18350, 18677, 19005, 19333, 19660,
    19988, 20316, 20643, 20971, 21299, 21626, 21954, 22282, 22609, 22937,
    23265, 23592, 23920, 24248, 24575, 24903, 25231, 25558, 25886, 26214,
    26541, 26869, 27197, 27524, 27852, 28180, 28507, 28835, 29163, 29490,
    29818, 30146, 30473, 30801, 31129, 31456, 31784, 32112, 32439, 32767
}

const int16 orbitX[] = {
	0, 29, 57, 85, 112, 138, 163, 187, 209, 229, 247, 263, 278, 289, 299, 306, 310, 312,
	312, 309, 303, 295, 285, 273, 259, 243, 226, 206, 186, 164, 142, 119, 95, 71, 47, 23,
	0, -23, -45, -66, -86, -105, -122, -137, -152, -164, -174, -183, -190, -195, -198, -199, -199, -196,
	-193, -187, -180, -172, -163, -153, -142, -130, -118, -105, -92, -79, -67, -54, -42, -30, -19, -9,
	-0, 8, 16, 22, 27, 31, 34, 36, 37, 36, 35, 33, 30, 26, 21, 17, 11, 6,
	0, -6, -11, -17, -21, -26, -30, -33, -35, -36, -37, -36, -34, -31, -27, -22, -16, -8,
	-0, 9, 19, 30, 42, 54, 67, 79, 92, 105, 118, 130, 142, 153, 163, 172, 180, 187,
	193, 196, 199, 199, 198, 195, 190, 183, 174, 164, 152, 137, 122, 105, 86, 66, 45, 23,
	0, -23, -47, -71, -95, -119, -142, -164, -186, -206, -226, -243, -259, -273, -285, -295, -303, -309,
	-312, -312, -310, -306, -299, -289, -278, -263, -247, -229, -209, -187, -163, -138, -112, -85, -57, -29,
	-0, 29, 57, 85, 112, 138, 163, 187, 209, 229, 247, 263, 278, 289, 299, 306, 310, 312,
	312, 309, 303, 295, 285, 273, 259, 243, 226, 206, 186, 164, 142, 119, 95, 71, 47, 23,
	0, -23, -45, -66, -86, -105, -122, -137, -152, -164, -174, -183, -190, -195, -198, -199, -199, -196,
	-193, -187, -180, -172, -163, -153, -142, -130, -118, -105, -92, -79, -67, -54, -42, -30, -19, -9,
	-0, 8, 16, 22, 27, 31, 34, 36, 37, 36, 35, 33, 30, 26, 21, 17, 11, 6,
	0, -6, -11, -17, -21, -26, -30, -33, -35, -36, -37, -36, -34, -31, -27, -22, -16, -8,
	-0, 9, 19, 30, 42, 54, 67, 79, 92, 105, 118, 130, 142, 153, 163, 172, 180, 187,
	193, 196, 199, 199, 198, 195, 190, 183, 174, 164, 152, 137, 122, 105, 86, 66, 45, 23,
	0, -23, -47, -71, -95, -119, -142, -164, -186, -206, -226, -243, -259, -273, -285, -295, -303, -309,
	-312, -312, -310, -306, -299, -289, -278, -263, -247, -229, -209, -187, -163, -138, -112, -85, -57, -29
}

const int16 orbitY[] = {
	0, 6, 11, 17, 21, 26, 30, 33, 35, 36, 37, 36, 34, 31, 27, 22, 16, 8,
	0, -9, -19, -30, -42, -54, -67, -79, -92, -105, -118, -130, -142, -153, -163, -172, -180, -187,
	-193, -196, -199, -199, -198, -195, -190, -183, -174, -164, -152, -137, -122, -105, -86, -66, -45, -23,
	-0, 23, 47, 71, 95, 119, 142, 164, 186, 206, 226, 243, 259, 273, 285, 295, 303, 309,
	312, 312, 310, 306, 299, 289, 278, 263, 247, 229, 209, 187, 163, 138, 112, 85, 57, 29,
	0, -29, -57, -85, -112, -138, -163, -187, -209, -229, -247, -263, -278, -289, -299, -306, -310, -312,
	-312, -309, -303, -295, -285, -273, -259, -243, -226, -206, -186, -164, -142, -119, -95, -71, -47, -23,
	-0, 23, 45, 66, 86, 105, 122, 137, 152, 164, 174, 183, 190, 195, 198, 199, 199, 196,
	193, 187, 180, 172, 163, 153, 142, 130, 118, 105, 92, 79, 67, 54, 42, 30, 19, 9,
	0, -8, -16, -22, -27, -31, -34, -36, -37, -36, -35, -33, -30, -26, -21, -17, -11, -6,
	-0, 6, 11, 17, 21, 26, 30, 33, 35, 36, 37, 36, 34, 31, 27, 22, 16, 8,
	0, -9, -19, -30, -42, -54, -67, -79, -92, -105, -118, -130, -142, -153, -163, -172, -180, -187,
	-193, -196, -199, -199, -198, -195, -190, -183, -174, -164, -152, -137, -122, -105, -86, -66, -45, -23,
	-0, 23, 47, 71, 95, 119, 142, 164, 186, 206, 226, 243, 259, 273, 285, 295, 303, 309,
	312, 312, 310, 306, 299, 289, 278, 263, 247, 229, 209, 187, 163, 138, 112, 85, 57, 29,
	0, -29, -57, -85, -112, -138, -163, -187, -209, -229, -247, -263, -278, -289, -299, -306, -310, -312,
	-312, -309, -303, -295, -285, -273, -259, -243, -226, -206, -186, -164, -142, -119, -95, -71, -47, -23,
	-0, 23, 45, 66, 86, 105, 122, 137, 152, 164, 174, 183, 190, 195, 198, 199, 199, 196,
	193, 187, 180, 172, 163, 153, 142, 130, 118, 105, 92, 79, 67, 54, 42, 30, 19, 9,
	0, -8, -16, -22, -27, -31, -34, -36, -37, -36, -35, -33, -30, -26, -21, -17, -11, -6
}

const int16 heartX[] = {
    0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 3, 4, 5, 6, 7, 8,
    10, 11, 13, 15, 17, 20, 22, 25, 28, 31, 34, 37, 41, 45, 49, 53, 57, 62,
    67, 71, 76, 82, 87, 93, 98, 104, 110, 116, 122, 128, 134, 141, 147, 154, 160, 167,
    173, 180, 187, 193, 200, 206, 213, 219, 226, 232, 238, 244, 250, 256, 261, 267, 272, 277,
    282, 287, 291, 295, 299, 303, 307, 310, 313, 316, 318, 320, 322, 324, 325, 326, 327, 328,
    328, 328, 327, 326, 325, 324, 322, 320, 318, 316, 313, 310, 307, 303, 299, 295, 291, 287,
    282, 277, 272, 267, 261, 256, 250, 244, 238, 232, 226, 219, 213, 206, 200, 193, 187, 180,
    173, 167, 160, 154, 147, 141, 134, 128, 122, 116, 110, 104, 98, 93, 87, 82, 76, 71,
    67, 62, 57, 53, 49, 45, 41, 37, 34, 31, 28, 25, 22, 20, 17, 15, 13, 11,
    10, 8, 7, 6, 5, 4, 3, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0,
    0, -0, -0, -0, -0, -0, -0, -1, -1, -1, -2, -2, -3, -4, -5, -6, -7, -8,
    -10, -11, -13, -15, -17, -20, -22, -25, -28, -31, -34, -37, -41, -45, -49, -53, -57, -62,
    -67, -71, -76, -82, -87, -93, -98, -104, -110, -116, -122, -128, -134, -141, -147, -154, -160, -167,
    -173, -180, -187, -193, -200, -206, -213, -219, -226, -232, -238, -244, -250, -256, -261, -267, -272, -277,
    -282, -287, -291, -295, -299, -303, -307, -310, -313, -316, -318, -320, -322, -324, -325, -326, -327, -328,
    -328, -328, -327, -326, -325, -324, -322, -320, -318, -316, -313, -310, -307, -303, -299, -295, -291, -287,
    -282, -277, -272, -267, -261, -256, -250, -244, -238, -232, -226, -219, -213, -206, -200, -193, -187, -180,
    -173, -167, -160, -154, -147, -141, -134, -128, -122, -116, -110, -104, -98, -93, -87, -82, -76, -71,
    -67, -62, -57, -53, -49, -45, -41, -37, -34, -31, -28, -25, -22, -20, -17, -15, -13, -11,
    -10, -8, -7, -6, -5, -4, -3, -2, -2, -1, -1, -1, -0, -0, -0, -0, -0, -0, -0
}

const int16 heartY[] = {
    -96, -96, -97, -97, -98, -99, -100, -102, -104, -106, -108, -110, -113, -115, -118, -121, -125, -128,
    -131, -135, -139, -143, -146, -150, -154, -158, -162, -166, -170, -174, -178, -182, -186, -190, -193, -197,
    -200, -203, -206, -209, -212, -215, -217, -219, -221, -223, -225, -226, -227, -228, -229, -229, -229, -229,
    -229, -228, -227, -226, -225, -223, -221, -219, -217, -214, -211, -208, -205, -201, -197, -193, -189, -185,
    -180, -176, -171, -166, -160, -155, -150, -144, -138, -132, -127, -121, -115, -108, -102, -96, -90, -83,
    -77, -71, -64, -58, -51, -45, -38, -32, -26, -19, -13, -7, -0, 6, 12, 18, 24, 30,
    37, 43, 49, 54, 60, 66, 72, 78, 83, 89, 95, 100, 106, 111, 117, 122, 128, 133,
    138, 144, 149, 154, 159, 164, 170, 175, 180, 185, 190, 195, 200, 205, 209, 214, 219, 224,
    228, 233, 238, 242, 246, 251, 255, 259, 263, 267, 271, 275, 279, 283, 286, 289, 293, 296,
    299, 302, 305, 307, 310, 312, 314, 316, 318, 320, 321, 323, 324, 325, 326, 326, 327, 327,
    327, 327, 327, 326, 326, 325, 324, 323, 321, 320, 318, 316, 314, 312, 310, 307, 305, 302,
    299, 296, 293, 289, 286, 283, 279, 275, 271, 267, 263, 259, 255, 251, 246, 242, 238, 233,
    228, 224, 219, 214, 209, 205, 200, 195, 190, 185, 180, 175, 170, 164, 159, 154, 149, 144,
    138, 133, 128, 122, 117, 111, 106, 100, 95, 89, 83, 78, 72, 66, 60, 54, 49, 43,
    37, 30, 24, 18, 12, 6, -0, -7, -13, -19, -26, -32, -38, -45, -51, -58, -64, -71,
    -77, -83, -90, -96, -102, -108, -115, -121, -127, -132, -138, -144, -150, -155, -160, -166, -171, -176,
    -180, -185, -189, -193, -197, -201, -205, -208, -211, -214, -217, -219, -221, -223, -225, -226, -227, -228,
    -229, -229, -229, -229, -229, -228, -227, -226, -225, -223, -221, -219, -217, -215, -212, -209, -206, -203,
    -200, -197, -193, -190, -186, -182, -178, -174, -170, -166, -162, -158, -154, -150, -146, -143, -139, -135,
    -131, -128, -125, -121, -118, -115, -113, -110, -108, -106, -104, -102, -100, -99, -98, -97, -97, -96, -96
}

const int16 sin[] = { 
	0, 6, 11, 17, 23, 29, 34, 40, 46, 51, 57, 63, 68, 74, 79, 85, 90, 96,
	101, 107, 112, 117, 123, 128, 133, 138, 144, 149, 154, 159, 164, 169, 174, 178, 183, 188,
	193, 197, 202, 206, 211, 215, 219, 223, 228, 232, 236, 240, 244, 247, 251, 255, 258, 262,
	265, 268, 272, 275, 278, 281, 284, 287, 289, 292, 295, 297, 299, 302, 304, 306, 308, 310,
	312, 313, 315, 317, 318, 319, 321, 322, 323, 324, 324, 325, 326, 326, 327, 327, 327, 328,
	328, 328, 327, 327, 327, 326, 326, 325, 324, 324, 323, 322, 321, 319, 318, 317, 315, 313,
	312, 310, 308, 306, 304, 302, 299, 297, 295, 292, 289, 287, 284, 281, 278, 275, 272, 268,
	265, 262, 258, 255, 251, 247, 244, 240, 236, 232, 228, 223, 219, 215, 211, 206, 202, 197,
	193, 188, 183, 178, 174, 169, 164, 159, 154, 149, 144, 138, 133, 128, 123, 117, 112, 107,
	101, 96, 90, 85, 79, 74, 68, 63, 57, 51, 46, 40, 34, 29, 23, 17, 11, 6,
	0, -6, -11, -17, -23, -29, -34, -40, -46, -51, -57, -63, -68, -74, -79, -85, -90, -96,
	-101, -107, -112, -117, -123, -128, -133, -138, -144, -149, -154, -159, -164, -169, -174, -178, -183, -188,
	-193, -197, -202, -206, -211, -215, -219, -223, -228, -232, -236, -240, -244, -247, -251, -255, -258, -262,
	-265, -268, -272, -275, -278, -281, -284, -287, -289, -292, -295, -297, -299, -302, -304, -306, -308, -310,
	-312, -313, -315, -317, -318, -319, -321, -322, -323, -324, -324, -325, -326, -326, -327, -327, -327, -328,
	-328, -328, -327, -327, -327, -326, -326, -325, -324, -324, -323, -322, -321, -319, -318, -317, -315, -313,
	-312, -310, -308, -306, -304, -302, -299, -297, -295, -292, -289, -287, -284, -281, -278, -275, -272, -268,
	-265, -262, -258, -255, -251, -247, -244, -240, -236, -232, -228, -223, -219, -215, -211, -206, -202, -197,
	-193, -188, -183, -178, -174, -169, -164, -159, -154, -149, -144, -138, -133, -128, -123, -117, -112, -107,
	-101, -96, -90, -85, -79, -74, -68, -63, -57, -51, -46, -40, -34, -29, -23, -17, -11, -6
}

const int16 cos[] = { 
	328, 328, 327, 327, 327, 326, 326, 325, 324, 324, 323, 322, 321, 319, 318, 317, 315, 313,
	312, 310, 308, 306, 304, 302, 299, 297, 295, 292, 289, 287, 284, 281, 278, 275, 272, 268,
	265, 262, 258, 255, 251, 247, 244, 240, 236, 232, 228, 223, 219, 215, 211, 206, 202, 197,
	193, 188, 183, 178, 174, 169, 164, 159, 154, 149, 144, 138, 133, 128, 123, 117, 112, 107,
	101, 96, 90, 85, 79, 74, 68, 63, 57, 51, 46, 40, 34, 29, 23, 17, 11, 6,
	0, -6, -11, -17, -23, -29, -34, -40, -46, -51, -57, -63, -68, -74, -79, -85, -90, -96,
	-101, -107, -112, -117, -123, -128, -133, -138, -144, -149, -154, -159, -164, -169, -174, -178, -183, -188,
	-193, -197, -202, -206, -211, -215, -219, -223, -228, -232, -236, -240, -244, -247, -251, -255, -258, -262,
	-265, -268, -272, -275, -278, -281, -284, -287, -289, -292, -295, -297, -299, -302, -304, -306, -308, -310,
	-312, -313, -315, -317, -318, -319, -321, -322, -323, -324, -324, -325, -326, -326, -327, -327, -327, -328,
	
	-328, -328, -327, -327, -327, -326, -326, -325, -324, -324, -323, -322, -321, -319, -318, -317, -315, -313,
	-312, -310, -308, -306, -304, -302, -299, -297, -295, -292, -289, -287, -284, -281, -278, -275, -272, -268,
	-265, -262, -258, -255, -251, -247, -244, -240, -236, -232, -228, -223, -219, -215, -211, -206, -202, -197,
	-193, -188, -183, -178, -174, -169, -164, -159, -154, -149, -144, -138, -133, -128, -123, -117, -112, -107,
	-101, -96, -90, -85, -79, -74, -68, -63, -57, -51, -46, -40, -34, -29, -23, -17, -11, -6,
	-0, 6, 11, 17, 23, 29, 34, 40, 46, 51, 57, 63, 68, 74, 79, 85, 90, 96,
	101, 107, 112, 117, 123, 128, 133, 138, 144, 149, 154, 159, 164, 169, 174, 178, 183, 188,
	193, 197, 202, 206, 211, 215, 219, 223, 228, 232, 236, 240, 244, 247, 251, 255, 258, 262,
	265, 268, 272, 275, 278, 281, 284, 287, 289, 292, 295, 297, 299, 302, 304, 306, 308, 310,
	312, 313, 315, 317, 318, 319, 321, 322, 323, 324, 324, 325, 326, 326, 327, 327, 327, 328
}

const int16 lemniscateX[] = {
	0, -3, -6, -9, -11, -14, -17, -20, -23, -26, -29, -32, -35, -38, -41, -44, -47, -50,
	-53, -56, -60, -63, -66, -69, -73, -76, -79, -83, -86, -90, -94, -97, -101, -105, -109, -112,
	-116, -120, -124, -129, -133, -137, -141, -146, -150, -154, -159, -164, -168, -173, -178, -182, -187, -192,
	-197, -202, -207, -212, -217, -222, -227, -232, -237, -242, -247, -252, -257, -262, -266, -271, -276, -280,
	-284, -289, -293, -297, -300, -304, -307, -310, -313, -316, -318, -320, -322, -324, -325, -326, -327, -328,
	-328, -328, -327, -326, -325, -324, -322, -320, -318, -316, -313, -310, -307, -304, -300, -297, -293, -289,
	-284, -280, -276, -271, -266, -262, -257, -252, -247, -242, -237, -232, -227, -222, -217, -212, -207, -202,
	-197, -192, -187, -182, -178, -173, -168, -164, -159, -154, -150, -146, -141, -137, -133, -129, -124, -120,
	-116, -112, -109, -105, -101, -97, -94, -90, -86, -83, -79, -76, -73, -69, -66, -63, -60, -56,
	-53, -50, -47, -44, -41, -38, -35, -32, -29, -26, -23, -20, -17, -14, -11, -9, -6, -3,
	0, 3, 6, 9, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50,
	53, 56, 60, 63, 66, 69, 73, 76, 79, 83, 86, 90, 94, 97, 101, 105, 109, 112,
	116, 120, 124, 129, 133, 137, 141, 146, 150, 154, 159, 164, 168, 173, 178, 182, 187, 192,
	197, 202, 207, 212, 217, 222, 227, 232, 237, 242, 247, 252, 257, 262, 266, 271, 276, 280,
	284, 289, 293, 297, 300, 304, 307, 310, 313, 316, 318, 320, 322, 324, 325, 326, 327, 328,
	328, 328, 327, 326, 325, 324, 322, 320, 318, 316, 313, 310, 307, 304, 300, 297, 293, 289,
	284, 280, 276, 271, 266, 262, 257, 252, 247, 242, 237, 232, 227, 222, 217, 212, 207, 202,
	197, 192, 187, 182, 178, 173, 168, 164, 159, 154, 150, 146, 141, 137, 133, 129, 124, 120,
	116, 112, 109, 105, 101, 97, 94, 90, 86, 83, 79, 76, 73, 69, 66, 63, 60, 56,
	53, 50, 47, 44, 41, 38, 35, 32, 29, 26, 23, 20, 17, 14, 11, 9, 6, 3
}

const int8 lemniscateY[] = {
	0, -3, -6, -9, -11, -14, -17, -20, -23, -26, -28, -31, -34, -37, -40, -42, -45, -48,
	-51, -53, -56, -59, -61, -64, -66, -69, -71, -74, -76, -79, -81, -83, -86, -88, -90, -92,
	-94, -96, -98, -100, -102, -103, -105, -106, -108, -109, -110, -112, -113, -113, -114, -115, -115, -116,
	-116, -116, -116, -115, -115, -114, -114, -112, -111, -110, -108, -106, -104, -102, -100, -97, -94, -91,
	-88, -84, -81, -77, -73, -68, -64, -59, -54, -49, -44, -39, -34, -28, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 28, 34, 39, 44, 49, 54, 59, 64, 68, 73, 77, 81, 84,
	88, 91, 94, 97, 100, 102, 104, 106, 108, 110, 111, 112, 114, 114, 115, 115, 116, 116,
	116, 116, 115, 115, 114, 113, 113, 112, 110, 109, 108, 106, 105, 103, 102, 100, 98, 96,
	94, 92, 90, 88, 86, 83, 81, 79, 76, 74, 71, 69, 66, 64, 61, 59, 56, 53,
	51, 48, 45, 42, 40, 37, 34, 31, 28, 26, 23, 20, 17, 14, 11, 9, 6, 3,
	0, -3, -6, -9, -11, -14, -17, -20, -23, -26, -28, -31, -34, -37, -40, -42, -45, -48,
	-51, -53, -56, -59, -61, -64, -66, -69, -71, -74, -76, -79, -81, -83, -86, -88, -90, -92,
	-94, -96, -98, -100, -102, -103, -105, -106, -108, -109, -110, -112, -113, -113, -114, -115, -115, -116,
	-116, -116, -116, -115, -115, -114, -114, -112, -111, -110, -108, -106, -104, -102, -100, -97, -94, -91,
	-88, -84, -81, -77, -73, -68, -64, -59, -54, -49, -44, -39, -34, -28, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 28, 34, 39, 44, 49, 54, 59, 64, 68, 73, 77, 81, 84,
	88, 91, 94, 97, 100, 102, 104, 106, 108, 110, 111, 112, 114, 114, 115, 115, 116, 116,
	116, 116, 115, 115, 114, 113, 113, 112, 110, 109, 108, 106, 105, 103, 102, 100, 98, 96,
	94, 92, 90, 88, 86, 83, 81, 79, 76, 74, 71, 69, 66, 64, 61, 59, 56, 53,
	51, 48, 45, 42, 40, 37, 34, 31, 28, 26, 23, 20, 17, 14, 11, 9, 6, 3
}

const int16 roseX[] = {
	0, -29, -57, -85, -112, -138, -163, -187, -209, -229, -247, -263, -278, -289, -299, -306, -310, -312,
	-312, -309, -303, -295, -285, -273, -259, -243, -226, -206, -186, -164, -142, -119, -95, -71, -47, -23,
	0, 23, 45, 66, 86, 105, 122, 137, 152, 164, 174, 183, 190, 195, 198, 199, 199, 196,
	193, 187, 180, 172, 163, 153, 142, 130, 118, 105, 92, 79, 67, 54, 42, 30, 19, 9,
	0, -8, -16, -22, -27, -31, -34, -36, -37, -36, -35, -33, -30, -26, -21, -17, -11, -6,
	0, 6, 11, 17, 21, 26, 30, 33, 35, 36, 37, 36, 34, 31, 27, 22, 16, 8,
	0, -9, -19, -30, -42, -54, -67, -79, -92, -105, -118, -130, -142, -153, -163, -172, -180, -187,
	-193, -196, -199, -199, -198, -195, -190, -183, -174, -164, -152, -137, -122, -105, -86, -66, -45, -23,
	0, 23, 47, 71, 95, 119, 142, 164, 186, 206, 226, 243, 259, 273, 285, 295, 303, 309,
	312, 312, 310, 306, 299, 289, 278, 263, 247, 229, 209, 187, 163, 138, 112, 85, 57, 29,
	0, -29, -57, -85, -112, -138, -163, -187, -209, -229, -247, -263, -278, -289, -299, -306, -310, -312,
	-312, -309, -303, -295, -285, -273, -259, -243, -226, -206, -186, -164, -142, -119, -95, -71, -47, -23,
	0, 23, 45, 66, 86, 105, 122, 137, 152, 164, 174, 183, 190, 195, 198, 199, 199, 196,
	193, 187, 180, 172, 163, 153, 142, 130, 118, 105, 92, 79, 67, 54, 42, 30, 19, 9,
	0, -8, -16, -22, -27, -31, -34, -36, -37, -36, -35, -33, -30, -26, -21, -17, -11, -6,
	0, 6, 11, 17, 21, 26, 30, 33, 35, 36, 37, 36, 34, 31, 27, 22, 16, 8,
	0, -9, -19, -30, -42, -54, -67, -79, -92, -105, -118, -130, -142, -153, -163, -172, -180, -187,
	-193, -196, -199, -199, -198, -195, -190, -183, -174, -164, -152, -137, -122, -105, -86, -66, -45, -23,
	0, 23, 47, 71, 95, 119, 142, 164, 186, 206, 226, 243, 259, 273, 285, 295, 303, 309,
	312, 312, 310, 306, 299, 289, 278, 263, 247, 229, 209, 187, 163, 138, 112, 85, 57, 29
}

const int16 roseY[] = {
    0, 0, -2, -4, -8, -12, -17, -23, -29, -36, -44, -51, -59, -67, -74, -82, -89, -95,
    -101, -106, -110, -113, -115, -116, -115, -113, -110, -105, -99, -91, -82, -71, -59, -46, -32, -16,
    0, 17, 35, 53, 72, 91, 110, 128, 146, 164, 181, 196, 211, 224, 236, 246, 254, 261,
    265, 267, 268, 265, 261, 255, 246, 235, 222, 206, 189, 170, 150, 127, 104, 79, 53, 27,
    0, -27, -55, -82, -109, -135, -160, -184, -207, -229, -249, -266, -282, -296, -307, -316, -322, -326,
    -328, -326, -322, -316, -307, -296, -282, -266, -249, -229, -207, -184, -160, -135, -109, -82, -55, -27,
    0, 27, 53, 79, 104, 127, 150, 170, 189, 206, 222, 235, 246, 255, 261, 265, 268, 267,
    265, 261, 254, 246, 236, 224, 211, 196, 181, 164, 146, 128, 110, 91, 72, 53, 35, 17,
    0, -16, -32, -46, -59, -71, -82, -91, -99, -105, -110, -113, -115, -116, -115, -113, -110, -106,
    -101, -95, -89, -82, -74, -67, -59, -51, -44, -36, -29, -23, -17, -12, -8, -4, -2, 0,
    0, 0, -2, -4, -8, -12, -17, -23, -29, -36, -44, -51, -59, -67, -74, -82, -89, -95,
    -101, -106, -110, -113, -115, -116, -115, -113, -110, -105, -99, -91, -82, -71, -59, -46, -32, -16,
    0, 17, 35, 53, 72, 91, 110, 128, 146, 164, 181, 196, 211, 224, 236, 246, 254, 261,
    265, 267, 268, 265, 261, 255, 246, 235, 222, 206, 189, 170, 150, 127, 104, 79, 53, 27,
    0, -27, -55, -82, -109, -135, -160, -184, -207, -229, -249, -266, -282, -296, -307, -316, -322, -326,
    -328, -326, -322, -316, -307, -296, -282, -266, -249, -229, -207, -184, -160, -135, -109, -82, -55, -27,
    0, 27, 53, 79, 104, 127, 150, 170, 189, 206, 222, 235, 246, 255, 261, 265, 268, 267,
    265, 261, 254, 246, 236, 224, 211, 196, 181, 164, 146, 128, 110, 91, 72, 53, 35, 17,
    0, -16, -32, -46, -59, -71, -82, -91, -99, -105, -110, -113, -115, -116, -115, -113, -110, -106,
    -101, -95, -89, -82, -74, -67, -59, -51, -44, -36, -29, -23, -17, -12, -8, -4, -2, 0
}

const int16 diamondX[] = {
    0, 4, 7, 11, 15, 18, 22, 26, 29, 33, 37, 40, 44, 48, 52, 55, 59, 63,
    66, 70, 74, 77, 81, 85, 88, 92, 96, 99, 103, 107, 110, 114, 118, 121, 125, 129,
    133, 136, 140, 144, 147, 151, 155, 158, 162, 166, 169, 173, 177, 180, 184, 188, 191, 195,
    199, 202, 206, 210, 214, 217, 221, 225, 228, 232, 236, 239, 243, 247, 250, 254, 258, 261,
    265, 269, 272, 276, 280, 283, 287, 291, 295, 298, 302, 306, 309, 313, 317, 320, 324, 328,
    328, 324, 320, 317, 313, 309, 306, 302, 298, 295, 291, 287, 283, 280, 276, 272, 269, 265, 
    261, 258, 254, 250, 247, 243, 239, 236, 232, 228, 225, 221, 217, 214, 210, 206, 202, 199,
    195, 191, 188, 184, 180, 177, 173, 169, 166, 162, 158, 155, 151, 147, 144, 140, 136, 133,
    129, 125, 121, 118, 114, 110, 107, 103, 99, 96, 92, 88, 85, 81, 77, 74, 70, 66,
    63, 59, 55, 52, 48, 44, 40, 37, 33, 29, 26, 22, 18, 15, 11, 7, 4, 0,
    0, -4, -7, -11, -15, -18, -22, -26, -29, -33, -37, -40, -44, -48, -52, -55, -59, -63,
    -66, -70, -74, -77, -81, -85, -88, -92, -96, -99, -103, -107, -110, -114, -118, -121, -125, -129,
    -133, -136, -140, -144, -147, -151, -155, -158, -162, -166, -169, -173, -177, -180, -184, -188, -191, -195,
    -199, -202, -206, -210, -214, -217, -221, -225, -228, -232, -236, -239, -243, -247, -250, -254, -258, -261,
    -265, -269, -272, -276, -280, -283, -287, -291, -295, -298, -302, -306, -309, -313, -317, -320, -324, -328,
    -328, -324, -320, -317, -313, -309, -306, -302, -298, -295, -291, -287, -283, -280, -276, -272, -269, -265,
    -261, -258, -254, -250, -247, -243, -239, -236, -232, -228, -225, -221, -217, -214, -210, -206, -202, -199,
    -195, -191, -188, -184, -180, -177, -173, -169, -166, -162, -158, -155, -151, -147, -144, -140, -136, -133,
    -129, -125, -121, -118, -114, -110, -107, -103, -99, -96, -92, -88, -85, -81, -77, -74, -70, -66,
    -63, -59, -55, -52, -48, -44, -40, -37, -33, -29, -26, -22, -18, -15, -11, -7, -4, 0
}

const int16 diamondY[] = {
    328, 324, 320, 317, 313, 309, 306, 302, 298, 295, 291, 287, 283, 280, 276, 272, 269, 265, 
    261, 258, 254, 250, 247, 243, 239, 236, 232, 228, 225, 221, 217, 214, 210, 206, 202, 199,
    195, 191, 188, 184, 180, 177, 173, 169, 166, 162, 158, 155, 151, 147, 144, 140, 136, 133,
    129, 125, 121, 118, 114, 110, 107, 103, 99, 96, 92, 88, 85, 81, 77, 74, 70, 66,
    63, 59, 55, 52, 48, 44, 40, 37, 33, 29, 26, 22, 18, 15, 11, 7, 4, 0,
    0, -4, -7, -11, -15, -18, -22, -26, -29, -33, -37, -40, -44, -48, -52, -55, -59, -63,
    -66, -70, -74, -77, -81, -85, -88, -92, -96, -99, -103, -107, -110, -114, -118, -121, -125, -129,
    -133, -136, -140, -144, -147, -151, -155, -158, -162, -166, -169, -173, -177, -180, -184, -188, -191, -195,
    -199, -202, -206, -210, -214, -217, -221, -225, -228, -232, -236, -239, -243, -247, -250, -254, -258, -261,
    -265, -269, -272, -276, -280, -283, -287, -291, -295, -298, -302, -306, -309, -313, -317, -320, -324, -328,
    -328, -324, -320, -317, -313, -309, -306, -302, -298, -295, -291, -287, -283, -280, -276, -272, -269, -265,
    -261, -258, -254, -250, -247, -243, -239, -236, -232, -228, -225, -221, -217, -214, -210, -206, -202, -199,
    -195, -191, -188, -184, -180, -177, -173, -169, -166, -162, -158, -155, -151, -147, -144, -140, -136, -133,
    -129, -125, -121, -118, -114, -110, -107, -103, -99, -96, -92, -88, -85, -81, -77, -74, -70, -66,
    -63, -59, -55, -52, -48, -44, -40, -37, -33, -29, -26, -22, -18, -15, -11, -7, -4, 0,
    0, 4, 7, 11, 15, 18, 22, 26, 29, 33, 37, 40, 44, 48, 52, 55, 59, 63,
    66, 70, 74, 77, 81, 85, 88, 92, 96, 99, 103, 107, 110, 114, 118, 121, 125, 129,
    133, 136, 140, 144, 147, 151, 155, 158, 162, 166, 169, 173, 177, 180, 184, 188, 191, 195,
    199, 202, 206, 210, 214, 217, 221, 225, 228, 232, 236, 239, 243, 247, 250, 254, 258, 261,
    265, 269, 272, 276, 280, 283, 287, 291, 295, 298, 302, 306, 309, 313, 317, 320, 324, 328
}

const int16 horizonX[] = {
    0, 4, 7, 11, 15, 18, 22, 26, 29, 33, 37, 40, 44, 48, 52, 55, 59, 63,
    66, 70, 74, 77, 81, 85, 88, 92, 96, 99, 103, 107, 110, 114, 118, 121, 125, 129,
    133, 136, 140, 144, 147, 151, 155, 158, 162, 166, 169, 173, 177, 180, 184, 188, 191, 195,
    199, 202, 206, 210, 214, 217, 221, 225, 228, 232, 236, 239, 243, 247, 250, 254, 258, 261,
    265, 269, 272, 276, 280, 283, 287, 291, 295, 298, 302, 306, 309, 313, 317, 320, 324, 328,
    328, 324, 320, 317, 313, 309, 306, 302, 298, 295, 291, 287, 283, 280, 276, 272, 269, 265, 
    261, 258, 254, 250, 247, 243, 239, 236, 232, 228, 225, 221, 217, 214, 210, 206, 202, 199,
    195, 191, 188, 184, 180, 177, 173, 169, 166, 162, 158, 155, 151, 147, 144, 140, 136, 133,
    129, 125, 121, 118, 114, 110, 107, 103, 99, 96, 92, 88, 85, 81, 77, 74, 70, 66,
    63, 59, 55, 52, 48, 44, 40, 37, 33, 29, 26, 22, 18, 15, 11, 7, 4, 0,
    0, -4, -7, -11, -15, -18, -22, -26, -29, -33, -37, -40, -44, -48, -52, -55, -59, -63,
    -66, -70, -74, -77, -81, -85, -88, -92, -96, -99, -103, -107, -110, -114, -118, -121, -125, -129,
    -133, -136, -140, -144, -147, -151, -155, -158, -162, -166, -169, -173, -177, -180, -184, -188, -191, -195,
    -199, -202, -206, -210, -214, -217, -221, -225, -228, -232, -236, -239, -243, -247, -250, -254, -258, -261,
    -265, -269, -272, -276, -280, -283, -287, -291, -295, -298, -302, -306, -309, -313, -317, -320, -324, -328,
    -328, -324, -320, -317, -313, -309, -306, -302, -298, -295, -291, -287, -283, -280, -276, -272, -269, -265,
    -261, -258, -254, -250, -247, -243, -239, -236, -232, -228, -225, -221, -217, -214, -210, -206, -202, -199,
    -195, -191, -188, -184, -180, -177, -173, -169, -166, -162, -158, -155, -151, -147, -144, -140, -136, -133,
    -129, -125, -121, -118, -114, -110, -107, -103, -99, -96, -92, -88, -85, -81, -77, -74, -70, -66,
    -63, -59, -55, -52, -48, -44, -40, -37, -33, -29, -26, -22, -18, -15, -11, -7, -4, 0
}

const int16 flowerX[] = {
	-1, -19, -39, -60, -82, -105, -128, -150, -172, -192, -211, -228, -244, -256, -267, -275, -281, -285,
	-287, -287, -286, -284, -281, -278, -275, -272, -269, -268, -268, -268, -271, -274, -279, -284, -291, -298,
	-304, -311, -317, -322, -326, -328, -327, -324, -318, -309, -297, -282, -264, -244, -221, -195, -169, -140,
	-112, -83, -54, -27, -2, 21, 42, 59, 73, 82, 88, 89, 87, 80, 70, 56, 39, 20,
	-2, -25, -49, -74, -98, -122, -145, -166, -185, -202, -217, -228, -237, -244, -247, -249, -248, -245,
	-240, -234, -227, -220, -212, -204, -196, -188, -182, -176, -170, -166, -162, -159, -157, -155, -154, -152,
	-150, -148, -146, -143, -139, -134, -128, -122, -114, -106, -97, -87, -77, -67, -57, -47, -38, -29,
	-21, -15, -9, -4, 0, 2, 4, 4, 4, 3, 2, 0, -2, -3, -4, -4, -4, -2,
	0, 4, 9, 15, 21, 29, 38, 47, 57, 67, 77, 87, 97, 106, 114, 122, 128, 134,
	139, 143, 146, 148, 150, 152, 154, 155, 157, 159, 162, 166, 170, 176, 182, 188, 196, 204,
	212, 220, 227, 234, 240, 245, 248, 249, 247, 244, 237, 228, 217, 202, 185, 166, 145, 122,
	98, 74, 49, 25, 2, -20, -39, -56, -70, -80, -87, -89, -88, -82, -73, -59, -42, -21,
	2, 27, 54, 83, 112, 140, 169, 195, 221, 244, 264, 282, 297, 309, 318, 324, 327, 328,
	326, 322, 317, 311, 304, 298, 291, 284, 279, 274, 271, 268, 268, 268, 269, 272, 275, 278,
	281, 284, 286, 287, 287, 285, 281, 275, 267, 256, 244, 228, 211, 192, 172, 150, 128, 105,
	82, 60, 39, 19, 1, -15, -28, -39, -47, -53, -55, -55, -53, -48, -41, -32, -22, -11,
	1, 13, 25, 37, 48, 57, 66, 73, 79, 83, 86, 87, 87, 85, 82, 79, 74, 68,
	63, 57, 50, 44, 38, 32, 26, 20, 15, 10, 5, 0, -5, -10, -15, -20, -26, -32,
	-38, -44, -50, -57, -63, -68, -74, -79, -82, -85, -87, -87, -86, -83, -79, -73, -66, -57,
	-48, -37, -25, -13, -1, 11, 22, 32, 41, 48, 53, 55, 55, 53, 47, 39, 28, 15
}

const int16 flowerY[] = {
	1, 20, 39, 58, 77, 94, 111, 126, 139, 150, 159, 166, 171, 173, 173, 172, 169, 165,
	159, 153, 146, 139, 131, 124, 117, 110, 103, 98, 92, 87, 83, 79, 75, 71, 67, 63,
	59, 55, 50, 45, 40, 34, 29, 23, 17, 11, 5, 0, -5, -9, -12, -14, -15, -15,
	-14, -12, -9, -5, 0, 5, 10, 15, 19, 24, 27, 29, 30, 29, 27, 23, 17, 9,
	-1, -12, -25, -39, -55, -71, -87, -104, -120, -136, -152, -166, -179, -190, -200, -209, -215, -220,
	-224, -226, -227, -227, -227, -226, -225, -224, -224, -225, -226, -228, -232, -236, -242, -248, -256, -263,
	-271, -279, -286, -293, -298, -301, -302, -301, -297, -291, -281, -268, -253, -235, -213, -190, -165, -138,
	-110, -82, -54, -27, -2, 22, 43, 61, 75, 86, 92, 94, 92, 86, 75, 61, 43, 22,
	-2, -27, -54, -82, -110, -138, -165, -190, -213, -235, -253, -268, -281, -291, -297, -301, -302, -301,
	-298, -293, -286, -279, -271, -263, -256, -248, -242, -236, -232, -228, -226, -225, -224, -224, -225, -226,
	-227, -227, -227, -226, -224, -220, -215, -209, -200, -190, -179, -166, -152, -136, -120, -104, -87, -71,
	-55, -39, -25, -12, -1, 9, 17, 23, 27, 29, 30, 29, 27, 24, 19, 15, 10, 5,
	0, -5, -9, -12, -14, -15, -15, -14, -12, -9, -5, 0, 5, 11, 17, 23, 29, 34,
	40, 45, 50, 55, 59, 63, 67, 71, 75, 79, 83, 87, 92, 98, 103, 110, 117, 124,
	131, 139, 146, 153, 159, 165, 169, 172, 173, 173, 171, 166, 159, 150, 139, 126, 111, 94,
	77, 58, 39, 20, 1, -16, -32, -47, -58, -67, -73, -76, -75, -71, -63, -52, -37, -19,
	2, 24, 49, 75, 102, 129, 156, 182, 206, 229, 250, 268, 284, 297, 308, 315, 320, 322,
	322, 321, 317, 313, 308, 302, 297, 292, 288, 285, 283, 282, 283, 285, 288, 292, 297, 302,
	308, 313, 317, 321, 322, 322, 320, 315, 308, 297, 284, 268, 250, 229, 206, 182, 156, 129,
	102, 75, 49, 24, 2, -19, -37, -52, -63, -71, -75, -76, -73, -67, -58, -47, -32, -16
}
 