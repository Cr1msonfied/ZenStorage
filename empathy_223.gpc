/*

																PUBG: BATTLEGROUNDS

														Author:		swedemafia
														Script:		Empathy
														Version:	2.23
														Build Date:	11 April 2023
														Support:	https://discord.gg/gr93vNW7Jp
														
														
							REQUIREMENTS:
								* Zen Studio (current version: v1.3.1 Beta 11).
								* You *MUST* set your in-game Deadzone to 0 for both Right and Left Sticks (set deadzones on the script instead)!
								* You *MUST* disable Aim Acceleration!
								* You *MUST* set Vertical Sensitivity Multiplier (%) to 100!
								* If using a keyboard for Weapon Select, in Zen Studio, make sure to unmap ALL keyboard buttons from any controller buttons!
								* If using Mouse & Keyboard, disable "Keyboard Switch" in Settings.
							
							README:
								* https://docs.google.com/document/d/1UQZdi7fMyfoOJBMcWclE7bcUjXQazbRkIO0XBOm-BRI
								
							FEATURES:
								* Anti-drift algorithm and calibration process to remove stick drift.
								* Anti-recoil for all 30 (AR/SMG/DMR/LMG) weapons.
								* Attachment Selector to choose which attachments you are using so recoil adjusts accordingly.
								* Auto Focus automatically holds your breath while aiming.
								* Auto Lean press in RS/R3 while aiming/firing to quickly lean back and forth.
								* Auto Parachute allows you to lock your parachute angle and adjust it on-the-fly.
								* Auto Turbo automatically engages turbo boost while driving a vehicle.
								* Rapid Fire (adjustable) to rapidly fire a semi-automatic weapon.
								* Scope Selector to choose which scope you are using so recoil adjusts accordingly.
								
							MISCELLANEOUS:
								* Adjustable Primary/Secondary LED color on your Cronus Zen device
								* Compatible for Inverted players
								* Deadzone capabilities to allow you to run a 0 in-game deadzone setting
									* The lower the in-game deadzone, the less Anti-recoil compensation is needed
								* FULL support for Type B / Type C players.  Type A will not be able to use all options such as Auto Focus
								* Profile Resync to keep Anti-recoil synchronized with your in-game weapons
								
							NAVIGATION:
								* Enter script menu:
									* Hold LT and press Menu (Xbox)
									* Hold L2 and press Options (PlayStation)
								* Enter Weapon Select menu
									* Hold LT and press View (Xbox)
									* Hold L2 and press Share (PlayStation)
								* Remove all attachments & reset scope selection
									* Hold RB and press View (Xbox)
									* Hold R1 and press Share (PlayStation)
								* Resync Stance Tracker
									* Toggling Standing/Crouched:
										- Hold RB and press B (Xbox)
										- Hold R1 and press Circle (PlayStation)
									* Toggling Standing/Prone:
										- Hold RB and press A (Xbox)
										- Hold R1 and press Cross (PlayStation)
									* Resync Inventory Tracker:
										- Hold RB and press Menu (Xbox)
										- Hold R1 and press Options (PlayStation)
									* Resync Grenade Tracker:
										- Hold RB and press Right (Xbox)
										- Hold R1 and press Right (PlayStation)
									* You may also resync by using your 'Resync' and 'Switch' button set under the profiles menu.
								* Selecting Scopes & Attachments:
									* Scopes:
										- Hold RB/R1 and press Up
										- Keyboard users: press 1 (1x), 2 (2x), 3 (3x), 4 (4x), 6 (6x), 8 (8x)
									* Muzzles:
										- Hold RB/R1 and press Left
									* Foregrips:
										- Hold RB/R1 and press Down
									* Stocks:
										- Hold RB/R1 and press Right
								* Select values or enabling/disabling options
									* Press Up or Down
								* Editing values
									* Hold LT/L2 and press Right/Left (increase by 1/decrease by 1)
									* Hold LT/L2 and press Up/Down (increase by 10/decrease by 10)
								* Save Settings
									* Press B/Circle until your Cronus Zen device says "Settings Saved"
								
							SWITCHING WEAPONS:
								* By default, 'Profile Switch' is set to Y (Xbox) or Triangle (PlayStation)
									* Pressing the 'Profile Switch' will change which Anti-recoil profile (weapon) that the script is set to.
									* By enabling Weapon display, the script screen to will flash every 3.5 seconds which weapon you are using.
									
								* To resync the Primary/Secondary weapons on the script with your Primary/Secondary weapons in game...
									...by default, 'Profile Resync' is set to RB (Xbox) or R1 (PlayStation)
									* Hold 'Profile Resync' button and press the 'Profile Switch' button
										* By default, 'Profile Resync' is RB/R1 and 'Profile Switch' is Y/Triangle
										
								* To change weapons on the script with a keyboard, you *MUST* have a keyboard attached to the front-left (A3) USB port
								
									[Assault Rifles]
									 Q - AKM
									 W - Beryl 762
									 E - G36C
									 R - M416
									 T - M16A4
									 Y - SCAR-L
									 U - Mk47 Mutant
									 I - QBZ
									 O - AUG
									 P - Groza
									 [ - ACE32
									 ] - K2
									 | - FAMAS

									[Sub Machine Guns]
									 A - PP-19 Bizon
									 S - Tommy Gun
									 D - UMP45
									 F - Micro UZI
									 G - Vector
									 H - MP5K
									 J - P90
									 K - MP9
									
									[Light Machine Guns]
									 L - DP-28
									 ; - M249
									 ' - MG3 (660rpm) 
									 ENTER - MG3 (990rpm) 
									
									[Designated Marksman Rifles]
									 Z - SLR
									 X - Mini 14
									 C - SKS
									 V - VSS (automatic fire only)
									 B - QBU
									 N - Mk14 (single-fire only)
									 M - Mk12
									
									[Sniper Rifle]
									 , - Sniper/Shotgun
									
							CHANGE LOG:
								[Version 2.23]
								* [UPGRADE]
									- Corrected issue with Flash Hider on various assault rifles.
									- Reverted single-fire DMR anti-recoil back to how it used to be.
								[Version 2.22]
								* [NEW]
									- Anti-recoil is now applied for hip-fire (does not work on Type A).
									- Anti-recoil is now applied for over-the-shoulder (only works on Type B).
								* [UPGRADE]
									Anti-recoil
										- Further adjusted an issue with the Beryl and Compensator attachment.
									Crouch Shot
										- Crouch Shot will now slightly tilt your aimer up when the mod engages.
										- Note: when you are a passenger in a car, you should Toggle off Crouch Shot, if enabled.
									Rapid Fire
										- Can now be engaged when hip-firing (does not work on Type A).
										- Can now be engaged when over-the-shoulder firing (only works on Type B).
									Vehicle Mode
										- Crouch Shot will no longer attempt to engage when you swap seats and aim/fire from a vehicle.
										- When moving back to the driver's seat by holding A/Cross, Vehicle Mode automatically re-engages.
								[Version 2.21]
								* [BUGS]
									- Fixed an issue related to 8x scopes.
									- Fixed an issue with AutoLean causing your PlayStation/Xbox menu to open up.
									- Fixed various issues when using a keyboard to switch weapons/scopes.
									- Fixed display issue relating to the P90 and Sniper/Shotgun.
								* [UPGRADE]
									- Adjusted the recoil for the Beryl when using a Compensator with any foregrip.
									- Increased allowable deadzone to 50.
								[Version 2.20]
								* [UPGRADE]
									Anti-recoil
										- Adjusted the recoil for the AUG.
										- Adjusted the recoil for the Vector.
									Display
										- Various OLED display improvements.
									Menus
										- Moved 'Aim Acceleration' and 'Smoothing' to the Settings menu.
									Rapid Fire
										- Corrected Rapid Fire anti-recoil boost strength for the M16A4.
										- Corrected the M16A4 Rapid Fire speed.
									Stance Tracker
										- Completely overhauled with a new, more accurate, Stance Tracker system.
										- Now has option for Training Mode that tracks the Spawn Tool.
										- Stance Alert is now automatically engaged with Stance Tracker being On
									Toggles
										- Enabling a toggle will now flash your profile color and then yellow.
										- Disabling a toggle will not flash your profile color and then red.
								[Version 2.19] (Season 22.2 Update)
								* [BUGS]
									- Fixed an issue where Smoothing value would not save.
									- Fixed an issue where resetting attachments/weapons would only work if Stance Tracker is enabled.
								* [NEW]
									Controller
										- Aim Acceleration: Reduction and Threshold
										- Any stick movement when aiming or firing under 'Threshold' will be reduced by 'Reduction' percent.
									Crouch Shot
										- Off, On ADS, On Fire
										- When enabled, you will automatically crouch when you either ADS or Fire depending which activation you choose.
										- Works best with Stance Tracker.
									Rapid Fire
										- Setup a HOLD button and a DOUBLE-TAP button under the Toggles menu.
										- Rapid Fire may only be used on the M16A4 and Mutant Mk47 (for DMRs, use Burst Fire).
								* [UPGRADE]
									Assault Rifles
										- Adjusted the recoil for the Mk12.
										- Adjusted the recoil for the Beryl M762.
									Designated Marksman Rifles
										- Adjusted the recoil for all DMR weapons with brand new spam-fire recoil boost algorithm.
									Stance Tracker
										- Now tracks switching to a pistol/pan/etc.
										- R1/RB + Options/Menu now resyncs viewing map/inventory (previously was R1/RB + Share/View).
										- R1/RB + Share/View now clears all attachments from weapons (previously was R1/RB + Options/Menu).
									Sub Machine Guns
										- Added support for toggling low/high zoom scope on P90.
										- Adjusted the recoil for the Tommy Gun.
										- Adjusted the recoil for the PP-19 Bizon.
										- Adjusted the recoil for the Micro UZI.
										- Adjusted the recoil for the Vector.
										- Adjusted the recoil for the MP5K.
										- Adjusted the recoil for the P90.
									Toggles
										- Auto Focus, Auto Lean and Crouch Shot are now togglable.
									Options
										- Auto Focus, Auto Lean and Crouch Shot now may be enabled for an individual profile.
								[Version 2.18]
								* [BUGS]
									- Fixed an issue where users with over a 10 sensitivity would have the recoil would pull down.
									- Fixed an issue where the script would not properly load the Default Weapons although the screen would show it did.
									- Fixed an issue where 'Always On' would not save.
								* [UPGRADE]
									- Adjusted recoil pattern for the UMP45.
									- Adjusted recoil pattern for the Vector.
									- Adjusted muzzle recoil compensation for SMGs.
									- Adjusted foregrip recoil compensation for SMGs.
								[Version 2.17]
								* [NEW]
									Controller
										- Smoothing: uses an Exponential Smoothing algorithm to smoothen your aim while aiming/firing.
											- Off, High or Low
								* [UPGRADE]
									- Stance Alert will now display orange/teal for grenade while crouched or solid orange for grenade while prone.
								* [BUGS]
									- Fixed a bug with Auto/Fast Lean causing PS/Xbox menu to open unexpectedly.
								[Version 2.16]
								* [NEW]
									Settings
										- Default Weapon Selector that will now save your default weapons when shutting off the script.
								* [BUGS]
									- Fixed an issue where the foregrip compensation was not properly being applied.
									- Fixed an issue where changing weapons attachments would improperly carry over to the new category.
									- Fixed an issue where using a keyboard to set the scope strength would apply the wrong scope.
									- Fixed an issue where using a Micro Uzi would improperly allow you to set a foregrip.
									- Fixed an issue where Weapon Display would improperly display attachments when using Sniper/Shotgun.
								* [UPGRADE]
									- Stance Tracker will now track grenades.  If it becomes out-of-sync, hold RB/R1 and tap Right to reset it.
								[Version 2.15]
								* [BUGS]
									- Fixed an issue where Burst Fire would not disable when swapping to an automatic weapon.
									- Fixed an issue where Stance Tracker would not recognize pressing jump as changing your stance from crouch/prone.
								* [NEW]
									- Input your sensitivities to the script in the Anti-recoil menu to match your in-game settings.
								* [UPGRADE]
									- Further refined the recoil patterns for all weapons.
									- Stance Tracker resync:
										* Hold RB/R1 and press B/Circle will toggle between standing/crouched.
										* Hold RB/R1 and press A/Cross will toggle between standing/prone.
									- Stance Tracker will now detect if you are in your inventory.
										- If it becomes out of sync, hold RB/R1 and press View/Share.
									- Stance Tracker will now cause your controller to have a slight rumble every two (2) seconds.
								* [REMOVED]
									- Removed anti-recoil Correction Values.
								[Version 2.14a]
								* [BUGS]
									- Fixed an issue causing Stance Tracker to engage when it is disabled while exiting Vehicle Mode.
								[Version 2.14]
								* [NEW]
									- Scope Selector
										- Hold RB/R1 and press Up/Down to set the scope on your weapon
											- AR/SMG/LMG can use 1x/2x/3x
											- DMR, M16A4, Mutant Mk47 can use 3x/4x/6x and 8x (where supported)
									- Hair Triggers (Options) is now optional
									- Stance Tracker (Options) is now optional
										- Script now keeps track of your stance (standing, crouched or prone)
											- LED will be solid with your profile color for standing
											- LED will flash your profile color and teal for crouched
											- LED will flash your profile color and orange for prone
											- Reset your stance if it becomes out of sync holding RB/R1 and press Right
									- VM Speed (Settings) is now available
										- This setting is optional
								* [UPGRADE]
									- New Anti-recoil system
										- Modified & created new anti-recoil patterns for all weapons
										- Adjustment values for each scope
									- Various OLED display improvements
										- Fixed a bug where text would overlap if Vehicle Mode during Weapon Display
										- Script now informs you if Auto Turbo is enabled while in Vehicle Mode
										- Script now informs you if Auto Parachute is enabled
								* [REMOVED]
									- Removed Rapid Fire and replaced it with Burst Fire (DMR/M16A4/Mutant Mk47 only)
								[Version 2.13]
								* [BUGS]
									- Fixed issue where horizontal recoil compensation was being applied when it shouldn't be
								[Version 2.12]
								* [BUGS}
									- Fixed issue where saved settings were not reloading properly
									- Fixed Auto Turbo (again)
								[Version 2.11]
								* [BUGS]
									- Fixed an issue where Auto Turbo would not engage
									- Fixed an issue where Profile Colors menu would not properly illuminate the selected color
								* [UPGRADE]
									- Anti-recoil Correction Value now uses high resolution values for more precise adjustments
									- Auto Focus will now engage even if player is moving
								* [NEW]
									- Keyboard is now *OPTIONAL*
									- Added the ability to change weapons using a controller
										- Keyboard weapon switching still remains, however, is now optional
									- Added new Bumper/Triggers Option
										- Allows you to swap LT/RT & L2/R2 with LB/RB & L1/R1
									- Added an option to disable the Weapon Display screen saver
								[Version 2.10]
								* [BUGS]
									- Fixed issue where saving settings would cause LED to display unwanted messages
								* [UPGRADE]
									- Completely remodeled the Anti-recoil system to use built-in values
									- Rapid Fire now relies on one universal Speed setting
								* [NEW]
									- Anti-Recoil
										Correction Value
									- Options
										Rapid Fire Speed
									- Toggles
										Auto Parachute
										Auto Turbo
								
								[Version 2.00]
								- Initial public release
*/


// Set to TRUE to use the developer's settings
define DEVELOPER = FALSE;
define NUMBER_OF_TOGGLE_BUTTONS = 16

/**************************************************************/
//	Variables
/**************************************************************/

// (Anti-drift) Variables
int antiDriftHighValue, antiDriftLowValue;
int antiDriftCalibrationHigh, antiDriftCalibrationLow;
int antiDriftCalibrationValue, antiDriftCalibrationRangeValue, antiDriftStickValue;
int antiDriftCalibrationCanSet, antiDriftCalibrationInRange, antiDriftCalibrationState;
int antiDriftCalibrationStick, antiDriftCalibrationDirection, antiDriftCalibrationPolarStick;

// (Anti-recoil) Variables
int antiRecoilIndexY, antiRecoilDurationY, antiRecoilMaxY, antiRecoilY;
// (Anti-recoil) Attachment adjustment
int antiRecoilAdjustment, antiRecoilAdjustValue, antiRecoilHighSensAdjust, antiRecoilForegripAdjust, antiRecoilMuzzleAdjust, antiRecoilScopeAdjust, antiRecoilStockAdjust;
// (Anti-recoil) Spam-fire anti-recoil boost variables
int antiRecoilCounter, antiRecoilFireCount, antiRecoilAttachmentSpamAdjust, antiRecoilSpamAdjust, antiRecoilStanceAdjust;
// (Anti-recoil) Stance adjustment
int antiRecoilCrouch, antiRecoilProne;
// (Anti-recoil Current profile values
int antiRecoilMuzzle[2], antiRecoilForegrip[2], antiRecoilScope[2], antiRecoilStock[2];
// (Anti-recoil) Stance Tracker
int stancePosition;

// (Controller) Buttons
int button[12];
// (Controller) Current ADS & Fire button values
int holdingADS, holdingFire;
// (Controller) Sticks
int aimX, aimY, moveY, moveX;

// (Display) Buffer
int displayBuffer, displayBufferInsertCopyValue, displayBufferInsertDigits[5], displayBufferInsertNumberOfDigits; 
// (Display) Vehicle Mode state
int vehicleMode, inVehicle;
// (Display) State
int displayDepth, displayUpdate;

// (Miscellaneous) Loop iterators
int i, j; 
// (Miscellaneous) Memory/storage
int spvar_current_bit, spvar_current_slot, spvar_current_value, spvar_tmp, spvar_bits; 

// (Menu) Edit Menu
int editMenuChangeTime, editMenuIndex, editMenuSelectedRow; 
// (Menu) Edit Menu data
int editMenuHoldingADS, editMenuType, editMenuAdsType, editMenuVariable1, editMenuVariable2, editMenuParent, editMenuMinValue, editMenuMaxValue, editMenuAdsMinValue, editMenuAdsMaxValue;
// (Menu) Mod Menu
int modMenuIndex; 

// (Options) Auto Lean, Fast Lean
int isAutoLean, isLeaning;
// (Options) Lean Direction
int leanDirection;
// (Options) Stance Tracker alert timer
int stanceCounter;
// (Options) Weapon Display
int weaponDisplayCounter

// (Profiles) Current category & weapon
int currentCategory[2], currentWeapon[2]; 
// (Profiles) Last category & weapon
int lastCategory, lastWeapon, lastScope, lastMuzzle, lastForegrip, lastStock; 
// (Profiles) Profile IDs
int currentProfile, menuProfile; 

// (Screen saver)
int screenSaverEnabled, screenSaverCounter; 

// (Settings) Exponential Smoothing
int forecast_x, forecast_y;

// (Toggles) Auto Parachute
int autoParachute, autoParachuteStrength[2];
// (Toggles) Auto Turbo
int autoTurbo;
// (Toggles) Burst Fire
int burstFire[2], rapidFire[2];

/**************************************************************/
//	User-defined configuration variables
/**************************************************************/
int userData[55];

enum {
	/* Anti-drift */
	vAntiDrift, vAntiDriftLeft, vAntiDriftRight = 5,
	
	/* Anti-recoil */
	vAntiRecoil1x = 9, vAntiRecoil2x, vAntiRecoil3x,
	vAntiRecoil4x, vAntiRecoil6x, vAntiRecoil8x,
	
	/* Controller */
	vControllerButtonLayout, vControllerBumperTriggers,
	
	/* Options */
	vOptionAutoFocus, vOptionAutoLean = 19, vOptionCrouchShot = 21, vOptionFastLean = 23, vOptionStanceTracker, vOptionWeaponDisplay,
	
	/* Profiles */
	vProfileColor,
	
	/* Settings */
	vAimAcceleration = 28, vBlockRumble = 30, vDeadzone, vDefaultWeapon = 33, vInverted = 35, vKeyboardSwitch, vSmoothing,
	
	/* Toggles */
	vToggleCrouchShot, vToggleButton
}

const int16 menuData[][] = {
/* Menu ID		  Menu type (No ADS)		Menu type w/ ADS    		Value 1				Value 2					Parent value 		Min			Max						Ads Min		Ads Max
/* AD */		{ menuToggleOnOff,			menuAdsNone,				vAntiDrift,			-1,						-1,					-1,			-1,						-1,			-1 },
/* ADCal */		{ menuAntiDriftCalibrate,	menuAdsAntiDriftCalibrate,	-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* ADDT */		{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* ADDV */		{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
	
/* AR1x */		{ menuNone,					menuAdsCycleEditValue,		-1,					vAntiRecoil1x,			-1,					-1, 		-1,						0,			200 },
/* AR2x */		{ menuNone,					menuAdsCycleEditValue,		-1,					vAntiRecoil2x,			-1,					-1,			-1,						0,			200 },
/* AR3x */		{ menuNone,					menuAdsCycleEditValue,		-1,					vAntiRecoil3x,			-1,					-1,			-1,						0,			200 },
/* AR4x */		{ menuNone,					menuAdsCycleEditValue,		-1,					vAntiRecoil4x,			-1,					-1,			-1,						0,			200 },
/* AR6x */		{ menuNone,					menuAdsCycleEditValue,		-1,					vAntiRecoil6x,			-1,					-1,			-1,						0,			200 },
/* AR8x */   	{ menuNone,					menuAdsCycleEditValue,		-1,					vAntiRecoil8x,			-1,					-1,			-1,						0,			200 },

/* BtnLayout*/	{ menuCycleListOption,		menuAdsNone,				vControllerButtonLayout, -1,				-1,					cblTypeA,	cblTypeC,				-1,			-1 },
/* BmprTrig*/	{ menuToggleOnOff,			menuAdsNone,				vControllerBumperTriggers, -1,				-1,					-1, 		-1,						-1,			-1 },

/* AutoFocus */	{ menuToggleOnOff,			menuAdsNone,				vOptionAutoFocus,	-1,						-1,					-1,			-1,						-1,			-1 },
/* AutoLean */	{ menuToggleOnOff,			menuAdsNone,				vOptionAutoLean,	-1,						-1,					-1,			-1,						-1,			-1 },
/* CrhShot*/	{ menuCycleListOption,		menuAdsNone,				vOptionCrouchShot,	-1,						-1,					crouchOff,	crouchOnFire,			-1,			-1 },
/* FastLean*/	{ menuToggleOnOff,			menuAdsNone,				vOptionFastLean,	-1,						-1,					-1,			-1,						-1,			-1 },
/* StnceTrckr*/	{ menuCycleListOption,		menuAdsNone,				vOptionStanceTracker,-1,					-1,					stanceTrackerOff,stanceTrackerTrainingMode,-1,	-1 },
/* WpnDisplay*/	{ menuCycleListOption,		menuAdsNone,				vOptionWeaponDisplay,-1,					-1,					displayOff,	displayAlways,			-1,			-1 },

/* ProBtns */	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* ProClrs */	{ menuMultiSelection,		menuAdsCycleListOption,		-1,					vProfileColor,			-1,					0,			2,						red,		pink },

/* AimAccel*/	{ menuMultiSelection,		menuAdsMultiSelection,		-1,					vAimAcceleration,		-1,					0,			1,						1,			100 },
/* BlckRmbl*/	{ menuToggleOnOff,			menuAdsNone,				vBlockRumble,		-1,						-1,					-1,			-1,						-1,			-1 },
/* Deadzone*/	{ menuMultiSelection,		menuAdsMultiSelection,		-1,					vDeadzone,				-1,					0,			1,						0,			50 },
/* DfltWpns*/	{ menuMultiSelection,		menuAdsCycleListOption,		-1,					vDefaultWeapon,			-1,					0,			1,						akm,		sniper_shotgun },
/* Inverted*/	{ menuToggleOnOff,			menuAdsNone,				vInverted,			-1,						-1,					-1,			-1,						-1,			-1 },
/* KeybrdSwch*/	{ menuToggleOnOff,			menuAdsNone,				vKeyboardSwitch,	-1,						-1,					-1,			-1,						-1,			-1 },
/* Smoothing*/	{ menuToggleOnOff,			menuAdsNone,				vSmoothing,			-1,						-1,					-1,			-1,						-1,			-1 },

/* T-AFocus*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-ALean*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-APchute*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-ATurbo */	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-BFire*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-CShot */	{ menuMultiSelection,		menuAdsCycleListOption,		-1,					vToggleCrouchShot,		-1,					0,			2,						crouchOnAds,crouchOnFire },
/* T-RpdFire*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 }
}

/**************************************************************/
//	Enumerations
/**************************************************************/

// (Anti-drift) Calibration direction
enum { antiDriftUp, antiDriftDown, antiDriftLeft, antiDriftRight }
// (Anti-drift) Calibratoin stick
enum { antiDriftLeftStick, antiDriftRightStick }

// (Anti-recoil) Muzzles
enum { Muzzle_None, Muzzle_FlashHider, Muzzle_Compensator,  Muzzle_Suppressor }
// (Anti-recoil) Foregrips
enum { Foregrip_None, Foregrip_Angled, Foregrip_Half, Foregrip_Lightweight, Foregrip_Thumb, Foregrip_Vertical }
// (Anti-recoil) Stocks
enum { Stock_None, Stock_CheekPad, Stock_Tactical, Stock_Heavy, Stock_Folding }

// (Controller) Button layout IDs
enum { cblTypeA, cblTypeB, cblTypeC }
// (Controller) Button IDs
enum { aim, ads, melee, fire, weapon, interact, action, jump, leanL, leanR, focus, zoom }

// (Display) Color IDs
enum { red, gold, yellow, green, blue, purple, pink, white, teal, orange }
// (Display) Formatting
enum { displayString, displayNumber }
// (Display) Home screen message IDs
enum { homeScriptName, homeScriptVersion, homeScriptAuthor }
// (Display) HSB map lookup IDs
enum { hue, saturation, brightness }
// (Display) Text alignment and formatting IDs
enum { alignCenter = -2, alignRight, alignLeft = 5, alignBottom = -1, alignTop = 5 }

// (Menu) Cycle value IDs
enum { cycleValueUp, cycleValueDown }
// (Menu) Data IDs
enum { menuType, menuAdsType, menuVariable1, menuVariable2, menuParent, menuMinValue, menuMaxValue, menuAdsMinValue, menuAdsMaxValue }
// (Menu) Edit menu navigation
enum { editMenuMin, editMenuMax }
// (Menu) Mod menu navigation and actions
enum { modMenuPrevious, modMenuCurrent, modMenuNext, modMenuDown, modMenuUp, modMenuExit, modMenuEnter }
// (Menu) Type
enum { menuNone, menuAntiDriftCalibrate, menuCycleListOption, menuMultiSelection, menuToggle, menuToggleOnOff }
// (Menu) Type ADS
enum { menuAdsNone, menuAdsAntiDriftCalibrate, menuAdsCycleEditValue, menuAdsCycleListOption, menuAdsMultiSelection }

// (Options) Crouch Shot
enum { crouchOff, crouchOnAds, crouchOnFire }
// (Options) Stance Tracker
enum { stanceTrackerOff, stanceTrackerOn, stanceTrackerOnNoRumble, stanceTrackerTrainingMode }

// (Profiles) Weapon select menu category IDs
enum { AR, SMG, LMG, DMR, SNIPER_SHOTGUN }

// (Settings) Aim Acceleration
enum { aimAccelReduction, aimAccelThreshold }
// (Settings) Weapon Display
enum { displayOff, displayOn, displayAlways }
// (Settings) Deadzone IDs
enum { deadzoneLeft, deadzoneRight }
// (Toggles) Array IDs
enum { toggleProfile = 0, toggleAutoFocus = 2, toggleAutoLean = 4, toggleAutoParachute = 6, toggleAutoTurbo = 8, toggleBurstFire = 10, toggleCrouchShot = 12, toggleRapidFire = 14 }

/**************************************************************/
//	Constants (strings)
/**************************************************************/

// (Anti-drift) Calibration direction
const string antiDriftCalibrationDirectionPrompt[] = { "Direction: Up", "Direction: Down", "Direction: Left", "Direction: Right" }
// (Anti-drift) Calibration result
const string antiDriftCalibrationResult[] = { "Failed", "Success", "Cancelled", "Reset Value" }
// (Anti-drift) Calibration state
const string antiDriftCalibrationStateMsg[] = { "Press A/Cross", "Waiting", "Release Joystick" }
// (Anti-drift) Calibration stick
const string antiDriftCalibrationStickPrompt[] = { "Joystick: Left", "Joystick: Right" }
// (Anti-drift) Values display
const string antiDriftValues[] = { "U: ", "D: ", "L: ", "R: " }

// (Anti-recoil) Scope Names
const string scopeName[] = { "1x", "2x", "3x", "4x", "6x", "8x" }
// (Anti-recoil) Muzzles
const string muzzles[] = { "No Muzzle", "Flash Hider", "Compensator", "Suppressor" }
// (Anti-recoil) Foregrips
const string foregrips[] = { "No Foregrip", "Angled Grip", "Half Grip", "Lightweight Grip", "Thumb Grip", "Vertical Grip" }
// (Anti-recoil) Stocks
const string stocks[] = { "No Stock", "Cheek Pad", "Tactical Stock", "Heavy Stock", "Folding Stock" }

// (Controller) Button layout descriptions
const string buttonLayoutName[] = { "Type A", "Type B", "Type C" }
// (Controller) Button names [PlayStation]
const string controllerButtonsPS4[] = { "not set", "", "", "R1", "R2", "", "L1", "L2", "", "", "", "", "", "Up", "Down", "Left", "Right", "Triangle", "Circle", "Cross", "Square" }
// (Controller) Button names [XBOX]
const string controllerButtonsXBOX[] = { "not set", "", "", "RB", "RT", "", "LB", "LT", "", "", "", "", "", "Up", "Down", "Left", "Right", "Y", "B", "A", "X" }
// (Controller) Bumper/Triggers
const string bumperTriggers[] = { "Default", "Flipped" }
// (Controller) Aim Acceleration
const string aimAcceleration[] = { "Reduction: ", "Threshold: " }
// (Controller) Smoothing
const string smoothing[] = { "Off", "On" }

// (Display) Color names
const string colorName[] = { "Red", "Gold", "Yellow", "Green", "Blue", "Purple", "Pink" }
// (Display) Home screen messages
const string homeScreenMessages[] = { "Empathy", "Version 2.23", "Swedemafia" }
// (Display) Script paused notification
const string vehicleModeMsg = "Vehicle Mode";

// (Options) Crouch Shot
const string crouchShot[] = { "Off", "On ADS", "On Fire" }
// (Options) Grenade Tracker
const string grenadeMode = "Grenade"
// (Options) Stance Tracker
const string stanceTracker[] = { "Off", "On", "On (No Alert)", "Training Mode" }
// (Options) Stance Tracker State
const string stanceTrackerState[] = { "No Weapon", "Handgun/Melee", "Inventory", "Paused", "Map", "Spawn Tool" }

// (Profile) Prompts
const string profileName[] = { "Primary", "Secondary", "Both Profiles" }
// (Profiles) Profile toggle/color prompts
const string profileToggleMsg[] = {
	"Resync: ", "Switch: ", // Profile Switch
	"Button 1: ", "Button 2: ", // Toggle Buttons
	"Primary:   ", "Secondary: ", // Profile Colors
	"Keyboard: " // Keyboard toggle
}

// (Settings) Weapon Display
const string weaponDisplay[] =  { "Off", "On", "Always On" }
// (Settings) Saved notification
const string settingsSaved = "Settings Saved";
// (Settings) Deadzone prompt
const string stickName[] = { "Left: ", "Right: " }
// (Settings) Default Weapons
const string defaultWeapons[] = { "#1: ", "#2: " }

// (Toggles) On/off messages
const string toggleOffOn[] = { "Off", "On" }
// (Toggles) Toggle
const string toggle = "Toggle: "
// (Toggles) Toggle combo messages
const string toggleMessages[] = {
	"Auto Focus: Off", "Auto Focus: On",
	"Auto Lean: Off", "Auto Lean: On",
	"Auto Chute: Off", "Auto Chute: On",
	"Auto Turbo: Off", "Auto Turbo: On",
	"Burst Fire: Off", "Burst Fire: On",
	"Crouch Shot: Off", "Crouch: ",
	"Rapid Fire: Off", "Rapid Fire: On"
}

/**************************************************************/
//	Constants (integers)
/**************************************************************/

// (Anti-recoil) Weapon keyboard key map
const int8 weaponKey[] = {
	KEY_Q, KEY_W, KEY_E, KEY_R, KEY_T, KEY_Y, KEY_U, KEY_I, KEY_O, KEY_P, KEY_LEFTBRACE, KEY_RIGHTBRACE, KEY_BACKSLASH,
	KEY_A, KEY_S, KEY_D, KEY_F, KEY_G, KEY_H, KEY_J, KEY_K, KEY_L, KEY_SEMICOLON, KEY_APOSTROPHE, KEY_ENTER,
	KEY_Z, KEY_X, KEY_C, KEY_V, KEY_B, KEY_N, KEY_M, KEY_COMMA
}

// (Anti-recoil) Attachment adjustment
const int8 muzzlePercentage_AR[] 	= { 0, 5, 10, 0 };
const int8 muzzlePercentage_SMG[] 	= { 0, 5, 15, 0 };
const int8 muzzlePercentage_DMR[] 	= { 0, 10, 20, 0 };
const int16 scopePercentage[] 		= { 0, 25, 85, 90, 90, 100 };
const int16 scopePercentage_DMR[] 	= { 0, 22, 72, 72, 85, 100 };
const int8 stockPercentage[] 		= { 0, 20, 0, 2, 10 };
const int8 foregripPercentage_AR[] 	= { 0, 0, 8, 5, 5, 10 };
const int8 foregripPercentage_SMG[] = { 0, 0, 4, 0, 5, 5 };

// (Anti-recoil) Sensitivity scaling table
const int16 sensitivity[] = {
	315,
	246, 235, 225, 215, 205, 193, 184, 178, 172, 157,
	154, 154, 142, 140, 138, 136, 124, 124, 122, 113,
	113, 110, 108, 103, 102, 90, 88, 88, 88, 86,
	86, 86, 86, 84, 82, 79, 78, 76, 76, 76,
	63, 60, 60, 59, 57, 52, 51, 46, 46, 42,
	40, 40, 39, 39, 37, 36, 36, 36, 36, 35,
	33, 30, 28, 28, 28, 27, 25, 25, 24, 22,
	21, 21, 20, 20, 19, 19, 17, 17, 15, 14,
	14, 13, 13, 13, 9, 9, 5, 4, 4, 0,
	-1, -2, -3, -3, -4, -4, -5, -5, -6, -7,
	-8, -9, -9, -9, -9, -10, -11, -11, -12, -15,
	-16, -16, -16, -17, -18, -18, -18, -18, -19, -20,
	-20, -20, -21, -22, -22, -23, -23, -24, -24, -24,
	-24, -24, -24, -24, -24, -24, -24, -25, -25, -25,
	-25, -25, -26, -26, -26, -27, -29, -29, -29, -30,
	-31, -31, -31, -31, -31, -31, -32, -32, -32, -33,
	-33, -33, -33, -34, -34, -34, -35, -35, -36, -37,
	-37, -37, -38, -38, -39, -39, -39, -39, -39, -40,
	-40, -40, -40, -40, -40, -41, -42, -42, -42, -43,
	-43, -44, -44, -44, -44, -45, -45, -45, -45, -45
}

// (Controller) List of possible buttons to be used for a toggle combination
const int8 controllerButtons[] = { XB1_VIEW, XB1_RB, XB1_RT, XB1_LB, XB1_LT, XB1_UP, XB1_DOWN, XB1_LEFT, XB1_RIGHT, XB1_Y, XB1_B, XB1_A, XB1_X }
// (Controller) Button Layout map
const int8 buttonLayoutMap[][] = {
	// Aim	  ADS	  Melee   Fire    Switch Interact Action Jump   LeanL   LeanR   Focus   Zoom
	{ XB1_LT, XB1_LT, XB1_UP, XB1_RT, XB1_Y, XB1_X,   XB1_B, XB1_A, XB1_LS, XB1_RS, XB1_LB, XB1_RB }, // Type A
	{ XB1_LB, XB1_LT, XB1_UP, XB1_RT, XB1_Y, XB1_X,   XB1_B, XB1_A, XB1_LS, XB1_RS, XB1_LB, XB1_RB }, // Type B
	{ XB1_LT, XB1_LT, XB1_RIGHT, XB1_RT, XB1_Y, XB1_X, XB1_B, XB1_A, XB1_LB, XB1_RB, XB1_LS, XB1_RS} // Type C
}

// (Display) HSB color values
const int16 colorValues[][] = {
	{ 0, 100, 75 }, { 17, 100, 100 }, { 30, 100, 100 }, { 120, 100, 75 }, { 200, 100, 50 },
	{ 300, 100, 50 }, { 359, 50, 75 }, { 20, 50, 100 },  { 135, 100, 75 }, { 10, 100, 75 }
}
// (Display) Line numbers for OLED_FONT_SMALL
const int8 lineNumber[] = { 22, 34, 46 }
// (Display) Font height
const int8 fontHeight[] = { OLED_FONT_SMALL_HEIGHT, OLED_FONT_MEDIUM_HEIGHT, OLED_FONT_LARGE_HEIGHT }
// (Display) Font width
const int8 fontWidth[] = { OLED_FONT_SMALL_WIDTH, OLED_FONT_MEDIUM_WIDTH, OLED_FONT_LARGE_WIDTH }
// (Display) Menu action buttons
const uint8 menuButtons[] = { XB1_UP, XB1_DOWN, XB1_LEFT, XB1_RIGHT, XB1_A, XB1_B, XB1_RB, XB1_LB, XB1_VIEW }

/**************************************************************/
//	Edit Menu
/**************************************************************/

// (Menu) Edit menu IDs
enum {
	/* Anti-drift */	editMenuAntidrift, editMenuAntidriftCalibration, editMenuAntidriftTest, editMenuAntidriftValues,
	/* Anti-recoil */	editMenuAntiRecoil1x, editMenuAntiRecoil2x, editMenuAntiRecoil3x, editMenuAntiRecoil4x, editMenuAntiRecoil6x, editMenuAntiRecoil8x,
	/* Controller */	editMenuControllerButtonLayout, editMenuControllerBumperTriggers,
	/* Options */		editMenuAutoFocus, editMenuAutoLean, editMenuCrouchShot, editMenuFastLean, editMenuStanceTracker, editMenuWeaponDisplay,
	/* Profiles */		editMenuProfileSwitch, editMenuProfileColors,
	/* Settings */		editMenuAimAcceleration, editMenuBlockRumble, editMenuDeadzone, editMenuDefaultWeapons, editMenuInverted, editMenuKeyboardSwitch, editMenuSmoothing,
	/* Toggles */		editMenuToggleAutoFocus, editMenuToggleAutoLean, editMenuToggleAutoParachute, editMenuToggleAutoTurbo, editMenuToggleBurstFire, editMenuToggleCrouchShot, editMenuToggleRapidFire
}
// (Menu) Edit menu items
const int8 editMenuItems[][] = {
	// Menu				  Minimum			Maximum
	/* Anti-drift */	{ editMenuAntidrift, editMenuAntidriftValues },
	/* Anti-recoil */	{ editMenuAntiRecoil1x, editMenuAntiRecoil8x },
	/* Controller */	{ editMenuControllerButtonLayout, editMenuControllerBumperTriggers },
	/* Options */		{ editMenuAutoFocus, editMenuWeaponDisplay },
	/* Profiles */		{ editMenuProfileSwitch, editMenuProfileColors },
	/* Settings */		{ editMenuAimAcceleration, editMenuSmoothing },
	/* Toggles */		{ editMenuToggleAutoFocus, editMenuToggleRapidFire }
}
// (Menu) Edit menu names
const string editMenuNames[] = {
	/* Anti-drift */	"Anti-drift", "Calibration", "Drift Test", "Drift Values", 
	/* Anti-recoil */	"1x Sensitivity", "2x Sensitivity", "3x Sensitivity", "4x Sensitivity", "6x Sensitivity", "8x Sensitivity",
	/* Controller */	"Button Layout", "Bumper/Triggers",
	/* Options */		"Auto Focus", "Auto Lean", "Crouch Shot", "Fast Lean", "Stance Tracker", "Weapon Display",
	/* Profiles */		"Profile Buttons", "Profile Colors",
	/* Settings */		"Aim Acceleration", "Block Rumble", "Deadzone", "Default Weapons", "Inverted", "Keyboard Switch", "Smoothing",
	/* Toggles */		"Auto Focus", "Auto Lean", "Auto Parachute", "Auto Turbo", "Burst Fire", "Crouch Shot", "Rapid Fire"
}

/**************************************************************/
//	Mod Menu
/**************************************************************/

// (Menu) Mod menu IDs
enum { modMenuAntidrift, modMenuAntiRecoil, modMenuController, modMenuOptions, modMenuProfiles, modMenuSettings, modMenuToggles }

// (Menu) Mod menu items
const int8 modMenuItems[][] = {
	// Previous			Current			Next
	{ modMenuToggles, modMenuAntidrift, modMenuAntiRecoil },
	{ modMenuAntidrift, modMenuAntiRecoil, modMenuController },
	{ modMenuAntiRecoil, modMenuController, modMenuOptions },
	{ modMenuController, modMenuOptions, modMenuProfiles },
	{ modMenuOptions, modMenuProfiles, modMenuSettings },
	{ modMenuProfiles, modMenuSettings, modMenuToggles },
	{ modMenuSettings, modMenuToggles, modMenuAntidrift }
}

// (Menu) Mod menu names
const string modMenuNames[] = { "Anti-drift", "Anti-recoil", "Controller", "Options", "Profiles", "Settings", "Toggles" }

/**************************************************************/
//	Weapon Data
/**************************************************************/

// Weapon  IDs
enum {
	akm, beryl, g36c, m416, m16a4, scar, mutant, qbz, aug, groza, ace32, k2, famas,
	bizon, tommy, ump, uzi, vector, mp5, p90, mp9, dp28, m249, mg3_660, mg3_990,
	slr, mini14, sks, vss, qbu, mk14_semi, /*mk14_auto,*/ mk12,
	sniper_shotgun
}

// Weapon names
const string weaponName[] = {
	// AR (12)
	"AKM", "Beryl M762", "G36C", "M416", "M16A4", "SCAR-L", "Mk47 Mutant", "QBZ", "AUG", "Groza", "ACE32", "K2", "FAMAS",
	// SMG (8)
	"PP-19 Bizon", "Tommy Gun", "UMP45", "Micro UZI", "Vector", "MP5K", "P90", "MP9",
	// LMG (3)
	"DP-28", "M249", "MG3 (660rpm)", "MG3 (990rpm)",
	// DMR (7)
	"SLR", "Mini14", "SKS", "VSS", "QBU", "Mk14 (Semi)", /*"Mk14 (Auto)",*/ "Mk12",
	// SR (1)
	"Sniper/Shotgun"
}

// Weapon Select menu category ranges
const int8 weaponSelectCategoryMenu[][] = { { akm, famas }, { bizon, mp9 }, { dp28, mg3_990 }, { slr, mk12 }, { sniper_shotgun, sniper_shotgun } }

// Weapon recoil data index
const int16 weaponIndex[] = {
	/* Assault Rilfes */ 		0, 10, 14, 21, 29, 32, 38, 41, 52, 58, 66, 75, 85,
	/* Sub-machine Guns */ 		92, 101, 110, 118, 132, 147, 156, 164,
	/* Light Machine Guns */ 	171, 181, 195, 202,
	/* Designated Marksman */	210, 213, 216, 219, 227, 230, 233
}

// P90 scopes
const string p90Scopes[] = { "Low Zoom", "High Zoom" }
// Weapon selector category
const string weaponSelectCategory[] = { "AR", "SMG", "LMG", "DMR", "Sniper/Shotgun" }
// Weapon selector display
const string weaponSelectDisplay[] = { "Primary", "Secondary", "Weapon Select" }

// Weapon Recoil Data
const int16 weaponData[][] = {

		/* Assault Rifles */
		
	/* AKM */ { 0, 8 },
			{ 91, 76 },
		/* Vertical */
			{ 24, 500 },
			{ 30, 1100 },
			{ 30, 500 },
			{ 31, 600 },
			{ 28, 200 },
			{ 29, 300 },
			{ 30, 500 },
			{ 29, 650 },
	/* Beryl */ { 0, 2 }, // 10
			{ 93, 80 },
		/* Vertical */
			{ 32, 1200 },
			{ 34, 2300 },
	/* G36C */ { 0, 5 }, // 14
			{ 93, 75 },
		/* Vertical */
			{ 25, 500 },
			{ 32, 1100 },
			{ 33, 500 },
			{ 34, 900 },
			{ 35, 500 },
	/* M416 */ { 0, 6 }, // 21
			{ 93, 75 },
		/* Vertical */
			{ 25, 400 },
			{ 32, 1600 },
			{ 33, 300 },
			{ 34, 500 },
			{ 35, 200 },
			{ 34, 600 },
	/* M16A4 */ { 0, 0 }, // 29
			{ 89, 60 },
			{ 19, 0 }, 
	/* Scar-L */ { 0, 4 }, // 32
			{ 93, 80 },
		/* Vertical */
			{ 25, 500 },
			{ 27, 200 },
			{ 29, 400 },
			{ 32, 2800 },
	/* Mutant Mk47 */ { 0, 0 }, // 38
			{ 96, 85 },
			{ 18, 0 },
	/* QBZ */ { 0, 9 }, // 41
			{ 91, 75 },
		/* Vertical */
			{ 24, 500 },
			{ 28, 200 },
			{ 29, 200 },
			{ 32, 400 },
			{ 33, 200 },
			{ 34, 800 },
			{ 33, 600 },
			{ 32, 400 },
			{ 33, 600 },
	/* AUG */ { 0, 4 }, // 52
			{ 92, 75 },
		/* Vertical */
			{ 25, 400 },
			{ 34, 400 },
			{ 35, 1000 },
			{ 36, 2200 },
	/* Groza */ { 0, 6 }, // 58
			{ 89, 75 },
		/* Vertical */
			{ 26, 500 },
			{ 27, 200 },
			{ 30, 600 },
			{ 31, 1000 },
			{ 32, 200 },
			{ 31, 800 },
	/* ACE32 */ { 0, 7 }, // 66
			{ 92, 75 },
		/* Vertical */
			{ 28, 500 },
			{ 29, 200 },
			{ 30, 400 },
			{ 31, 200 },
			{ 32, 700 },
			{ 33, 400 },
			{ 32, 1300 },
	/* K2 */ { 0, 8 }, // 75
			{ 93, 77 },
		/* Vertical */
			{ 26, 200 },
			{ 28, 200 },
			{ 29, 200 },
			{ 30, 200 },
			{ 31, 400 },
			{ 32, 1000 },
			{ 33, 900 },
			{ 34, 400 },
			
	/* FAMAS */ { 0, 5 }, // 85
			{ 93, 77 },
		/* Vertical */
			{ 22, 200 },
			{ 29, 200 },
			{ 30, 200 },
			{ 31, 300 },
			{ 32, 1100 },
			
	/* Sub-machine Guns */
	
	/* PP-Bizon */ { 0, 7 }, // 92
			{ 88, 82 },
		/* Vertical */
			{ 22, 400 },
			{ 24, 200 },
			{ 28, 300 },
			{ 26, 2300 },
			{ 25, 500 },
			{ 26, 300 },
			{ 28, 500 },
	/* Tommy Gun */ { 0, 7 }, 
			{ 88, 82 },
		/* Vertical */
			{ 26, 400 },
			{ 28, 300 },
			{ 31, 200 },
			{ 33, 400 },
			{ 34, 1600 },
			{ 33, 700 },
			{ 34, 900 },
	/* UMP45 */ { 0, 6 },
			{ 90, 82 },
		/* Vertical */
			{ 24, 400 },
			{ 26, 300 },
			{ 27, 300 },
			{ 28, 300 },
			{ 30, 1200 },
			{ 29, 800 },
	/* Micro Uzi */ { 0, 12 },
			{ 90, 82 },
		/* Vertical */
			{ 23, 300 },
			{ 25, 100 },
			{ 28, 100 },
			{ 30, 100 },
			{ 31, 100 },
			{ 32, 100 },
			{ 33, 100 },
			{ 34, 100 },
			{ 35, 100 },
			{ 36, 100 },
			{ 37, 100 },
			{ 38, 300 },
	/* Vector */ { 0, 13 },
			{ 90, 82 },
		/* Vertical */
			{ 30, 100 },
			{ 29, 100 },
			{ 32, 100 },
			{ 33, 100 },
			{ 34, 100 },
			{ 35, 100 },
			{ 36, 100 },
			{ 41, 100 },
			{ 42, 100 },
			{ 43, 100 },
			{ 42, 100 },
			{ 43, 100 },
			{ 44, 500 },
	/* MP5K */ { 0, 7 },
			{ 90, 82 },
		/* Vertical */
			{ 24, 100 },
			{ 26, 200 },
			{ 27, 200 },
			{ 28, 200 },
			{ 29, 200 },
			{ 30, 1100 },
			{ 29, 800 },
	/* P90 */ { 0, 6 }, // 150
			{ 90, 82 },
		/* Vertical */
			{ 25, 300 },
			{ 26, 300 },
			{ 25, 300 },
			{ 24, 300 },
			{ 23, 800 },
			{ 22, 1000 },
	/* MP9 */ { 0, 5 },
			{ 90, 82 },
		/* Vertical */
			{ 24, 200 },
			{ 25, 200 },
			{ 26, 600 },
			{ 25, 600 },
			{ 23, 700 },
		
		/* Light Machine Guns */
		
	/* DP-28 */ { 0, 8 },
			{ 65, 25 },
		/* Vertical */
			{ 26, 500 },
			{ 25, 200 },
			{ 26, 200 },
			{ 27, 200 },
			{ 28, 300 },
			{ 29, 500 },
			{ 31, 1200 },
			{ 30, 2100 },
	/* M249 */ { 0, 12 },
			{ 75, 40 },
		/* Vertical */
			{ 27, 200 },
			{ 29, 100 },
			{ 30, 100 },
			{ 31, 100 },
			{ 32, 200 },
			{ 31, 500 },
			{ 30, 100 },
			{ 29, 100 },
			{ 28, 100 },
			{ 27, 2700 },
			{ 28, 2000 },
			{ 27, 5800 },
	/* MG3 (660rpm) */ { 0, 5 },
			{ 75, 45 },
		/* Vertical */
			{ 22, 200 },
			{ 25, 100 },
			{ 29, 400 },
			{ 30, 500 },
			{ 28, 5500 },
	/* MG3 (990rpm) */ { 0, 6 },
			{ 75, 45 },
		/* Vertical */
			{ 26, 200 },
			{ 38, 300 },
			{ 32, 600 },
			{ 29, 500 },
			{ 30, 2700 },
			{ 32, 120 },
			
		/* Designated Marksman Rifles */
		
	/* SLR */ { 0, 0 },
		// Single  Spam
			{ 95, 80 },
			{ 21, 24 },
	/* Mini14 */ { 0, 0 },
		// Single  Spam
			{ 90, 80 }, // Crouch/prone
			{ 20, 23 },
	/* SKS */ { 0, 0 },
		// Single  Spam
			{ 95, 80 }, // Crouch/prone
			{ 21, 25 },
	/* VSS */ { 0, 6 },
			{ 90, 80 },
		/* Vertical */
			{ 28, 400 },
			{ 60, 150 },
			{ 42, 300 },
			{ 60, 200 },
			{ 55, 300 },
			{ 57, 300 },
	/* QBU */ { 0, 0 },
		// Single  Spam
			{ 90, 35 }, // Crouch/prone
			{ 20, 26 }, 
	/* Mk14 (Semi) */ { 0, 0 },
		// Single  Spam
			{ 75, 45 }, // Crouch/prone
			{ 20, 17 },
	/* Mk14 (Auto) */// { 0, 4 },
			//{ 75, 45 }, // Crouch/prone
			/* Vertical */
			//{ 35, 600 },
			//{ 44, 600 },
			//{ 38, 650 },
			//{ 34, 300 },
	/* Mk12 //*/ { 0, 0 },
		// Single  Spam
			{ 90, 40 }, // Crouch/prone
			{ 22, 26 }
}
   
/**************************************************************/
//	Begin script
/**************************************************************/

init {
	displayBuffer = 1; // Initialize display buffer
	loadSettings(); // Load user-defined settings
	displayUpdate = TRUE; // Enable display update to force home screen
	
	stance = stanceWeapon;
}

main {
	
	removeDriftAndApplyDeadzone(); // Remove stick drift and apply deadzone
	
	if(!displayDepth) {
		swapPS4(); // Fix PS4 issue
		if(!checkPause()) {
			applySmoothing(); // Check for Exponential Smoothing
			applyAimAcceleration(); // Apply any Aim Acceleration
			
			if(!checkCombos()) {
				checkDisplay(); // Check what should be displaying
				checkStanceAlert(); // Check for Stance Tracker alert
				
				// Determine menu to enter, if any
				if(get_ival(button[ads]) && event_press(XB1_MENU)) {
					changeDisplayDepth(1);
				} else if((stance == stanceWeapon) && get_ival(button[ads]) && event_press(XB1_VIEW)) {
					changeDisplayDepth(3);
					// Copy current weapon data
					lastCategory = currentCategory[currentProfile];
					lastWeapon = currentWeapon[currentProfile];
					lastMuzzle = antiRecoilMuzzle[currentProfile];
					lastForegrip = antiRecoilForegrip[currentProfile];
					lastStock = antiRecoilStock[currentProfile];
					lastScope = antiRecoilScope[currentProfile];
				} else if(get_ival(XB1_RB) && !autoParachute && !displayDepth) {
					// Check for forced Weapon Display
					if(event_press(XB1_X)) { 
						weaponDisplayCounter = 3500;
					} else if(userData[vOptionStanceTracker] ) {
						if(event_press(XB1_A)) {
							stancePosition = iif(stancePosition == 2, 0, 2); // Toggle prone
							resetStance(TRUE);
						} else if(event_press(XB1_B)) {
							stancePosition = !stancePosition; // Toggle between standing/crouched
							resetStance(TRUE);
						} else if((stance > stanceInventory) && event_press(XB1_MENU)) {
							stance = (stance & ~stancePaused & ~stanceInventory & ~stanceMap & ~stanceSpawnTool);
							resetStance(FALSE);
						}
						
						// Cancel out buttons
						set_val(XB1_A, 0);
						set_val(XB1_B, 0);
						set_val(XB1_VIEW, 0);
					} 
					
					// Check for weapon//attachments reset
					if(event_press(XB1_VIEW)) {
						weaponDisplayCounter = 3500; // Reset display
						for(i = 0; i < 2; i++) { // Reset attachments
							antiRecoilScope[i] = 0;
							antiRecoilMuzzle[i] = Muzzle_None;
							antiRecoilForegrip[i] = Foregrip_None;
							antiRecoilStock[i] = Stock_None;
						}
					}
					
					// Block button press
					set_val(XB1_MENU, 0);
					
					// Check for attachment actions
					if(event_press(XB1_UP)) {
						if((stance & stanceNoWeapon) || (stance & stancePistol)) {
							stance = stanceWeapon;
							weaponDisplayCounter = 3500;
						} else if(stance & stanceWeapon) {
							cycleScope(); // Scope selector
							weaponDisplayCounter = 3500;
						}
					} else if(event_press(XB1_RIGHT)) {
						if(stance & stanceGrenade) {
							stance = stanceWeapon;
						} else {
							cycleStock(); // Stock selector
						}
						weaponDisplayCounter = 3500;
						displayUpdate = TRUE;
					} else if(stance & stanceWeapon) {
						if(event_press(XB1_DOWN)) {
							cycleForegrip(); // Foregrip selector
							weaponDisplayCounter = 3500;
						} else if(event_press(XB1_LEFT)) {
							cycleMuzzle(); // Muzzle selector
							weaponDisplayCounter = 3500;
						}
					}
					
					// Cancel out buttons
					set_val(XB1_LEFT, 0);
					set_val(XB1_RIGHT, 0);
					set_val(XB1_UP, 0);
					set_val(XB1_DOWN, 0);
				}
			}
			
			// Check for P90 scope toggle
			if((currentWeapon[currentProfile] == p90) && get_ival(button[ads]) && event_press(XB1_X)) {
				stopCombos(); // Stop combos that may use the OLED
				combo_restart(cboChangeScope); // Alert user via rumble
				antiRecoilScope[currentProfile] = antiRecoilScope[currentProfile] ^ 1;
				weaponDisplayCounter = 3500;
			}
			
			// Remove drift and apply deadzone if calibration is not running
			if(!antiDriftCalibrationState && !displayDepth) { // displayDepth is checked again because Anti-drift may modify it
				checkOptions(); // Execute any running options
				checkTriggers(); // Get trigger state & set hair triggers
				checkAssist(); // Execute any enabled assists (Anti-recoil)
				checkKeys(); // Check for keyboard presses
				checkStance(); // Check for stance
				checkToggles(); // Execute any toggles
				determineLEDColor(); // Determine LED color
				blockActionButtons(); // Block any buttons used in toggles/profile switches
			}
		}
		
		checkAutoTurbo(); // Check for Auto Turbo
	} else if(displayDepth == 1) {
		setProfileLedColor(menuProfile); // Set LED to Profile being edited
		checkModMenuEvent(); // Check for mod menu events
		checkToggles(); // Check for Profile switches
	} else if(displayDepth == 2) {
		if(editMenuIndex == editMenuProfileColors) {
			setProfileLedColor(editMenuSelectedRow); // Set LED to Profile Color being edited
		} else if(antiDriftCalibrationState) {
			// Determine stick being calibrated
			if(antiDriftCalibrationStick == antiDriftLeftStick) {
				antiDriftCalibrationPolarStick = iif(antiDriftCalibrationDirection == antiDriftUp || antiDriftCalibrationDirection == antiDriftDown, POLAR_LY, POLAR_LX);
			} else {
				antiDriftCalibrationPolarStick = iif(antiDriftCalibrationDirection == antiDriftUp || antiDriftCalibrationDirection == antiDriftDown, POLAR_RY, POLAR_RX);
			}
			checkCalibrationRange(); // Check calibration range
			setLedColor(iif(antiDriftCalibrationInRange, green, orange)); // Notify user of calibration state
			
			// Display to user "Release Joystick" if they are in range and remove if they are not
			if(antiDriftCalibrationInRange) {
				antiDriftCalibrationState = 2;
				displayUpdate = TRUE;
			} else {
				if(antiDriftCalibrationState == 2 && !antiDriftCalibrationInRange) {
					antiDriftCalibrationState = 1;
					displayUpdate = TRUE;
				}
			}
		} else {
			setProfileLedColor(menuProfile); // Set LED to Profile being edited
		}
		
		checkEditMenuEvent(); // Check for edit menu event
		checkToggles(); // Check for Profile switches
	} else if(displayDepth == 3) {
		setProfileLedColor(currentProfile); // Set LED to Profile being edited
		checkWeaponSelectEvent(); // Check for Weapon Select menu event
	}
	
	blockMenuButtons(); // Block any buttons pressed if in a menu
	checkBlockRumble(); // Always check for blocking rumbled called for by the game
}

// Adjusts the anti-recoil strength based on stance, attachments and scope being used
function adjustAntiRecoil(value) {

	antiRecoilAdjustment = sensitivity[getCurrentSensitivity()]; // Calculate sensitivity adjustment
	antiRecoilAdjustValue = polarValues[value] + (antiRecoilAdjustment * 64); // Store a copy of the value for efficiency
    
	if(stancePosition) { // Determine stance adjustment
		antiRecoilAdjustValue = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * iif(stancePosition == 1, antiRecoilCrouch, antiRecoilProne) / 100));
	}
	
	// Foregrip adjustment
	if(canUseForegrip(currentWeapon[currentProfile])) {
		if(currentCategory[currentProfile] == AR || currentCategory[currentProfile] == DMR) {
			antiRecoilForegripAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * foregripPercentage_AR[antiRecoilForegrip[currentProfile]] / 100));
		} else if(currentCategory[currentProfile] == SMG) {
			antiRecoilForegripAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * foregripPercentage_SMG[antiRecoilForegrip[currentProfile]] / 100));
		}
	}
	
	// Stock adjustment
	if(canUseStock(currentWeapon[currentProfile]) && antiRecoilStock[currentProfile]) {
		if(currentWeapon[currentProfile] != sks) {
			if(currentWeapon[currentProfile] == mk14_semi) {
				antiRecoilStockAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * 5 / 100));
			//} else if(currentWeapon[currentProfile] == mk14_auto && !antiRecoilForegrip[currentProfile]) {
			//	antiRecoilStockAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * 15 / 100));
			} else {
				antiRecoilStockAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * stockPercentage[antiRecoilStock[currentProfile]] / 100));
			}
		} else {
			if(antiRecoilStock[currentProfile] == Stock_CheekPad) {
				antiRecoilStockAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * 10 / 100));
			}
		}
	}
	
	// Muzzle adjustment (variable per category)
	if(canUseMuzzle(currentWeapon[currentProfile])) {
		switch(currentCategory[currentProfile]) {
			case AR {
				antiRecoilMuzzleAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * muzzlePercentage_AR[antiRecoilMuzzle[currentProfile]] / 100));
				// Perform weapon-specific adjustments
				if(antiRecoilMuzzle[currentProfile]) {
					if(currentWeapon[currentProfile] == beryl) {
						if((antiRecoilMuzzle[currentProfile] == Muzzle_Compensator) && canUseForegrip(currentWeapon[currentProfile]) && antiRecoilForegrip[currentProfile]) {
							if(antiRecoilForegrip[currentProfile] == Foregrip_Lightweight) {
								antiRecoilMuzzleAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * 7 / 100));
							} else if(antiRecoilForegrip[currentProfile] != Foregrip_Angled) {
								if(antiRecoilMuzzleAdjust > antiRecoilForegripAdjust) {
									antiRecoilMuzzleAdjust = antiRecoilForegripAdjust;
								} else if(antiRecoilMuzzleAdjust == antiRecoilForegripAdjust) {
									antiRecoilMuzzleAdjust = (antiRecoilMuzzleAdjust >> 1);
								} else if(antiRecoilMuzzleAdjust < antiRecoilForegripAdjust) {
									antiRecoilForegripAdjust = antiRecoilMuzzleAdjust;
								}
							}
						}
					}
				}
				break;
			} case SMG {
				antiRecoilMuzzleAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * muzzlePercentage_SMG[antiRecoilMuzzle[currentProfile]] / 100));
				break;
			} case DMR {
				//if(currentWeapon[currentProfile] == mk14_auto) {
				//	antiRecoilMuzzleAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * (muzzlePercentage_DMR[antiRecoilMuzzle[currentProfile]] >> 2) / 100));
				//} else {
					antiRecoilMuzzleAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * muzzlePercentage_DMR[antiRecoilMuzzle[currentProfile]] / 100));
				//}
				break;
			}
		}
	}
	
	antiRecoilAdjustValue = antiRecoilAdjustValue - antiRecoilForegripAdjust - antiRecoilMuzzleAdjust - antiRecoilStockAdjust; // Calculate adjustment
	
	// Scope adjustment after sensitivity/stance/attachment adjustment
	if(canUseScope(currentWeapon[currentProfile])) {
		if((currentCategory[currentProfile] == LMG) || (currentCategory[currentProfile] == AR)) {
			if((currentWeapon[currentProfile] == m16a4) || (currentWeapon[currentProfile] == mutant)) {
				antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * scopePercentage_DMR[antiRecoilScope[currentProfile]] / 100)); 
			} else {
				if(getCurrentSensitivity() > 100) {
					if(!antiRecoilScope[currentProfile]) {
						if(currentWeapon[currentProfile] == aug) {
							antiRecoilHighSensAdjust = ((getCurrentSensitivity() / 10) >> 1);
						} else {
							antiRecoilHighSensAdjust = (((getCurrentSensitivity() / 10) >> 1) >> 1) >> 1;
						}
						antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * (scopePercentage[antiRecoilScope[currentProfile]] - antiRecoilHighSensAdjust) / 100)); 
					} else if(antiRecoilScope[currentProfile] == 1) {
						if(currentWeapon[currentProfile] == aug) {
							antiRecoilHighSensAdjust = (getCurrentSensitivity() / 10);
						} else {
							antiRecoilHighSensAdjust = (getCurrentSensitivity() / 10) >> 1;
						}
						antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * (scopePercentage[antiRecoilScope[currentProfile]] - antiRecoilHighSensAdjust) / 100));
					} else {
						if(currentWeapon[currentProfile] == aug) {
							antiRecoilHighSensAdjust = (getCurrentSensitivity() / 10) + (((getCurrentSensitivity() / 10) << 1) >> 1);
						} else {
							antiRecoilHighSensAdjust = getCurrentSensitivity() / 10;
						}
						antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * (scopePercentage[antiRecoilScope[currentProfile]] - antiRecoilHighSensAdjust) / 100)); 
					}
				} else {
					antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * scopePercentage[antiRecoilScope[currentProfile]] / 100)); 
				}
			}
		} else if(currentCategory[currentProfile] == SMG) {
			if(getCurrentSensitivity() > 100) {
				if(!antiRecoilScope[currentProfile]) {
					antiRecoilHighSensAdjust = (((getCurrentSensitivity() / 10) >> 1) >> 1) >> 1;
					antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * (scopePercentage[antiRecoilScope[currentProfile]] - antiRecoilHighSensAdjust) / 100)); 
				} else if(antiRecoilScope[currentProfile] == 1) {
					antiRecoilHighSensAdjust = ((getCurrentSensitivity() / 10) >> 1) >> 1;
					if(currentWeapon[currentProfile] == p90) {
						antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * (40 - antiRecoilHighSensAdjust) / 100));
					} else {
						antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * (scopePercentage[1] - antiRecoilHighSensAdjust) / 100));
					}
				} else {
					antiRecoilHighSensAdjust = (getCurrentSensitivity() / 10) >> 1;
					if(currentWeapon[currentProfile] != vector) {
						antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * (scopePercentage[antiRecoilScope[currentProfile]] - antiRecoilHighSensAdjust) / 100)); 
					} else {
						antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * (70 - antiRecoilHighSensAdjust) / 100)); 
					}
				}
			} else {
				antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * scopePercentage[antiRecoilScope[currentProfile]] / 100)); 
			}
		} else if(currentCategory[currentProfile] == DMR) {
			//if(currentWeapon[currentProfile] != mk14_auto) {
				if(getCurrentSensitivity() > 100) {
					if(!antiRecoilScope[currentProfile]) {
						antiRecoilHighSensAdjust = (getCurrentSensitivity() / 10) << 1;
						antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * (scopePercentage[antiRecoilScope[currentProfile]] + antiRecoilHighSensAdjust) / 100)); 
					} else if(antiRecoilScope[currentProfile] == 1) {
						antiRecoilHighSensAdjust = (getCurrentSensitivity() / 10);
						antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * (scopePercentage[antiRecoilScope[currentProfile]] + antiRecoilHighSensAdjust) / 100));
					} else {
						antiRecoilHighSensAdjust = (getCurrentSensitivity() / 10);
						antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * (scopePercentage[antiRecoilScope[currentProfile]] + antiRecoilHighSensAdjust) / 100));
					}
				} else {
					antiRecoilScopeAdjust = antiRecoilAdjustValue - (antiRecoilAdjustValue - (antiRecoilAdjustValue * scopePercentage_DMR[antiRecoilScope[currentProfile]] / 100)); 
				}
			//}
		}
	}
	
	if((userData[vControllerButtonLayout] > cblTypeA) && !get_ival(button[ads])) {
		antiRecoilAdjustValue = antiRecoilAdjustValue;
	} else {
		antiRecoilAdjustValue = antiRecoilAdjustValue + antiRecoilScopeAdjust; // Add strength needed per scope
	}
	antiRecoilForegripAdjust = antiRecoilMuzzleAdjust = antiRecoilStockAdjust = antiRecoilStanceAdjust = 0; // Reset values for next time
	
	return antiRecoilAdjustValue;
}

// This function applies a generic Aim Acceleration to the stick movement
function applyAimAcceleration() {
	// Apply joystick 'Aim Acceleration'
	set_val(POLAR_RX, calculateAimAcceleration(get_val(POLAR_RX)));
	set_val(POLAR_RY, calculateAimAcceleration(get_val(POLAR_RY)));
}

// This function applies Exponential Smoothing to the stick movement, if enabled
function applySmoothing() {
	if(userData[vSmoothing]  && (get_ival(button[ads]) || get_ival(button[fire]))) {
		forecast_x = exponentialSmoothing(get_val(POLAR_RX) * 10, forecast_x); // Calculate X
		forecast_y = exponentialSmoothing(get_val(POLAR_RY) * 10, forecast_y); // Calculate Y
		set_val(POLAR_RX, forecast_x / 10); // Set X
		set_val(POLAR_RY, forecast_y / 10); // Set Y
	}
}

// Block output to controller from menu actions
function blockActionButtons() {
	
	// Loop through each toggle combination and block if being used
	for(i = 0; i < NUMBER_OF_TOGGLE_BUTTONS; i += 2) {
		if(userData[vToggleButton + i] && userData[vToggleButton + i + 1]) {
			if(get_ival(userData[vToggleButton + i]) && get_ptime(userData[vToggleButton + i + 1]) < 250) {
				set_val(userData[vToggleButton + i + 1], 0);
			}
		}
	}
	
	// Block quick edit recoil and entering the menu buttons
	if(get_val(button[ads])) {
		set_val(XB1_MENU, 0);
		set_val(XB1_VIEW, 0);
	}
}

// Block output to controller from menu actions
function blockMenuButtons() {
	// Block all buttons while in a menu
	if(displayDepth) {
		block_all_inputs();
	}
}

// Prepares the display buffer for a multiple item menu
function buildSelectedItemBuffer(type, message, value) {
	// Build display
	insertString(message);
	
	// Determine data type being used
	if(type == displayString) {
		insertString(value);
	} else {
		insertNumber(value);
	}
}

// Joystick response adjustment
// Will set any % stick movement under THRESHOLD to a REDUCTION percentage
// 	i.e. 66 Threshold 75 Reduction:
//	- Any movement under 66 is only 75% movement output to game
// Will only activate if user is ADS or Firing
function calculateAimAcceleration(z) {
	
	if(get_val(button[ads]) || get_val(button[fire])) {
		// Determine if movement is at or below the threshold
		if(abs(z) <= polarValues[userData[vAimAcceleration + aimAccelThreshold]]) {
			return z - (z - (z * userData[vAimAcceleration + aimAccelReduction] / 100));
		}
		
		return z - (z - (z * (abs(z) / 327) / 100));
	}
	
	return z;
}

// Checks if a weapon can use a muzzle and returns which kind
function canUseMuzzle(x) {
	
	// Groza & Tommy is only Suppressor
	if((x == groza) || (x == tommy)) {
		return Muzzle_Suppressor;
	} else if((x == p90) || (x == mp9) || (x == vss) || (x >= dp28 && x <= mg3_990)) {
		return Muzzle_None;
	}

	return Muzzle_FlashHider;
}

// Checks if a weapon can use a foregrip and returns which kind
function canUseForegrip(x) {
	// Tommy can only use Vertical Grip
	if(x == tommy) {
		return Foregrip_Vertical;
	} else if(x == vector) {
		return Foregrip_Lightweight;
	} else if((currentCategory[currentProfile] == AR) && (x != akm) && (x != m16a4) && (x != groza) && (x != k2) && (x != famas)) {
		return Foregrip_Angled;
	} else if((currentCategory[currentProfile] == SMG) && (x != bizon) && (x != uzi) && (x != p90) && (x != mp9)) {
		return Foregrip_Angled;
	} else if((currentCategory[currentProfile] == DMR) && (x != slr) && (x != mini14) && (x != vss) && (x != qbu) && (x != mk14_semi) /*&& (x != mk14_auto)*/) {
		return Foregrip_Angled;
	}
	
	return Foregrip_None;
}

// Checks if a weapon can use a stock and returns which kind
function canUseStock(x) {
	if((x == m16a4) || (x == m416) || (x == mutant) || (x == ace32) || (x == vector) || (x == mp5) || (x == m249)) {
		return Stock_Tactical; // OR Stock_Heavy
	} else if((x == slr) || (x == sks) || (x == vss) || (x == mk14_semi) /*|| (x == mk14_auto)*/) {
		return Stock_CheekPad;
	} else if((x == uzi) || (x == mp9)) {
		return Stock_Folding;
	}
	
	return Stock_None;
}


// Checks if weaponc an use a scope other than 1x/default
function canUseScope(profile) {
	if((currentWeapon[profile] != vss) && (currentWeapon[profile] != uzi) && (currentWeapon[profile] != tommy) && (currentWeapon[profile] != mp9) && (currentWeapon[profile] != sniper_shotgun)) {
		return TRUE;
	}
	return FALSE;
}

// Checks if a weapon can use a 8x scope
function canUse8x(profile) {
	if((currentCategory[profile] == DMR) || (currentWeapon[profile] == m16a4) || (currentWeapon[profile] == mutant)) {
		return TRUE;
	}
	
	return FALSE;
}

// Cycle through available foregrips for a specific weapon
function cycleForegrip() {
	switch(canUseForegrip(currentWeapon[currentProfile])) {
		case Foregrip_Angled { // Can use anything
			antiRecoilForegrip[currentProfile] = cycleListOption(antiRecoilForegrip[currentProfile], cycleValueUp, Foregrip_Vertical, Foregrip_None); 
			stopCombos(); // Stop combos that may use the OLED
			combo_restart(cboChangeForegrip);
			break;	
		} case Foregrip_Vertical { // Vertical only (i.e. Tommy)
			antiRecoilForegrip[currentProfile] = iif(!antiRecoilForegrip[currentProfile], Foregrip_Vertical, Foregrip_None);
			stopCombos(); // Stop combos that may use the OLED
			combo_restart(cboChangeForegrip);
			break;
		} case Foregrip_Lightweight {
			if(!antiRecoilForegrip[currentProfile]) {
				antiRecoilForegrip[currentProfile] = Foregrip_Half;
			} else if(antiRecoilForegrip[currentProfile] == Foregrip_Half) {
				antiRecoilForegrip[currentProfile] = Foregrip_Lightweight;
			} else if(antiRecoilForegrip[currentProfile] == Foregrip_Lightweight) {
				antiRecoilForegrip[currentProfile] = Foregrip_Vertical;
			} else if(antiRecoilForegrip[currentProfile] == Foregrip_Vertical) {
				antiRecoilForegrip[currentProfile] = Foregrip_None;
			}
			stopCombos(); // Stop combos that may use the OLED
			combo_restart(cboChangeForegrip);
			break;
		}
	}
}

// Cycle through available muzzles for a specific weapon
function cycleMuzzle() {
	switch(canUseMuzzle(currentWeapon[currentProfile])) {
		case Muzzle_FlashHider { // Flash Hider = can use anything
			antiRecoilMuzzle[currentProfile] = cycleListOption(antiRecoilMuzzle[currentProfile], cycleValueUp, Muzzle_Suppressor, Muzzle_None); 
			stopCombos(); // Stop combos that may use the OLED
			combo_restart(cboChangeMuzzle);
			break;
		} case Muzzle_Suppressor { // Limited to Suppressor only (i.e. Tommy / Groza)
			if(!antiRecoilMuzzle[currentProfile]) {
				antiRecoilMuzzle[currentProfile] = Muzzle_Suppressor;
			} else {
				antiRecoilMuzzle[currentProfile] = Muzzle_None;
			}
			stopCombos(); // Stop combos that may use the OLED
			combo_restart(cboChangeMuzzle);
			break;	
		}
	}
}

// Cycle through available scopes for a specific weapon
function cycleScope() {
	if(canUseScope(currentProfile) && (currentWeapon[currentProfile] != p90)) {
		antiRecoilScope[currentProfile] = cycleListOption(antiRecoilScope[currentProfile], cycleValueUp, iif(canUse8x(currentProfile), 5, 4), 0);
		stopCombos(); // Stop combos that may use the OLED
		combo_restart(cboChangeScope); // Alert user via rumble
	}
}

// Cycle through available stocks for a specific weapon
function cycleStock() {
	switch(canUseStock(currentWeapon[currentProfile])) {
		case Stock_CheekPad {
			antiRecoilStock[currentProfile] = !antiRecoilStock[currentProfile];
			stopCombos(); // Stop combos that may use the OLED
			combo_restart(cboChangeStock);
			break;
		} case Stock_Tactical {
			if(!antiRecoilStock[currentProfile]) {
				antiRecoilStock[currentProfile] = Stock_Tactical;
			} else if(antiRecoilStock[currentProfile] == Stock_Tactical) {
				antiRecoilStock[currentProfile] = Stock_Heavy;
			} else if(antiRecoilStock[currentProfile] == Stock_Heavy) {
				antiRecoilStock[currentProfile] = Stock_None;
			}
			stopCombos(); // Stop combos that may use the OLED
			combo_restart(cboChangeStock);
			break;
		} case Stock_Folding {
			antiRecoilStock[currentProfile] = iif(antiRecoilStock[currentProfile] == Stock_None, Stock_Folding, Stock_None);
			stopCombos(); // Stop combos that may use the OLED
			combo_restart(cboChangeStock);
			break;
		}
	}
}

// This function changes the display depth
function changeDisplayDepth(depth) {
	combo_stop_all();
	reset_rumble();
	displayDepth = depth; // Set display depth & enable update
	displayUpdate = TRUE; // Enable display update
	menuProfile = currentProfile; // Set current profile
	screenSaverCounter = 0; // Reset Screen Saver
	weaponDisplayCounter = 0; // Reset Weapon Display Counter
	screenSaverEnabled = FALSE; // Set Screen Saver to OFF
}

// Checks the stick when in calibration mode to make sure the
// user has moved the stick to the appropriate range prior to
// releasing the stick and setting the new value
function checkCalibrationRange() {
	// Determine target range
	if((antiDriftCalibrationDirection == antiDriftLeft) || (antiDriftCalibrationDirection == antiDriftUp)) {
		antiDriftCalibrationLow = -11468; // 35
		antiDriftCalibrationHigh = -8191 // 25
	} else {
		antiDriftCalibrationLow = 8191; // 25
		antiDriftCalibrationHigh = 11468; // 35
	}
	
	// Get stick value
	antiDriftCalibrationRangeValue = get_val(antiDriftCalibrationPolarStick);
	
	// See if stick is moved within boundaries
	if((antiDriftCalibrationRangeValue >= antiDriftCalibrationLow) && (antiDriftCalibrationRangeValue <= antiDriftCalibrationHigh)) {
		// Notify user it is in range and allow calibration to proceed
		antiDriftCalibrationInRange = TRUE;
		antiDriftCalibrationCanSet = TRUE;
	} else if(((antiDriftCalibrationDirection == antiDriftLeft) || (antiDriftCalibrationDirection == antiDriftUp)) && antiDriftCalibrationRangeValue < antiDriftCalibrationLow) {
		// Stick moved too far, reading will be inaccurate.  Stick pulls too hard back to center
		antiDriftCalibrationCanSet = FALSE;
		antiDriftCalibrationInRange = FALSE;
	} else if(((antiDriftCalibrationDirection == antiDriftRight) || (antiDriftCalibrationDirection == antiDriftDown)) && antiDriftCalibrationRangeValue > antiDriftCalibrationHigh) {
		// Stick moved too far, reading will be inaccurate.  Stick pulls too hard back to center
		antiDriftCalibrationCanSet = FALSE;
		antiDriftCalibrationInRange = FALSE;
	} else {
		// Release zone not met
		antiDriftCalibrationInRange = FALSE;
	} 
}

// Checks if a status change combo is running (i.e. action failed/success)
function checkCombos() {
	if(combo_running(cboActionFailed)) {
		return 1;
	} else if(combo_running(cboActionSuccess)) {
		return 1;
	} else if(combo_running(cboSaveSettings)) {
		return 1;
	} else if(combo_running(cboToggleOn) || combo_running(cboToggleOff)) {
		return 1;
	}
	return 0;
}


// Check and perform display update
function checkDisplayUpdate() {
	// Check for a display update
	if(displayUpdate) {
		// Clear display
		cls_oled(OLED_BLACK);
		// Determine menu to display
		if(displayDepth == 1) {
			displayModMenu(); // Display mod menu
		} else if(displayDepth == 2) {
			displayEditMenu(); // Display edit menu
		} else if(displayDepth == 3) {
			displayWeaponSelect(); // Display Weapon Select menu
		}
	}
}

// Checks for key presses on the keyboard
function checkKeys() {
	if(userData[vKeyboardSwitch]) {
		// Loop through each possible weapon
		for(i = 0; i < sizeof(weaponKey); i++) {
			// Check if user is pressing a key that corresponds to a weapon
			if(get_keyboard(weaponKey[i])) {
			
				// Set last values
				lastWeapon = currentWeapon[currentProfile];
				lastScope = antiRecoilScope[currentProfile];
				lastStock = antiRecoilStock[currentProfile];
				lastForegrip = antiRecoilForegrip[currentProfile];
				lastMuzzle = antiRecoilMuzzle[currentProfile];
				
				// Change current weapon on current profile
				currentWeapon[currentProfile] = i;
				currentCategory[currentProfile] = getWeaponCategory(i);
				
				// Check for scope change
				if(currentWeapon[currentProfile] == p90) {
					antiRecoilScope[currentProfile] = 0; // Reset scope as P90 defaults on Low Zoom
				} else {
					if(lastWeapon == p90) {
						antiRecoilScope[currentProfile] = 0; // If last weapon is P90, reset scope to 1x
					} else if(!canUseScope(currentProfile)) {
						antiRecoilScope[currentProfile] = 0; // If current weapon cannot use scope, reset scope to 1x
					} else if(lastScope == 5 && !canUse8x(currentProfile)) {
						antiRecoilScope[currentProfile] = 0; // If 8x was set and weapon switched, reset scope to 1x
					}
				}
				
				// Check for attachment change
				checkForegripSwap();
				checkMuzzleSwap();
				checkStockSwap();
				
				// Check for Burst Fire, don't allow it to transfer to automatic weapon
				if(burstFire[currentProfile] && isAutomatic(currentWeapon[currentProfile])) {
					burstFire[currentProfile] = FALSE;
				}
				// Check for Rapid Fire, don't allow it to transfer to a weapon that cannot use it
				if(rapidFire[currentProfile] && !canUseRapidFire(currentWeapon[currentProfile])) {
					rapidFire[currentProfile] = FALSE;
				}
				switchProfile(currentProfile);
				return;
			}
		}
	
		// Check for scope change
		if(canUseScope(currentProfile)) {
			if(get_keyboard(KEY_1) || get_keyboard(KEY_KP1)) {
				antiRecoilScope[currentProfile] = 0; // 1x
				stopCombos(); // Stop combos that may use the OLED
				combo_restart(cboChangeScope); // Alert user via rumble
			} else if(get_keyboard(KEY_2) || get_keyboard(KEY_KP2)) {
				antiRecoilScope[currentProfile] = 1; // 2x
				stopCombos(); // Stop combos that may use the OLED
				combo_restart(cboChangeScope); // Alert user via rumble
			} else if(get_keyboard(KEY_3) || get_keyboard(KEY_KP3)) {
				antiRecoilScope[currentProfile] = 2; // 3x
				stopCombos(); // Stop combos that may use the OLED
				combo_restart(cboChangeScope); // Alert user via rumble
			} else if(get_keyboard(KEY_4) || get_keyboard(KEY_KP4)) {
				antiRecoilScope[currentProfile] = 3; // 4x
				stopCombos(); // Stop combos that may use the OLED
				combo_restart(cboChangeScope); // Alert user via rumble
			} else if(get_keyboard(KEY_6) || get_keyboard(KEY_KP6)) {
				antiRecoilScope[currentProfile] = 4; // 6x
				stopCombos(); // Stop combos that may use the OLED
				combo_restart(cboChangeScope); // Alert user via rumble
			} else if(canUse8x(currentProfile) && (get_keyboard(KEY_8) || get_keyboard(KEY_KP8))) {
				antiRecoilScope[currentProfile] = 5; // 8x
				stopCombos(); // Stop combos that may use the OLED
				combo_restart(cboChangeScope); // Alert user via rumble
			}
		}
	}
}

// Determine which Assist mods must be executed
// - Aim Assist (+etc.), Rotation Assist, Anti-recoil
function checkAssist() {
	if(currentWeapon[currentProfile] < sniper_shotgun) {
		// Prepare for DMR spam adjustment
		if(currentCategory[currentProfile] == DMR) {
			switch(currentWeapon[currentProfile]) {
				case slr {
					if(get_brtime(button[fire]) <= 500) {
						antiRecoilCounter += get_rtime();
					} else {
						antiRecoilFireCount = 0;
						antiRecoilCounter = 0;
					}
					break;
				} case mini14 {
					if(get_brtime(button[fire]) <= 270) {
						antiRecoilCounter += get_rtime();
					} else {
						antiRecoilFireCount = 0;
						antiRecoilCounter = 0;
					}
					break;
				} case sks {
					if(get_brtime(button[fire]) <= 350) {
						antiRecoilCounter += get_rtime();
					} else {
						antiRecoilFireCount = 0;
						antiRecoilCounter = 0;
					}
					break;
				} case qbu {
					if(get_brtime(button[fire]) <= 250) {
						antiRecoilCounter += get_rtime();
					} else {
						antiRecoilFireCount = 0;
						antiRecoilCounter = 0;
					}
					break;
				} case mk14_semi {
					if(get_brtime(button[fire]) <= 270) {
						antiRecoilCounter += get_rtime();
					} else {
						antiRecoilFireCount = 0;
						antiRecoilCounter = 0;
					}
					break;
				} case mk12 {
					if(get_brtime(button[fire]) <= 350) {
						antiRecoilCounter += get_rtime();
					} else {
						antiRecoilFireCount = 0;
						antiRecoilCounter = 0;
					}
					break;
				}
			}
		} else if(currentCategory[currentProfile] == AR) {
			if(currentWeapon[currentProfile] == mutant || currentWeapon[currentProfile] == m16a4) {
				if(get_brtime(button[fire]) <= 250) {
					antiRecoilCounter += get_rtime();
				} else {
					antiRecoilFireCount = 0;
					antiRecoilCounter = 0;
				}
			}
		}
	
		// Check Anti-recoil
		if(userData[vControllerButtonLayout]  == cblTypeA) {
			if(get_val(button[fire]) && isAutomatic(currentWeapon[currentProfile])) {
				executeAntiRecoil();
			} else if((event_press(button[fire]) && !isAutomatic(currentWeapon[currentProfile])) || (combo_running(cboBurstFire) || combo_running(cboRapidFire))) {
				executeAntiRecoil();
			} else {
				antiRecoilMaxY = 0;
				antiRecoilIndexY = 0;
				antiRecoilAdjustment = 0;
			}
			
		} else if(userData[vControllerButtonLayout] >= cblTypeB) {
			if(get_val(button[ads]) && get_val(button[fire]) && isAutomatic(currentWeapon[currentProfile])) {
				executeAntiRecoil();
			} else if((get_val(button[ads]) && event_press(button[fire]) && !isAutomatic(currentWeapon[currentProfile])) || (combo_running(cboBurstFire) || combo_running(cboRapidFire))) {
				antiRecoilFireCount++;
				executeAntiRecoil();
			} else if(userData[vOptionStanceTracker] && (stance == stanceWeapon) && get_val(button[fire]) && !get_val(button[ads])) {
				executeAntiRecoil();
			} else if (!get_val(button[fire])) {
				antiRecoilMaxY = 0;
				antiRecoilIndexY = 0;
				antiRecoilAdjustment = 0;
			}
		}
	}
}

// Checks for rumble block state
function checkBlockRumble() {
	if(userData[vBlockRumble]) {
		block_rumble();
	}
}

// Check for edit menu event
function checkEditMenuEvent() {
	// See if edit menu needs to update to the display
	checkDisplayUpdate();
	
	// See if we are setting toggle combination buttons
	if(modMenuIndex == modMenuProfiles) {
		if(editMenuIndex == editMenuProfileSwitch) {
			createToggle(toggleProfile);
		}
	} else if(modMenuIndex == modMenuToggles) {
		switch(editMenuIndex) {
			case editMenuToggleAutoFocus {
				createToggle(toggleAutoFocus);
				break;
			} case editMenuToggleAutoLean {
				createToggle(toggleAutoLean);
				break;
			} case editMenuToggleAutoParachute {
				createToggle(toggleAutoParachute);
				break;
			} case editMenuToggleAutoTurbo {
				createToggle(toggleAutoTurbo);
				break;
			} case editMenuToggleBurstFire {
				createToggle(toggleBurstFire);
				break;
			} case editMenuToggleCrouchShot {
				createToggle(toggleCrouchShot);
				break;
			} case editMenuToggleRapidFire {
				createToggle(toggleRapidFire);
				break;
			}
		}
	}
	
	// Check for events (only responsive to presses under 1000ms)
	for(i = 0; i < sizeof(menuButtons) / sizeof(menuButtons[0]); i++) {
		if(checkEvent(menuButtons[i])) {
			cycleEditMenu(menuButtons[i]);
		}
	}
	
	if(editMenuIndex == editMenuAntidriftTest) {
		// Constantly update display
		displayUpdate = TRUE;
	}
}

// Determine if an event is being called
function checkEvent(b) {
	// Check if user is holding down the button to quickly cycle through values
	if(get_ival(button[ads]) && get_ival(b) && get_ptime(b) > 240) {
		if(editMenuChangeTime >= 120) {
			editMenuChangeTime = 0;
			return TRUE;
		} else {
			editMenuChangeTime += get_rtime();
			return FALSE;
		}
	}
	
	return (event_release(b) && (get_ptime(b) < 720));
}

// Check for mod menu event
function checkModMenuEvent() {
	// See if edit menu needs to update to the display
	checkDisplayUpdate();
	
	// Check for events
	if(event_press(XB1_DOWN)) { // Request mod menu cycle downwards
		cycleModMenu(modMenuDown);
	} else if(event_press(XB1_UP)) {// Request mod menu cycle upwards
		cycleModMenu(modMenuUp); 
	} else if(event_press(XB1_A)) { // Request enter mod menu
		cycleModMenu(modMenuEnter);
	} else if(event_release(XB1_B)) { // Exit mod menu to home screen
		cycleModMenu(modMenuExit);
	}
}

combo cboDelayLean {
	wait(250);
	combo_run(cboAutoLean);
}

// Checks for running options and executes them if enabled
function checkOptions() {

	// Bumper/Triggers
	if(userData[vControllerBumperTriggers] ) {
		if(get_ival(XB1_LB)) {
			set_val(XB1_LB, 0);
			set_val(XB1_LT, 100);	
		}
		if(get_ival(XB1_LT)) {
			set_val(XB1_LT, 0);
			set_val(XB1_LB, 100);
		}
		if(get_ival(XB1_RB)) {
			set_val(XB1_RB, 0);
			set_val(XB1_RT, 100);	
		}
		if(get_ival(XB1_RT)) {
			set_val(XB1_RT, 0);
			set_val(XB1_RB, 100);
		}
	}

	// Auto Focus
	if(userData[vOptionAutoFocus + currentProfile] && (userData[vControllerButtonLayout] >= cblTypeB)) {
		// If aiming, execute combo
		if(get_ival(button[ads]) && !get_ival(button[zoom])) {
			// If combo not running, execute it
			if(!combo_running(cboAutoFocus)) {
				combo_run(cboAutoFocus);
			}
		} else {
			// If not aiming and combo running, stop it
			if(combo_running(cboAutoFocus)) {
				combo_stop(cboAutoFocus);	
			}
		}
	}
	
	// Auto Lean
	if(userData[vOptionAutoLean + currentProfile]) {
		if((abs(get_ival(POLAR_LX) / 327) > 25) && event_press(button[ads]) && !isAutoLean) {
			leanDirection = button[iif(get_ival(POLAR_LX) < 0, leanL, leanR)];
			isAutoLean = TRUE;
			combo_run(cboDelayLean); // Run combo
		} else if(get_ival(button[ads]) && (abs(get_ival(POLAR_LX) / 327) > 25)) {
			if(get_ival(POLAR_LX) < 0) {
				if(leanDirection != button[leanL] || !isAutoLean) {
					leanDirection = button[leanL]; // Lean left
					isAutoLean = TRUE;
					combo_run(cboAutoLean); // Run combo
				}
			} else if(get_ival(POLAR_LX) > 0) {
				if(leanDirection != button[leanR] || !isAutoLean) {
					leanDirection = button[leanR]; // Lean right
					isAutoLean = TRUE;
					combo_run(cboAutoLean); // Run combo
				}	
			}
		} else if(get_ival(button[ads])) {
			if(event_press(button[leanL])) {
				isAutoLean = !isAutoLean;
				leanDirection = iif(isAutoLean, button[leanL], 0);
				if(!leanDirection) {
					combo_stop(cboAutoLean);
					combo_stop(cboDelayLean);
				}
			} else if(event_press(button[leanR])) {
				isAutoLean = !isAutoLean;
				leanDirection = iif(isAutoLean, button[leanR], 0);
				if(!leanDirection) {
					combo_stop(cboAutoLean);
					combo_stop(cboDelayLean);
				}
			}
		} else if(event_release(button[ads])) {
			combo_stop(cboAutoLean);
			combo_stop(cboDelayLean);
			combo_stop(cboFastLean);
			leanDirection = 0;
			isAutoLean = FALSE;
		}
	}
	
	// Auto Parachute
	if(autoParachute) {
	
		if(event_press(XB1_UP) || (get_ival(XB1_UP) && get_ptime(XB1_UP) >= 300)) {
			autoParachuteStrength[1] = cycleEditValue(autoParachuteStrength[1], cycleValueDown, 1, -100);
		} else if(event_press(XB1_DOWN) || (get_ival(XB1_DOWN)&& get_ptime(XB1_DOWN) >= 300)) {
			autoParachuteStrength[1] = cycleEditValue(autoParachuteStrength[1], cycleValueUp, 1, 100);
		} else if(event_press(XB1_LEFT) || (get_ival(XB1_LEFT)&& get_ptime(XB1_LEFT) >= 300)) {
			autoParachuteStrength[0] = cycleEditValue(autoParachuteStrength[0], cycleValueDown, 1, -100);
		} else if(event_press(XB1_RIGHT) || (get_ival(XB1_RIGHT) && get_ptime(XB1_RIGHT) >= 300)) {
			autoParachuteStrength[0] = cycleEditValue(autoParachuteStrength[0], cycleValueUp, 1, 100);
		}
		
		// Block button output
		set_val(XB1_UP, 0);
		set_val(XB1_DOWN, 0);
		set_val(XB1_RIGHT, 0);
		set_val(XB1_LEFT, 0);
		
		// Set stick values
		set_val(XB1_LX, clamp(get_val(XB1_LX) + autoParachuteStrength[0], -100, 100));
		set_val(XB1_LY, clamp(get_val(XB1_LY) + autoParachuteStrength[1], -100, 100));
	}
		
	// Fast Lean
	if(userData[vOptionFastLean]  && (event_release(button[ads]) || event_release(button[fire]))) {
		// Anytime ADS or Fire is released, set leaning to off
		isLeaning = FALSE
		combo_stop(cboFastLean);
	} else if(userData[vOptionFastLean] ) {
		if(((userData[vControllerButtonLayout]  >= cblTypeB) && get_val(button[ads]) && get_val(button[fire])) || (userData[vControllerButtonLayout]  == cblTypeA && get_val(button[fire]))) {
			// Check if RS is pressed to initiate lean combo
			if(event_press(button[leanR])) {
				// Toggle leaning
				isLeaning = !isLeaning;
				// Execute combo if leaning
				if(isLeaning) {
					combo_run(cboFastLean);
				} else {
					combo_stop(cboFastLean);
				}
			} else if(isLeaning) {
				// If already leaning, continue with combo
				combo_run(cboFastLean);
			}
		}
	}
	
	// Burst Fire (& Rapid Fire)
	if(burstFire[currentProfile] && event_press(button[fire]) && !combo_running(cboBurstFire)) {
		// Only run combo if it is not already running
		combo_run(cboBurstFire);
	} else if(rapidFire[currentProfile]) {
		if(holdingADS && holdingFire) {
			combo_run(cboRapidFire);
		} else if((userData[vControllerButtonLayout] >= cblTypeB) && userData[vOptionStanceTracker] && (stance == stanceWeapon) && holdingFire) {
			combo_run(cboRapidFire);
		} else if(event_release(button[fire])) {
			combo_stop(cboRapidFire);
		}
	}
	
	// Crouch Shot
	if(userData[vOptionCrouchShot + currentProfile] && !inVehicle) {
		if(((userData[vOptionCrouchShot + currentProfile] == crouchOnFire) && event_press(button[fire])) || ((userData[vOptionCrouchShot + currentProfile] == crouchOnAds) && event_press(button[ads]))) {
			if(userData[vOptionStanceTracker] && !stancePosition && ((stance == stancePistol) || (stance == stanceWeapon))) {
				// Stance Tracker enabled, not in inventory and standing, can crouch
				if(userData[vControllerButtonLayout] == cblTypeA) {
					combo_run(cboOptionCrouchShot);
				} else if(get_ival(button[ads])) {
					combo_run(cboOptionCrouchShot);
				}
				stancePosition = 1; // Crouched
			} else if(!userData[vOptionStanceTracker] ) {
				if(userData[vControllerButtonLayout] == cblTypeA) {
					combo_run(cboOptionCrouchShot);
				} else if(get_ival(button[ads])) {
					combo_run(cboOptionCrouchShot);
				}
			}
		} else if((((userData[vOptionCrouchShot + currentProfile] == crouchOnFire) && event_release(button[fire])) || (userData[vOptionCrouchShot + currentProfile] == crouchOnAds) && event_release(button[ads])) && (stance < stanceInventory) && (stancePosition == 1)){
			combo_run(cboOptionCrouchShot); // Stand back up
			stancePosition = 0;
		}
	}
}

// Checks if the user is pausing the script (enter vehicle mode)
function checkPause() {
	// Check if pause button combination is pressed
	if(!vehicleMode && get_val(button[fire]) && event_press(XB1_UP) && (get_brtime(XB1_UP) <= 250)) {
		combo_stop_all();
		cls_oled(OLED_BLACK); // Clear screen
		vehicleMode = TRUE;
		inVehicle = TRUE;
		screenSaverEnabled = FALSE; // Disable screen saver
		screenSaverCounter = 0; // Reset screen saver timer
		weaponDisplayCounter = 0; // Reset screen saver weapon counter timer
		printText(alignCenter, alignCenter, vehicleModeMsg[0], OLED_FONT_SMALL, OLED_WHITE); // Display message
		if(swappingPistols && swapWeaponTimer <= 250) {
			swappingPistols = FALSE;
			swapWeaponTimer = 0;
		}
	} else if(vehicleMode && (event_press(XB1_B) || event_press(XB1_A))) {
		if(userData[vOptionStanceTracker] ) {
			stancePosition = 1; // Will get reset to 0
		}
		if(event_press(XB1_B)) {
			inVehicle = FALSE;
		}
		cls_oled(OLED_BLACK); // Clear screen
		autoTurbo = FALSE; // Disable auto turbo
		vehicleMode = FALSE; // Unpause script
		combo_stop(cboAlertVehicleMode); // Disable pause mode notification
		if((stance == stanceWeapon) && userData[vOptionWeaponDisplay]) {
			combo_run(cboWeaponDisplay);
		} else {
			displayUpdate = TRUE;
			checkDisplay();
			displayUpdate = FALSE;
		}
	} else if(vehicleMode) {
		if(displayUpdate && !combo_running(cboToggleAutoTurbo)) {
			if(!autoTurbo) {
				printText(alignCenter, alignCenter, vehicleModeMsg[0], OLED_FONT_SMALL, OLED_WHITE); // Display message
			} else {
				printText(alignCenter, lineNumber[0], vehicleModeMsg[0], OLED_FONT_SMALL, OLED_WHITE);
				printText(alignCenter, lineNumber[1], toggleMessages[toggleAutoTurbo - 2 + autoTurbo], OLED_FONT_SMALL, OLED_WHITE);
			}
			displayUpdate = FALSE; // Disable update
		}
		combo_run(cboAlertVehicleMode); // Enable vehicle mode notification
	} else if(!vehicleMode) {
		if(inVehicle && get_ival(XB1_A) && (get_ptime(XB1_A) >= 1000)) {
			vehicleMode = TRUE;
			printText(alignCenter, alignCenter, vehicleModeMsg[0], OLED_FONT_SMALL, OLED_WHITE); // Display message
		}
	}
	
	return vehicleMode;
}

int stance, swappingWeapon, swappingPistols, swapWeaponTimer;
int leavingSpawnTool, spawnToolTimer;

// (Stance Tracker)
enum { stanceNoWeapon = 1, stancePistol = 2, stanceGrenade = 4, stanceWeapon = 8, stanceInventory = 16, stanceMap = 32, stancePaused = 64, stanceSpawnTool = 128 }

// Checks for toggle combination buttons to be pressed
function checkToggles() {
	
	if(!displayDepth) {
		// Loop through all toggle combinations
		for(i = 0; i < NUMBER_OF_TOGGLE_BUTTONS; i += 2) {
			// Only process if a toggle is set
			if(userData[vToggleButton + i] && userData[vToggleButton + i + 1]) {
				if(get_ival(userData[vToggleButton + i])) {
					if(i == toggleProfile) {
						if(event_release(userData[vToggleButton + i + 1])) {
							if(stance == stanceWeapon) {
								switchProfile(!currentProfile);
							} else {
								stance = stanceWeapon;
								cls_oled(OLED_BLACK);
								combo_run(cboSwitchProfile);
							}
							return;
						}
					} else {
						if(event_press(userData[vToggleButton + i + 1])) {
							if(get_brtime(userData[vToggleButton + i + 1]) <= 240) {
								dispatchToggle(i);
							}
							return;
						}
					}
				}
			}
		}
	}
	if(!displayDepth && !get_ival(XB1_RB)) {
		// See if weapon was being swapped
		if(swappingWeapon) {
			if(swapWeaponTimer >= 300) {
				swapWeaponTimer = 0;
				swappingWeapon = FALSE;
				displayUpdate = TRUE;
				if((stance == stanceWeapon) || (stance == stanceNoWeapon)) {
					stance = stanceWeapon;
					switchProfile(!currentProfile);
				} else {
					stance = stanceWeapon;
					switchProfile(currentProfile);
				}
			}
			swapWeaponTimer += get_rtime();
		} else if(swappingPistols) {
			if(swapWeaponTimer > 250) {
				swappingPistols = FALSE;
				displayUpdate = TRUE;
				swapWeaponTimer = 0;
				stance = stancePistol;
			}
			swapWeaponTimer += get_rtime();
		} else if(leavingSpawnTool) {
			if(spawnToolTimer > 200) {
				leavingSpawnTool = FALSE;
				spawnToolTimer = 0;
			}
			spawnToolTimer += get_rtime();
		} else {
			swapWeaponTimer = 0;
		}
		
		// Check for Paused/Inventory
		if(((stance < stanceInventory) || (stance & stanceMap))) {
			if(userData[vOptionStanceTracker]) {
				if(event_release(XB1_MENU) && (get_ptime(XB1_MENU) < 1000)) {
					stance = (stance & ~stanceMap);
					stance = (stance | stanceInventory);
					displayUpdate = TRUE;
				} else if(get_ival(XB1_MENU) && (get_ptime(XB1_MENU) >= 1000)) {
					stance = (stance & ~stanceMap);
					stance = (stance | stancePaused);
					displayUpdate = TRUE;
				} else if(userData[vOptionStanceTracker] == stanceTrackerTrainingMode) {
					if((get_console() == PIO_PS4 || get_console() == PIO_PS5 || get_controller() == PIO_PS4 || get_controller() == PIO_PS5) && get_ival(PS4_TOUCH) && (get_ptime(PS4_TOUCH) >= 700)) {
						stance = (stance & ~stanceMap);
						stance = (stance | stanceSpawnTool);
						displayUpdate = TRUE;
					} else if(get_ival(XB1_VIEW) && (get_ptime(XB1_VIEW) >= 700)) {
						stance = (stance & ~stanceMap);
						stance = (stance | stanceSpawnTool);
						displayUpdate = TRUE;
					}
				}
			}
			switch(stance) {
				case stanceNoWeapon {
					if(userData[vOptionStanceTracker]) {
						checkStanceSwap(stancePistol, XB1_UP);
						checkStanceSwap(stanceGrenade, XB1_RIGHT);
						checkStanceSwap(stanceWeapon, XB1_Y);
					}
					break;
				} case stancePistol {
					checkStanceSwap(stanceGrenade, XB1_RIGHT);
					checkStanceSwap(stanceWeapon, XB1_Y);
					break;
				} case stanceGrenade {
					if(get_ival(XB1_RB) && event_release(XB1_RIGHT)) {
						stance = stanceWeapon;
						switchProfile(currentProfile);
					} else {
						checkStanceSwap(stancePistol, XB1_UP);
						checkStanceSwap(stanceWeapon, XB1_Y);
					}
					break;
				} case stanceWeapon {
					// Check for grenade swap
					if(checkStanceSwap(stanceWeapon, XB1_Y)) {
						switchProfile(!currentProfile);
					} else {
						if(userData[vOptionStanceTracker]) {
							checkStanceSwap(stanceGrenade, XB1_RIGHT);
							checkStanceSwap(stancePistol, XB1_UP);
						}
					}
					break;
				}
			}
		} else if(stance & stanceSpawnTool) {
			if(event_release(XB1_B) || event_press(XB1_VIEW)) {
				stance = (stance & ~stanceMap);
				stance = (stance ^ stanceSpawnTool);
				leavingSpawnTool = TRUE;
				displayUpdate = TRUE;
				combo_run(cboWeaponDisplay);
				weaponDisplayCounter = 3500;
			}
		} else if(stance & stanceInventory) {
			if(event_release(XB1_MENU)) {
				if((get_ptime(XB1_MENU) < 1000) || event_release(XB1_B)) {
					stance = (stance & ~stanceMap);
					stance = (stance ^ stanceInventory);
					displayUpdate = TRUE;
					combo_run(cboWeaponDisplay);
					weaponDisplayCounter = 3500;
				}
			} else if(get_ival(XB1_MENU) && get_ptime(XB1_MENU) >= 1000) {
				stance = (stance & ~stanceMap);
				stance = (stance ^ stanceInventory);
				stance = (stance | stancePaused);
				displayUpdate = TRUE;
			} else if(userData[vOptionStanceTracker] == stanceTrackerTrainingMode) {
				if((get_controller() == PIO_PS4 || get_controller() == PIO_PS5) && get_ival(PS4_TOUCH) && (get_ptime(PS4_TOUCH) >= 700)) {
					stance = (stance & ~stanceMap);
					stance = (stance ^ stanceInventory);
					stance = (stance | stanceSpawnTool);
					displayUpdate = TRUE;
				} else if(get_ival(XB1_VIEW) && (get_ptime(XB1_VIEW) >= 700)) {
					stance = (stance & ~stanceMap);
					stance = (stance ^ stanceInventory);
					stance = (stance | stanceSpawnTool);
					displayUpdate = TRUE;
				}
			}
		} else if(stance & stancePaused) {
			if(event_release(XB1_B)) {
				stance = (stance ^ stancePaused);
				displayUpdate = TRUE;
				combo_run(cboWeaponDisplay);
				weaponDisplayCounter = 3500;
			}
		}
	} else if(displayDepth == 2) {
		if(event_press(XB1_Y) && ((editMenuIndex == editMenuAutoFocus) || (editMenuIndex == editMenuAutoLean) || (editMenuIndex == editMenuCrouchShot))) {
			menuProfile = !menuProfile;
			displayUpdate = TRUE;
		}
	}
}

function checkStanceSwap(check, press_button) {
	if(iif((check == stanceGrenade) || (check == stancePistol), event_press(press_button), event_release(press_button))) {
		if(!swappingWeapon) {
			if(get_ptime(press_button) <= 250) {
				if(check != stanceWeapon) {
					if((check == stancePistol) && get_ival(button[fire])) {
						swappingPistols = TRUE;
						return FALSE;
					} else {
						stance = check;
						displayUpdate = TRUE;
						return TRUE;
					}
				} else {
					if(check == stanceWeapon) {
						if(stance == stanceNoWeapon) {
							stance = check;
							displayUpdate = TRUE;
							switchProfile(currentProfile);
							return FALSE;
						} else {
							swappingWeapon = TRUE;
							return FALSE;
						}
					} else {
						swappingWeapon = FALSE;
						displayUpdate = TRUE;
						stance = stanceWeapon;
						switchProfile(currentProfile);
						return TRUE;
					}
				}
			} else if(get_ptime(press_button > 250) && (check == stanceWeapon)) {
				if(userData[vOptionStanceTracker]) {
					stance = stanceNoWeapon;
				}
				swappingWeapon = FALSE;
				displayUpdate = TRUE;
				return FALSE;
			}
		} else {
			if(swapWeaponTimer <= 300) {
				if(swappingWeapon) {
					if(userData[vOptionStanceTracker]) {
						stance = stanceNoWeapon;
					}
					swappingWeapon = FALSE;
					displayUpdate = TRUE;
					return TRUE;
				}
			}
		}
	}
	
	return FALSE;
}

// Checks for triggers
function checkTriggers() {

	// Set stick position values and max out if buttons are pressed
	holdingADS = get_val(button[ads]);
	holdingFire = get_val(button[fire]);
	
	if(holdingADS) {
		set_val(button[ads], 100);
	}
	if(holdingFire) {
		set_val(button[fire], 100);
	}
}

// Correct stick input based on drift low/high values including deadzone and compensate for "lost" values
function correctStickInput(low, high, deadzone, stick) {

	// Calculate the boundaries
	antiDriftLowValue = low - polarValues[deadzone];
	antiDriftHighValue = high + polarValues[deadzone];
	antiDriftStickValue = get_val(stick); // Get stick value
	
	// In the drift zone, so set stick to no movement
	if((antiDriftStickValue >= antiDriftLowValue) && (antiDriftStickValue <= antiDriftHighValue)) {
		set_val(stick, 0);
		
	// If user has moved stick under the lower boundary (left/up)
	} else if(antiDriftStickValue < antiDriftLowValue) {
		set_val(stick, clamp((antiDriftStickValue - antiDriftLowValue) - ((antiDriftStickValue / 327) * antiDriftLowValue) / 100, -32768, 32767));
		
	// If user has moved stick over the upper boundary (right/down)
	} else if(antiDriftStickValue > antiDriftHighValue) {
		set_val(stick, clamp((antiDriftStickValue - antiDriftHighValue) + ((antiDriftStickValue / 327) * antiDriftHighValue) / 100, -32768, 32767));
		
	// Just incase stick_value isn't in driftzone and doesn't meet other conditions
	// (i.e. calculations equate to low/high value)
	// At that point we still do not want to make any adjustment because we're not outside of the drift+deadzone
	} else {
		set_val(stick, 0);
	}
}

// Creates a toggle combination
function createToggle(toggle) {
	if(editMenuSelectedRow < 2) {
		// Loop through each controllerButtons and see what is being held down for 3/4 second
		for(i = 0; i < 13; i++) {	
			if(get_val(controllerButtons[i]) && (get_ptime(controllerButtons[i]) >= 720)) {
				if(!editMenuSelectedRow) {
					// Setting HOLD
					userData[vToggleButton + toggle] = setToggleButton(userData[vToggleButton + toggle], controllerButtons[i], userData[vToggleButton + toggle + 1]);
					userData[vToggleButton + toggle] = verifyToggleCombo(userData[vToggleButton + toggle], toggle);
				} else {
					// Setting PRESS
					userData[vToggleButton + toggle + 1] = setToggleButton(userData[vToggleButton + toggle + 1], controllerButtons[i], userData[vToggleButton + toggle]);
					userData[vToggleButton + toggle + 1] = verifyToggleCombo(userData[vToggleButton + toggle + 1], toggle);
				}
			}
		}
	}
}

// This function returns the current sensitivity being used
function getCurrentSensitivity() {

	switch(antiRecoilScope[currentProfile]) {
		case 0 { return userData[vAntiRecoil1x] }
		case 1 { return userData[vAntiRecoil2x] }
		case 2 { return userData[vAntiRecoil3x] }
		case 3 { return userData[vAntiRecoil4x] }
		case 4 { return userData[vAntiRecoil6x] }
	}
	
	return userData[vAntiRecoil8x];
}

// Gets the weapon category by weapon ID
function getWeaponCategory(w) {

	if((w >= akm) && (w <= famas)) {
		return AR;
	} else if((w >= bizon) && (w <= mp9)) {
		return SMG;
	} else if((w >= dp28) && (w <= mg3_990)) {
		return LMG;
	} else if((w >= slr) && (w <= mk12)) {
		return DMR;
	}
	
	return SNIPER_SHOTGUN;
}

function dispatchAdsAntiDriftCalibrate(direction) {
	switch(direction) {
		case XB1_UP {
			if(antiDriftCalibrationDirection != antiDriftUp) {
				antiDriftCalibrationDirection = antiDriftUp;
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_DOWN {
			if(antiDriftCalibrationDirection != antiDriftDown) {
				antiDriftCalibrationDirection = antiDriftDown;
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_LEFT {
			if(antiDriftCalibrationDirection != antiDriftLeft) {
				antiDriftCalibrationDirection = antiDriftLeft;
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_RIGHT {
			if(antiDriftCalibrationDirection != antiDriftRight) {
				antiDriftCalibrationDirection = antiDriftRight;
			} else {
				menuActionFailed();
			}
			break;
		} default {
			menuActionFailed()
		}
	}
}

function dispatchAdsCycleEditValue(direction, profile, variable, min, max) {
	variable += profile;
	switch(direction) {
		case XB1_UP {
			userData[variable] = cycleEditValue(userData[variable], cycleValueUp, 10, max);
			break;
		} case XB1_DOWN {
			userData[variable] = cycleEditValue(userData[variable], cycleValueDown, 10, min);
			break;
		} case XB1_LEFT {
			userData[variable] = cycleEditValue(userData[variable], cycleValueDown, 1, min);
			break;
		} case XB1_RIGHT {
			userData[variable] = cycleEditValue(userData[variable], cycleValueUp, 1, max);
			break;
		} default {
			menuActionFailed();
		}
	}
}

function dispatchAdsCycleListOption(direction) {
	// Only Crouch Shot Toggle has a 3rd row that can be edited
	if(editMenuIndex == editMenuToggleCrouchShot && editMenuSelectedRow != 2) {
		menuActionFailed();
		return;
	}
	
	switch(direction) {
		case XB1_LEFT {
			userData[editMenuVariable2 + iif(editMenuIndex == editMenuToggleCrouchShot && editMenuSelectedRow == 2, 0, editMenuSelectedRow)] = cycleListOption(userData[editMenuVariable2 + iif(editMenuIndex == editMenuToggleCrouchShot && editMenuSelectedRow == 2, 0, editMenuSelectedRow)], cycleValueDown, editMenuAdsMinValue, editMenuAdsMaxValue);
			break;
		} case XB1_RIGHT {
			userData[editMenuVariable2 + iif(editMenuIndex == editMenuToggleCrouchShot && editMenuSelectedRow == 2, 0, editMenuSelectedRow)] = cycleListOption(userData[editMenuVariable2 + iif(editMenuIndex == editMenuToggleCrouchShot && editMenuSelectedRow == 2, 0, editMenuSelectedRow)], cycleValueUp, editMenuAdsMaxValue, editMenuAdsMinValue);
			break;
		} default {
			menuActionFailed();
		}
	}
}

function dispatchAdsMultiSelection(direction) {
	switch(direction) {
		case XB1_UP {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleEditValue(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueUp, 10, editMenuAdsMaxValue);
			break;
		} case XB1_DOWN {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleEditValue(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueDown, 10, editMenuAdsMinValue);
			break;
		} case XB1_LEFT {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleEditValue(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueDown, 1, editMenuAdsMinValue);
			break;
		} case XB1_RIGHT {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleEditValue(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueUp, 1, editMenuAdsMaxValue);
			break;
		} default {
			menuActionFailed();
		}
	}
}

function dispatchAntiDriftCalibrate(direction) {
	if(direction == XB1_LB || direction == XB1_RB) {
		antiDriftCalibrationStick = !antiDriftCalibrationStick;
	} else {
		switch(direction) {
			case XB1_VIEW {
				if(!antiDriftCalibrationState) {
					if(antiDriftCalibrationStick == antiDriftLeftStick) {
						userData[vAntiDriftLeft + antiDriftCalibrationDirection] = 0;
					} else {
						userData[vAntiDriftRight + antiDriftCalibrationDirection] = 0;
					}
					antiDriftCalibrationCanSet = 3;
					combo_run(cboCalibrationComplete); // Alert user of status
					antiDriftCalibrationState = !antiDriftCalibrationState; // Keep process disabled as combo will flop this value positive
				}
				break;
			} case XB1_A {
				if(antiDriftCalibrationState) {
					// Only set if range was met
					if(antiDriftCalibrationCanSet) {
						determineAntidriftValue(); // Determine the value to set
					}
					combo_run(cboCalibrationComplete); // Alert user of status
				} else {
					antiDriftCalibrationState = !antiDriftCalibrationState; // Enter calibration process
				}
				break;
			} default {
				dispatchMenuAction(direction);
			}
		}
	}
}

function dispatchCycleListOption(direction, profile) {
	editMenuVariable1 += profile;
	switch(direction) {
		case XB1_UP {
			userData[editMenuVariable1] = cycleListOption(userData[editMenuVariable1], cycleValueUp, editMenuMaxValue, editMenuMinValue);
			break;
		} case XB1_DOWN {
			userData[editMenuVariable1] = cycleListOption(userData[editMenuVariable1], cycleValueDown, editMenuMinValue, editMenuMaxValue);
			break;
		} default {
			dispatchMenuAction(direction);
		}
	}
}

function dispatchMenuAction(direction) {
	switch(direction) {
		case XB1_A {
			if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				// Only set if range was met
				if(antiDriftCalibrationCanSet) {
					determineAntidriftValue(); // Determine the value to set
				}
				combo_run(cboCalibrationComplete); // Alert user of status
			} else if(editMenuIndex == editMenuAntidriftCalibration) {
				antiDriftCalibrationState = !antiDriftCalibrationState; // Enter calibration process
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_B { // When user presses B/Circle
			if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				antiDriftCalibrationCanSet = 2; // Flag for cancelled
				combo_run(cboCalibrationComplete);
			} else {
				displayUpdate = TRUE;
				displayDepth--; // Exit to Mod Menu
				editMenuSelectedRow = 0; // Reset selected item index
				editMenuIndex = 0; // Reset index
			}
			break;
		} case XB1_VIEW {
			if(editMenuIndex == editMenuAntidriftCalibration && !antiDriftCalibrationState) {
				if(antiDriftCalibrationStick == antiDriftLeftStick) {
					userData[vAntiDriftLeft + antiDriftCalibrationDirection] = 0;
				} else {
					userData[vAntiDriftRight + antiDriftCalibrationDirection] = 0;
				}
				antiDriftCalibrationCanSet = 3;
				combo_run(cboCalibrationComplete); // Alert user of status
				antiDriftCalibrationState = !antiDriftCalibrationState; // Keep process disabled as combo will flop this value positive
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_RB { // When user presses RB
			if((editMenuIndex == editMenuAntidriftCalibration) && (antiDriftCalibrationStick != antiDriftRightStick) && !antiDriftCalibrationState) {
				antiDriftCalibrationStick = antiDriftRightStick;
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_LB { // When user presses LB
			if((editMenuIndex == editMenuAntidriftCalibration) && (antiDriftCalibrationStick != antiDriftLeftStick) && !antiDriftCalibrationState) {
				antiDriftCalibrationStick = antiDriftLeftStick;
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_LEFT {
			if(editMenuIndex == editMenuAntidrift && !userData[vAntiDrift]) {
				menuActionFailed(); // Anti-drift must be enabled to see rest of options
			} else if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				menuActionFailed(); // Cannot leave calibration menu if calibration is running
			} else {
				editMenuSelectedRow = 0; // Reset selected item index
				editMenuIndex = cycleListOption(editMenuIndex, cycleValueDown, editMenuItems[modMenuIndex][editMenuMin], editMenuItems[modMenuIndex][editMenuMax]);
				// Will not alert in DisplayEditMenu due to constant repeat, so enable here
				if(editMenuIndex == editMenuAntidriftTest) {
					menuActionSuccess();
				}
			}
			break;
		} case XB1_RIGHT {
			if(editMenuIndex == editMenuAntidrift && !userData[vAntiDrift]) {
				menuActionFailed(); // Anti-drift must be enabled to see rest of options
			} else if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				menuActionFailed(); // Cannot leave calibration menu if calibration is running
			} else {
				editMenuSelectedRow = 0; // Reset selected item index
				editMenuIndex = cycleListOption(editMenuIndex, cycleValueUp, editMenuItems[modMenuIndex][editMenuMax], editMenuItems[modMenuIndex][editMenuMin]);
				// Will not alert in DisplayEditMenu due to constant repeat, so enable here
				if(editMenuIndex == editMenuAntidriftTest) {
					menuActionSuccess();
				}
			}
			break;
		} default {
			menuActionFailed();
		}
	}
}

function dispatchMenuMultiSelection(direction) {
	switch(direction) {
		case XB1_UP {
			editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, editMenuMinValue);
			break;
		} case XB1_DOWN {
			editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, editMenuMaxValue);
			break;
		} default {
			dispatchMenuAction(direction);
		}
	}
}

function dispatchMenuNone(direction) {
	if((direction == XB1_UP) || (direction == XB1_DOWN)) {
		menuActionFailed();
	} else {
		dispatchMenuAction(direction);
	}
}

function dispatchMenuToggle(direction) {
	if((direction == XB1_UP) || (direction == XB1_DOWN)) {
		userData[editMenuVariable1 + menuProfile] = (userData[editMenuVariable1 + menuProfile] ^ editMenuMaxValue);
	} else {
		dispatchMenuAction(direction);
	}
}

function dispatchMenuToggleOnOff(direction, profile) {
	editMenuVariable1 += profile;
	if((direction == XB1_UP) || (direction == XB1_DOWN)) {
		userData[editMenuVariable1] = !userData[editMenuVariable1];
	} else {
		dispatchMenuAction(direction);
	}
}

// Cycles the edit menu
function cycleEditMenu(direction) {
	
	displayUpdate = TRUE; // Enable display update
	
	//menuType, menuAdsType, menuVariable1, menuVariable2, menuMinValue, menuMaxValue, menuAdsMinValue, menuAdsMaxValue
	editMenuHoldingADS = get_ival(button[ads]);
	editMenuType = menuData[editMenuIndex][menuType];
	editMenuAdsType = menuData[editMenuIndex][menuAdsType];
	editMenuVariable1 = menuData[editMenuIndex][menuVariable1];
	editMenuVariable2 = menuData[editMenuIndex][menuVariable2];
	editMenuParent = menuData[editMenuIndex][menuParent];
	editMenuMinValue = menuData[editMenuIndex][menuMinValue];
	editMenuMaxValue = menuData[editMenuIndex][menuMaxValue];
	editMenuAdsMinValue = menuData[editMenuIndex][menuAdsMinValue];
	editMenuAdsMaxValue = menuData[editMenuIndex][menuAdsMaxValue];
	
	// Handle the menu action based on whether user is holding ADS or not
	if(!editMenuHoldingADS) {
		switch(editMenuType) {
			case menuAntiDriftCalibrate {
				dispatchAntiDriftCalibrate(direction);
				break;
			} case menuCycleListOption {
				dispatchCycleListOption(direction, iif(isGlobalOption(), 0, menuProfile));
				break;
			} case menuMultiSelection {
				dispatchMenuMultiSelection(direction);
				break;
			} case menuNone {
				dispatchMenuNone(direction);
				break;
			} case menuToggle {
				dispatchMenuToggle(direction);
				break;
			} case menuToggleOnOff {
				dispatchMenuToggleOnOff(direction, iif(isGlobalOption(), 0, menuProfile));
				break;
			} default {
				dispatchMenuAction(direction);
			}
		}
	} else {
		switch(editMenuAdsType) {
			case menuAdsAntiDriftCalibrate {
				dispatchAdsAntiDriftCalibrate(direction);
				break;
			} case menuAdsCycleEditValue {
				dispatchAdsCycleEditValue(direction, iif(isGlobalOption(), 0, menuProfile), editMenuVariable2, editMenuAdsMinValue, editMenuAdsMaxValue);
				break;
			} case menuAdsCycleListOption {
				dispatchAdsCycleListOption(direction);
				break;
			} case menuAdsMultiSelection {
				dispatchAdsMultiSelection(direction);
				break;
			} case menuAdsNone {
				menuActionFailed();
				break;
			}
		}
	}
	
	return;
}

// Cycle an edit menu value by step amount with change limited to a threshold
function cycleEditValue(value, direction, step, threshold) {

	// See what direction we are cycling the values
	if(direction == cycleValueUp) {
		if((value + step) <= threshold) {
			return (value + step);
		} else if(value == threshold) {
			menuActionFailed();
		} else {
			return threshold;
		}
	} else {
		if((value - step) >= threshold) {
			return (value - step);
		} else if(value == threshold) {
			menuActionFailed();
		} else {
			return threshold;
		}
	}
	
	return value;
}

// Cycle a menu value
function cycleListOption(value, direction, threshold, reset_value) {

	// See what direction we are cycling the values
	if(direction == cycleValueUp) {
		if((value + 1) <= threshold) {
			return (value + 1);
		}
	} else {
		if((value - 1) >= threshold) {
			return (value - 1);
		}
	}
	
	return reset_value;
}

// Cycle mod menu value
function cycleModMenu(direction) {
 	
	displayUpdate = TRUE; // Enable display update
	
	// Determine action and handle it accordingly
	switch(direction) {
		case modMenuEnter {
			displayDepth++; // Advance to Edit Menu
			displayUpdate = TRUE; // Enable display update
			editMenuIndex = editMenuItems[modMenuIndex][editMenuMin]; // Set new edit menu index
			break;
		} case modMenuExit {
			displayDepth--; // Exit to Home Screen
			combo_run(cboSaveSettings); // Save settings upon exiting mod menu
			if((userData[vOptionCrouchShot] == crouchOnAds) && (stancePosition == 1)) {
				combo_run(cboOptionCrouchShot);
				stancePosition = 0;
			}
			break;
		} case modMenuDown {
			modMenuIndex++; // Cycle to next menu
			if(modMenuIndex > modMenuToggles) { // Check boundaries
				modMenuIndex = modMenuAntidrift; // Out of bounds, set to minimum
			}
			menuActionSuccess(); // Alert for successful action
			break;
		} case modMenuUp {
			modMenuIndex--; // Cycle to previous menu
			if(modMenuIndex < modMenuAntidrift) { // Check boundaries
				modMenuIndex = modMenuToggles; // Out of bounds, set to maximum
			}
			menuActionSuccess(); // Alert for successful action
			break;
		}
	}
}

// Checks for Auto Turbo toggle and if it should be engaged
function checkAutoTurbo() {
	// Check for Auto Turbo toggle
	if(get_ival(userData[vToggleButton + toggleAutoTurbo]) && event_press(userData[vToggleButton + toggleAutoTurbo + 1]) && get_brtime(userData[vToggleButton + toggleAutoTurbo + 1]) <= 240) {
		combo_stop_all();
		dispatchToggle(toggleAutoTurbo);
	}
	
	// Engage Auto Turbo
	if(autoTurbo) {
		if(get_val(XB1_RT) && !get_val(XB1_LT) && !get_ival(XB1_Y)) {
			set_val(XB1_LB, 100);	
		}
	}
}

function checkDisplay() {
	// Check for Screen Saver, otherwise display Home Screen
	if(displayUpdate && (stance == stanceGrenade)) {
		stopCombos();
		cls_oled(OLED_BLACK); // Clear screen
		printText(alignCenter, alignCenter, grenadeMode[0], OLED_FONT_SMALL, OLED_WHITE);
		displayUpdate = FALSE; // Disable display update
	} else if(displayUpdate && ((stance == stanceNoWeapon) || (stance == stancePistol))) {
		stopCombos();
		cls_oled(OLED_BLACK);
		printText(alignCenter, alignCenter, stanceTrackerState[iif(stance == stanceNoWeapon, 0, 1)], OLED_FONT_SMALL, OLED_WHITE);
		displayUpdate = FALSE;
	} else if(displayUpdate && (stance & stanceSpawnTool)) {
		stopCombos();
		cls_oled(OLED_BLACK);
		printText(alignCenter, alignCenter, stanceTrackerState[5], OLED_FONT_SMALL, OLED_WHITE);
		displayUpdate = FALSE;
	} else if(displayUpdate && (stance & stanceMap)) {
		stopCombos();
		cls_oled(OLED_BLACK);
		printText(alignCenter, alignCenter, stanceTrackerState[4], OLED_FONT_SMALL, OLED_WHITE);
		displayUpdate = FALSE;
	} else if(displayUpdate && (stance >= stanceInventory)) {
		stopCombos();
		cls_oled(OLED_BLACK);
		printText(alignCenter, alignCenter, stanceTrackerState[iif(stance & stanceInventory, 2, 3)], OLED_FONT_SMALL, OLED_WHITE);
		displayUpdate = FALSE;
	} else if(autoParachute && displayUpdate && !combo_running(cboToggleAutoParachute)) {
		cls_oled(OLED_BLACK); // Clear screen
		printText(alignCenter, alignCenter, toggleMessages[toggleAutoParachute - 2 + autoParachute], OLED_FONT_SMALL, OLED_WHITE);
		displayUpdate = FALSE; // Disable display update
	} else if(!screenSaverEnabled && !autoParachute && !combo_running(cboWeaponDisplay) && (stance == stanceWeapon)) {
		if(screenSaverCounter >= 2000) {
			screenSaverEnabled = TRUE; // Enable Screen Saver
			cls_oled(OLED_BLACK); // Clear screen
		} else if(!screenSaverCounter && displayUpdate) {
			displayHomeScreen(); // Display Home Screen
			displayUpdate = FALSE; // Disable display update
		}
		screenSaverCounter += get_rtime(); // Increase Screen Saver counter
	} else if(((screenSaverEnabled && !combo_running(cboWeaponDisplay) && !autoParachute) || (userData[vOptionWeaponDisplay] || (weaponDisplayCounter == 3500))) && (stance == stanceWeapon)) {
		// Check for Weapon Display, otherwise do nothing
		if((weaponDisplayCounter >= 7000) && (userData[vOptionWeaponDisplay] != displayAlways)) {
			weaponDisplayCounter = 0;
			cls_oled(OLED_BLACK);
		} else if((weaponDisplayCounter == 3500) || (userData[vOptionWeaponDisplay] == displayAlways)) {
			// Do not overlap combos as they both use the display
			if(!combo_running(cboToggleBurstFire) && !combo_running(cboToggleRapidFire)) {
				combo_run(cboWeaponDisplay);
			}
		}
		weaponDisplayCounter = iif(userData[vOptionWeaponDisplay] != displayAlways, weaponDisplayCounter + get_rtime(), 0);
	}
}

// Checks if Stance Tracker should dispatch an alert
function checkStanceAlert() {
	// Check for Stance Tracker alert
	if(userData[vOptionStanceTracker] == stanceTrackerOn) {
		if(stancePosition) {
			if(stanceCounter >= 2000) {
				combo_run(cboStanceAlert);
				stanceCounter = 0;
			} else {
				stanceCounter += get_rtime();
			}
		}
	}
}

// Check for changes within the player's stance
function checkStance() {
	if(!get_ival(XB1_RB) && !autoParachute && userData[vOptionStanceTracker]) {
		if(event_release(button[action])) {
			if(!inVehicle) {
				if(stance < stanceInventory) {
					if(get_ptime(button[action]) < 200) {
						combo_stop(cboAlertStance);
						stancePosition = iif(stancePosition == 2, 1, !stancePosition);
					} else {
						stancePosition = iif(stancePosition <= 1, 2, 0);
					}
					stanceCounter = 0;
				} else {
					if(stance & stanceInventory) {
						stance = (stance ^ stanceInventory);
						weaponDisplayCounter = 3500;
						displayUpdate = TRUE;
					} else if(stance & stanceMap) {
						stance = (stance ^ stanceMap);
						weaponDisplayCounter = 3500;
						displayUpdate = TRUE;
					}
				}
			} else {
				inVehicle = FALSE;
				displayUpdate = TRUE;
				weaponDisplayCounter = 3500;
			}
		} else if(event_press(button[jump])) {
			if(stancePosition) {
				stancePosition = 0;
			}
			stanceCounter = 0;
		} else if((event_release(XB1_VIEW) && (get_ptime(XB1_VIEW) < 360)) || (get_controller() == PIO_PS4 || get_controller() == PIO_PS5) && event_release(PS4_TOUCH) && (get_ptime(PS4_TOUCH) < 360)) {
			if(!(stance & stancePaused) && !leavingSpawnTool) {
				stance = (stance ^ stanceMap);
				weaponDisplayCounter = 3500;
				displayUpdate = TRUE;
			}
			if(stance & stanceInventory) {
				stance = (stance ^ stanceInventory);
			}
		}
		/*} else if((event_release(XB1_VIEW) && (get_ptime(XB1_VIEW) < 360)) || ((get_console() == PIO_PS4 || get_console() == PIO_PS5 || get_controller() == PIO_PS4 || get_controller() == PIO_PS5) && event_release(PS4_TOUCH) && (get_ptime(PS4_TOUCH) < 360))) {
			if(stanceInventory != 3) {
				stanceInventory = iif(!stanceInventory || stanceInventory == 1, 2, 0);
			}
		} else if(event_release(XB1_MENU)) {
			if(get_ptime(XB1_MENU) > 360) {
				stanceInventory = 3; // In menu (i.e. quit game, settings, etc.)
			} else {
				if(stanceInventory != 3) {
					stanceInventory = iif(!stanceInventory || stanceInventory == 2, 1, 0);
				}
			}
		} else if(event_release(XB1_B)) {
			if(stanceInventory) {
				stanceInventory = 0;
			}*/
	}
}

// Determines which color the LED on the Zen should be
function determineLEDColor() {
	// If Rapid Fire not enabled, Set LED color to notify user of current profile
	if((burstFire[currentProfile] || rapidFire[currentProfile])) {
		combo_run(cboAlertToggleEngaged); // If Burst/Rapid Fire enabled, enable alert
	} else {
		if(stance >= stanceInventory) {
			setLedColor(white);
		} else {
			if((stance == stanceNoWeapon) || (stance == stancePistol)) {
				setLedColor(yellow);
			} else if(stance == stanceWeapon) {
				if(inVehicle) {
					setLedColor(pink);
				} else {
					setProfileLedColor(currentProfile);
				}
			} else if(stance == stanceGrenade) {
				setLedColor(gold);
			}
			if(stancePosition) {
				combo_run(cboAlertStance);
			}
		}
	}
}

// Determines what to set the anti-drift value to, if a new value was found
function determineAntidriftValue() {
	if(antiDriftCalibrationStick == antiDriftLeftStick) {
		switch(antiDriftCalibrationDirection) {
			case antiDriftUp {
				antiDriftCalibrationValue = get_val(POLAR_LY);
				if((antiDriftCalibrationValue < userData[vAntiDriftLeft + antiDriftUp]) || (userData[vAntiDriftLeft + antiDriftUp] == 0)) {
					userData[vAntiDriftLeft + antiDriftUp] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftDown {
				antiDriftCalibrationValue = get_val(POLAR_LY);
				if((antiDriftCalibrationValue > userData[vAntiDriftLeft + antiDriftDown]) || (userData[vAntiDriftLeft + antiDriftDown] == 0)) {
					userData[vAntiDriftLeft + antiDriftDown] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftLeft {
				antiDriftCalibrationValue = get_val(POLAR_LX);
				if((antiDriftCalibrationValue < userData[vAntiDriftLeft + antiDriftLeft]) || (userData[vAntiDriftLeft + antiDriftLeft] == 0)) {
					userData[vAntiDriftLeft + antiDriftLeft] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftRight {
				antiDriftCalibrationValue = get_val(POLAR_LX);
				if((antiDriftCalibrationValue > userData[vAntiDriftLeft + antiDriftRight]) || (userData[vAntiDriftLeft + antiDriftRight] == 0)) {
					userData[vAntiDriftLeft + antiDriftRight] = antiDriftCalibrationValue;
				}
				break;
			}
		}
	} else {
		switch(antiDriftCalibrationDirection) {
			case antiDriftUp {
				antiDriftCalibrationValue = get_val(POLAR_RY);
				if((antiDriftCalibrationValue < userData[vAntiDriftRight + antiDriftUp]) || (userData[vAntiDriftRight + antiDriftUp] == 0)) {
					userData[vAntiDriftRight + antiDriftUp] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftDown {
				antiDriftCalibrationValue = get_val(POLAR_RY);
				if((antiDriftCalibrationValue > userData[vAntiDriftRight + antiDriftDown]) || (userData[vAntiDriftRight + antiDriftDown] == 0)) {
					userData[vAntiDriftRight + antiDriftDown] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftLeft {
				antiDriftCalibrationValue = get_val(POLAR_RX);
				if((antiDriftCalibrationValue < userData[vAntiDriftRight + antiDriftLeft]) || (userData[vAntiDriftRight + antiDriftLeft] == 0)) {
					userData[vAntiDriftRight + antiDriftLeft] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftRight {
				antiDriftCalibrationValue = get_val(POLAR_RX);
				if((antiDriftCalibrationValue > userData[vAntiDriftRight + antiDriftRight]) || (userData[vAntiDriftRight + antiDriftRight] == 0)) {
					userData[vAntiDriftRight + antiDriftRight] = antiDriftCalibrationValue;
				}
				break;
			}
		}
	}
}

// Handles a pressed toggle combination sequence
function dispatchToggle(id) {
	switch(id) {
		case toggleProfile {
			switchProfile(!currentProfile); // Switch profiles
			break;
		} case toggleAutoFocus {
			userData[vOptionAutoFocus + currentProfile] = !userData[vOptionAutoFocus + currentProfile];
			combo_stop(cboAutoFocus); // Stop incase it was running
			combo_stop(cboWeaponDisplay); // Stop weapon display
			combo_restart(cboToggleAutoFocus); // Run combo to alert user
			break;
		} case toggleAutoLean {
			userData[vOptionAutoLean + currentProfile] = !userData[vOptionAutoLean + currentProfile];
			combo_stop(cboWeaponDisplay); // Stop weapon display
			combo_restart(cboToggleAutoLean); // Run combo to alert user
			break;
		} case toggleAutoParachute {
			autoParachute = !autoParachute; // Change auto parachute state
			weaponDisplayCounter = 0; // Reset weapon display counter
			combo_stop(cboWeaponDisplay); // Stop weapon display
			combo_restart(cboToggleAutoParachute); // Run combo to alert user
			if(autoParachute) {
				// Set initial values
				autoParachuteStrength[0] = get_val(XB1_LX);
				autoParachuteStrength[1] = get_val(XB1_LY);
				displayUpdate = TRUE;
			}
			break;
		} case toggleAutoTurbo {
			if(vehicleMode) {
				autoTurbo = !autoTurbo; // Change auto turbo state
				weaponDisplayCounter = 0; // Reset weapon display counter
				combo_stop(cboWeaponDisplay); // Stop weapon display
				combo_restart(cboToggleAutoTurbo); // Run combo to alert user
				displayUpdate = TRUE;
			}
			break;
		} case toggleBurstFire {
			if(!isAutomatic(currentWeapon[currentProfile]) && !rapidFire[currentProfile]) {
				burstFire[currentProfile] = !burstFire[currentProfile]; // Change burst fire state
				weaponDisplayCounter = 0; // Reset weapon display counter
				combo_stop(cboBurstFire); // Stop incase it was running
				combo_stop(cboWeaponDisplay); // Stop weapon display
				combo_restart(cboToggleBurstFire); // Run combo to alert user
			}
			break;
		} case toggleCrouchShot {
			userData[vOptionCrouchShot + currentProfile] = userData[vOptionCrouchShot + currentProfile] ^ userData[vToggleCrouchShot];
			combo_stop(cboWeaponDisplay); // Stop weapon display
			combo_restart(cboToggleCrouchShot); // Run combo to alert user
			break;
		} case toggleRapidFire {
			if(canUseRapidFire(currentWeapon[currentProfile]) && !burstFire[currentProfile]) {
				rapidFire[currentProfile] = !rapidFire[currentProfile]; // Change rapid fire state
				weaponDisplayCounter = 0; // Reset weapon display counter
				combo_stop(cboRapidFire); // Stop incase it was running
				combo_stop(cboWeaponDisplay); // Stop weapon display
				combo_restart(cboToggleRapidFire); // Run combo to alert user
			}
			break;
		}
	}
	
	weaponDisplayCounter = 3500;
}

// Determines if the current weapon can use Rapid Fire
function canUseRapidFire(z) {
	return iif((z == mutant) || (z == m16a4), TRUE, FALSE);
}

// Displays stick values for the Anti-drift Test menu
function displayAntidriftTest(x, y, line) {
	// Build display
	insertCharacter(iif(x == POLAR_LX, ASCII_UPPER_L, ASCII_UPPER_R));
	insertCharacter(ASCII_COLON);
	insertCharacter(ASCII_SPACE);
	insertNumber(get_val(x));
	insertCharacter(ASCII_COMMA);
	insertNumber(get_val(y));
	flushBuffer(alignLeft, line, OLED_FONT_SMALL, OLED_WHITE);
}

// Displays the current anti-drift X/Y values for both sticks
function displayAntidriftValues() {
	// Draw a separator line down middle of OLED
	line_oled(OLED_WIDTH >> 1, lineNumber[0] - 4, OLED_WIDTH >> 1, OLED_HEIGHT - 2, 1, OLED_WHITE);
	// Draw each value
	for(j = 0; j < 4; j++) {
		// Left stick
		insertString(antiDriftValues[j]);
		insertNumber(userData[vAntiDriftLeft + j]);
		flushBuffer(alignLeft - 2, 21 + (j * 10), OLED_FONT_SMALL, OLED_WHITE);
		// Right stick
		insertString(antiDriftValues[j]);
		insertNumber(userData[vAntiDriftRight + j]);
		flushBuffer((OLED_WIDTH >> 1) + 3, 21 + (j * 10), OLED_FONT_SMALL, OLED_WHITE);
	}
}

// Draws a list of two items and highlights the selected item
function displayDualSelection(type, message1, message2, value1, value2) {
	
	// Draw selected item background
	rect_oled(alignLeft, lineNumber[editMenuSelectedRow] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
	
	// Generate first item
	buildSelectedItemBuffer(type, message1, value1);
	flushSelectedItemBuffer(0, lineNumber[0]);
	
	// Generate second item
	buildSelectedItemBuffer(type, message2, value2);
	flushSelectedItemBuffer(1, lineNumber[1]);
	
	if(editMenuIndex == editMenuToggleCrouchShot) {
		buildSelectedItemBuffer(type, toggle[0], crouchShot[userData[vToggleCrouchShot]]);
		flushSelectedItemBuffer(2, lineNumber[2]);
	}
}

// Display edit menu
function displayEditMenu() {

 	drawBorder(); // Clears the screen and draws a border
 	
 	// Alert for success
 	if(!get_lval(XB1_Y) && (editMenuIndex != editMenuAntidriftTest) && !antiDriftCalibrationState ) {
  		menuActionSuccess();
	}
	
	// Display header
	printText(alignCenter, alignTop, editMenuNames[editMenuIndex], OLED_FONT_SMALL, OLED_WHITE); 
	line_oled(1, OLED_FONT_SMALL_HEIGHT + 7, 127, OLED_FONT_SMALL_HEIGHT + 7, 1, OLED_WHITE);
	
	// Display footer (i.e. Profile name or "Both Profiles")
	if(modMenuIndex == modMenuOptions) {
		printText(alignCenter, alignBottom, profileName[iif(isGlobalOption(), 2, menuProfile)], OLED_FONT_SMALL, OLED_WHITE); // Display "Both Profiles"
		line_oled(1, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 127, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 1, OLED_WHITE); // Draw bottom line
	}
	
	if(modMenuIndex == modMenuToggles) {
		displayToggle(((editMenuIndex - editMenuToggleAutoFocus) << 1) + 2);
	} else {
		if(editMenuIndex >= editMenuAntiRecoil1x && editMenuIndex <= editMenuAntiRecoil8x) {
			if(!(userData[vAntiRecoil1x + editMenuIndex - editMenuAntiRecoil1x] % 10)) {
				printNumber(alignCenter, 28, userData[vAntiRecoil1x + editMenuIndex - editMenuAntiRecoil1x] / 10, OLED_FONT_MEDIUM, OLED_WHITE);
			} else {
				insertNumber(userData[vAntiRecoil1x + editMenuIndex - editMenuAntiRecoil1x] / 10);
				insertCharacter(ASCII_PERIOD);
				insertNumber(userData[vAntiRecoil1x + editMenuIndex - editMenuAntiRecoil1x] % 10);
				flushBuffer(alignCenter, 28, OLED_FONT_MEDIUM, OLED_WHITE);
			}
		} else {
			// See what setting we must display
			switch (editMenuIndex) {
				case editMenuAntidrift { // (Anti-drift) Toggle On/Off
					printText(alignCenter, alignCenter, toggleOffOn[userData[vAntiDrift]], OLED_FONT_SMALL, OLED_WHITE);
					break;
				} case editMenuAntidriftCalibration { // (Anti-drift) Calibration
					if(antiDriftCalibrationState) {
						// Calibration mode running
						printText(alignCenter, alignCenter, antiDriftCalibrationStateMsg[antiDriftCalibrationState], OLED_FONT_SMALL, OLED_WHITE);
					} else {
						// Calibration mode not running
						printText(alignCenter, lineNumber[0], antiDriftCalibrationStickPrompt[antiDriftCalibrationStick], OLED_FONT_SMALL, OLED_WHITE);
						printText(alignCenter, lineNumber[1], antiDriftCalibrationDirectionPrompt[antiDriftCalibrationDirection], OLED_FONT_SMALL, OLED_WHITE);
						rect_oled(alignLeft - 2, lineNumber[2], OLED_WIDTH - 6, OLED_FONT_SMALL_HEIGHT + 4, 1, OLED_WHITE);
						printText(alignCenter, lineNumber[2] + 3, antiDriftCalibrationStateMsg[antiDriftCalibrationState], OLED_FONT_SMALL, OLED_BLACK);
					}
					break;
				} case editMenuAntidriftTest { // (Anti-drift) Drift Test
					displayAntidriftTest(POLAR_LX, POLAR_LY, lineNumber[0]);
					displayAntidriftTest(POLAR_RX, POLAR_RY, lineNumber[1]);
					break;
				} case editMenuAntidriftValues { // (Anti-drift) Drift Values
					displayAntidriftValues();
					break;
				} case editMenuControllerButtonLayout { // (Controller) Button Layout
					printText(alignCenter, alignCenter, buttonLayoutName[userData[vControllerButtonLayout] ], OLED_FONT_SMALL, OLED_WHITE);
					break;
				} case editMenuControllerBumperTriggers { // (Controller) Bumper/Triggers
					printText(alignCenter, alignCenter, bumperTriggers[userData[vControllerBumperTriggers] ], OLED_FONT_SMALL, OLED_WHITE);
					break;
				} case editMenuAimAcceleration { // (Controller) Response Curve
					displayDualSelection(displayNumber, aimAcceleration[0], aimAcceleration[1], userData[vAimAcceleration + aimAccelReduction], userData[vAimAcceleration + aimAccelThreshold]);
					break;
				} case editMenuSmoothing { // (Controller) Smoothing
					printText(alignCenter, alignCenter, smoothing[userData[vSmoothing] ], OLED_FONT_SMALL, OLED_WHITE);
					break;
				} case editMenuAutoFocus { // (Options) Auto Focus
					printText(alignCenter, alignCenter, toggleOffOn[userData[vOptionAutoFocus + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
					break;
				} case editMenuAutoLean { // (Options) Auto Lean
					printText(alignCenter, alignCenter, toggleOffOn[userData[vOptionAutoLean + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
					break;
				} case editMenuCrouchShot { // (Options) Crouch Shot
					printText(alignCenter, alignCenter, crouchShot[userData[vOptionCrouchShot + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
					break;
				} case editMenuFastLean { // (Options) Fast Lean
					printText(alignCenter, alignCenter, toggleOffOn[userData[vOptionFastLean] ], OLED_FONT_SMALL, OLED_WHITE);
					break;
				} case editMenuStanceTracker { // (Options) Stance Tracker
					printText(alignCenter, alignCenter, stanceTracker[userData[vOptionStanceTracker] ], OLED_FONT_SMALL, OLED_WHITE);
					break;
				} case editMenuProfileSwitch { // (Profiles) Profile Switch
					displayDualSelection(displayString, profileToggleMsg[0], profileToggleMsg[1], iif((get_controller() == PIO_PS4) || (get_controller() == PIO_PS5), controllerButtonsPS4[userData[vToggleButton + toggleProfile]], controllerButtonsXBOX[userData[vToggleButton + toggleProfile]]), iif((get_controller() == PIO_PS4) || (get_controller() == PIO_PS5), controllerButtonsPS4[userData[vToggleButton + toggleProfile + 1]], controllerButtonsXBOX[userData[vToggleButton + toggleProfile + 1]]));
					break;
				} case editMenuProfileColors { // (Profiles) Profile colors
					displayDualSelection(displayString, profileToggleMsg[4], profileToggleMsg[5], colorName[userData[vProfileColor]], colorName[userData[vProfileColor + 1]]);
					break;
				} case editMenuBlockRumble { // (Settings) Block Rumble
					printText(alignCenter, alignCenter, toggleOffOn[userData[vBlockRumble]], OLED_FONT_SMALL, OLED_WHITE);
					break;
				} case editMenuDeadzone { // (Settings) Deadzone
					displayDualSelection(displayNumber, stickName[deadzoneLeft], stickName[deadzoneRight], userData[vDeadzone + deadzoneLeft], userData[vDeadzone + deadzoneRight]);
					break;
				} case editMenuDefaultWeapons { // (Settings) Default Weapons
					displayDualSelection(displayString, defaultWeapons[0], defaultWeapons[1], weaponName[userData[vDefaultWeapon]], weaponName[userData[vDefaultWeapon + 1]]);
					break;
				} case editMenuInverted { // (Settings) Inverted
					printText(alignCenter, alignCenter, toggleOffOn[userData[vInverted]], OLED_FONT_SMALL, OLED_WHITE);
					break;
				} case editMenuKeyboardSwitch { // (Settings) Keyboard Switch
					printText(alignCenter, alignCenter, toggleOffOn[userData[vKeyboardSwitch]], OLED_FONT_SMALL, OLED_WHITE):
					break;
				} case editMenuWeaponDisplay { // (Settings) Weapon Display
					printText(alignCenter, alignCenter, weaponDisplay[userData[vOptionWeaponDisplay]], OLED_FONT_SMALL, OLED_WHITE);
					break;
				}
			}
		}
	}
	
	displayUpdate = FALSE; // Disable display update
 }
 

// Display home screen
function displayHomeScreen() {

 	drawBorder(); // Clears the screen and draws a border
 	
	// Show home screen
	printText(alignCenter, 10, homeScreenMessages[homeScriptName], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, 26, homeScreenMessages[homeScriptVersion], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, 42, homeScreenMessages[homeScriptAuthor], OLED_FONT_SMALL, OLED_WHITE);
 }
 
 // Display mod menu
 function displayModMenu() {
 
 	drawBorder(); // Clears the screen and draws a border
  	menuActionSuccess(); // Alert for successful action
	
 	// Display the mod menu
	printText(alignCenter, alignTop, modMenuNames[modMenuItems[modMenuIndex][modMenuPrevious]], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, alignCenter, modMenuNames[modMenuItems[modMenuIndex][modMenuCurrent]], OLED_FONT_MEDIUM, OLED_WHITE);
	printText(alignCenter, alignBottom, modMenuNames[modMenuItems[modMenuIndex][modMenuNext]], OLED_FONT_SMALL, OLED_WHITE);
	
 	displayUpdate = FALSE; // Disable update
 }

// Generates the display for editing toggles
function displayToggle(id) {
	if((get_controller() == PIO_PS4) || (get_controller() == PIO_PS5)) {
		displayDualSelection(displayString, profileToggleMsg[2], profileToggleMsg[3], controllerButtonsPS4[userData[vToggleButton + id]], controllerButtonsPS4[userData[vToggleButton + id + 1]]);
	} else {
		displayDualSelection(displayString, profileToggleMsg[2], profileToggleMsg[3], controllerButtonsXBOX[userData[vToggleButton + id]], controllerButtonsXBOX[userData[vToggleButton + id + 1]]);
	}
}

function checkForegripSwap() {
	if(currentCategory[currentProfile] != lastCategory) {
		antiRecoilForegrip[currentProfile] = Foregrip_None;
	} else if(canUseForegrip(currentWeapon[currentProfile]) != canUseForegrip(lastWeapon)) {
		if(canUseForegrip(currentWeapon[currentProfile]) == Foregrip_Vertical && lastForegrip != Foregrip_Vertical) {
			antiRecoilForegrip[currentProfile] = Foregrip_None;
		} else if(canUseForegrip(currentWeapon[currentProfile]) == Foregrip_Lightweight) {
			if(antiRecoilForegrip[currentProfile] == Foregrip_Angled || antiRecoilForegrip[currentProfile] == Foregrip_Thumb) {
				antiRecoilForegrip[currentProfile] = Foregrip_None;
			}
		} else if(!((canUseForegrip(lastWeapon) == Foregrip_Vertical) && (canUseForegrip(currentWeapon[currentProfile]))) && !((canUseForegrip(lastWeapon) == Foregrip_Lightweight) && canUseForegrip(currentWeapon[currentProfile]))) {
			antiRecoilForegrip[currentProfile] = Foregrip_None;
		}
	}
}

function checkMuzzleSwap() {
	if(currentCategory[currentProfile] != lastCategory) {
		antiRecoilMuzzle[currentProfile] = Muzzle_None;
	} else if(canUseMuzzle(currentWeapon[currentProfile]) != canUseMuzzle(lastWeapon)) {
		if(canUseMuzzle(currentWeapon[currentProfile]) == Muzzle_Suppressor && lastMuzzle != Muzzle_Suppressor) {
			antiRecoilMuzzle[currentProfile] = Muzzle_None;
		}
	}
}

function checkStockSwap() {
	if(currentCategory[currentProfile] != lastCategory) {
		antiRecoilStock[currentProfile] = Stock_None;
	} else if(canUseStock(currentWeapon[currentProfile]) != canUseStock(lastWeapon)) {
		antiRecoilStock[currentProfile] = Stock_None;	
	}
}

// Checks and handles any controller actions within the Weapon Select menu
function checkWeaponSelectEvent() {
	
	displayUpdate = TRUE; // Enable display update
	checkDisplayUpdate(); // See if edit menu needs to update to the display
	
	if(event_release(XB1_B)) {
	
		displayDepth = 0; // Return to home screen
		combo_run(cboWeaponDisplay); // Display current weapon
		
		if(currentWeapon[menuProfile] == p90) {
			antiRecoilScope[menuProfile] = 0; // Reset scope as P90 defaults on Low Zoom
		} else {
			if(lastWeapon == p90) {
				antiRecoilScope[menuProfile] = 0; // If last weapon is P90, reset scope to 1x
			} else if(!canUseScope(menuProfile)) {
				antiRecoilScope[menuProfile] = 0; // If current weapon cannot use scope, reset scope to 1x
			} else if((lastScope == 5) && !canUse8x(menuProfile)) {
				antiRecoilScope[menuProfile] = 0; // If 8x was set and weapon switched, reset scope to 1x
			}
		}
		
		checkForegripSwap();
		checkMuzzleSwap();
		checkStockSwap();
		
		// Check for Burst Fire, don't allow it to transfer to automatic weapon
		if(burstFire[menuProfile] && isAutomatic(currentWeapon[menuProfile])) {
			burstFire[menuProfile] = FALSE;
		}
		// Check for Rapid Fire, don't allow it to transfer to a weapon that cannot use it
		if(rapidFire[menuProfile] && !canUseRapidFire(currentWeapon[menuProfile])) {
			rapidFire[menuProfile] = FALSE;
		}
	} else if(event_press(XB1_UP)) {
		currentCategory[menuProfile] = cycleListOption(currentCategory[menuProfile], cycleValueUp, SNIPER_SHOTGUN, AR);
		currentWeapon[menuProfile] = weaponSelectCategoryMenu[currentCategory[menuProfile]][0];
	} else if(event_press(XB1_DOWN)) {
		currentCategory[menuProfile] = cycleListOption(currentCategory[menuProfile], cycleValueDown, AR, SNIPER_SHOTGUN);
		currentWeapon[menuProfile] = weaponSelectCategoryMenu[currentCategory[menuProfile]][0];
	} else if(event_press(XB1_LEFT)) {
		currentWeapon[menuProfile] = cycleListOption(currentWeapon[menuProfile], cycleValueDown, weaponSelectCategoryMenu[currentCategory[menuProfile]][0], weaponSelectCategoryMenu[currentCategory[menuProfile]][1]);
	} else if(event_press(XB1_RIGHT)) {
		currentWeapon[menuProfile] = cycleListOption(currentWeapon[menuProfile], cycleValueUp, weaponSelectCategoryMenu[currentCategory[menuProfile]][1], weaponSelectCategoryMenu[currentCategory[menuProfile]][0]);
	} else if(event_press(XB1_Y)) {
		switchProfile(!currentProfile);
	}
}

// Generates the weapon select menu
function displayWeaponSelect() {

	drawBorder(); // Clears the screen and draws a border
	
	line_oled(1, OLED_FONT_SMALL_HEIGHT + 7, 127, OLED_FONT_SMALL_HEIGHT + 7, 1, OLED_WHITE);
	line_oled(1, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 127, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 1, OLED_WHITE);
	printText(alignCenter, alignTop, weaponSelectDisplay[2], OLED_FONT_SMALL, OLED_WHITE); 
	printText(alignCenter, alignBottom, weaponSelectDisplay[menuProfile], OLED_FONT_SMALL, OLED_WHITE);
	
	if(currentWeapon[menuProfile] != sniper_shotgun) {
		insertString(weaponSelectCategory[currentCategory[menuProfile]]);
		flushBuffer(alignCenter, lineNumber[0], OLED_FONT_SMALL, OLED_WHITE);
		insertString(weaponName[currentWeapon[menuProfile]]);
		flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
	} else {
		insertString(weaponSelectCategory[currentCategory[menuProfile]]);
		flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	}

	displayUpdate = FALSE; // Disable any update
}

// Clears the screen and draws a border around the OLED
function drawBorder() {
	cls_oled(OLED_BLACK); // Clear screen
	rect_oled(0, 0, 128, 63, 0, OLED_WHITE); // Draw border around OLED
}

int antiRecoilPerformSpamAdjust;

// Execute anti-recoil
function executeAntiRecoil() {

	// Check for number of vertical steps
	if(!antiRecoilMaxY) {
		antiRecoilIndexY = 2;
		antiRecoilDurationY = 0;
		antiRecoilMaxY = weaponData[weaponIndex[currentWeapon[currentProfile]]][1];
		antiRecoilCrouch = weaponData[weaponIndex[currentWeapon[currentProfile]] + 1][0];
		antiRecoilProne = weaponData[weaponIndex[currentWeapon[currentProfile]] + 1][1];
	}
	
	// antiRecoilMaxY will be 0 if weapon is single fire (i.e. DMR)
	if(antiRecoilMaxY) {
		if(antiRecoilDurationY <= weaponData[weaponIndex[currentWeapon[currentProfile]] + antiRecoilIndexY][1]) {
			antiRecoilY = weaponData[weaponIndex[currentWeapon[currentProfile]] + antiRecoilIndexY][0];
			antiRecoilY = adjustAntiRecoil(antiRecoilY);
			antiRecoilDurationY += get_rtime(); // Increase kick duration counter
		} else {
			if(antiRecoilIndexY <= antiRecoilMaxY) {
				antiRecoilDurationY = 0;
				antiRecoilIndexY++;
				antiRecoilY = weaponData[weaponIndex[currentWeapon[currentProfile]] + antiRecoilIndexY][0];
				antiRecoilY = adjustAntiRecoil(antiRecoilY);
			} else {
				antiRecoilY = 0;
			}
		}
			
		if(antiRecoilY) {
			if((userData[vControllerButtonLayout] > cblTypeA) && !get_ival(button[ads])) {
				if(userData[vControllerButtonLayout] == cblTypeB && get_ival(button[focus])) {
					antiRecoilY = antiRecoilY - (antiRecoilY - ((antiRecoilY * 80) / 100));
				} else {
					antiRecoilY = antiRecoilY - (antiRecoilY - ((antiRecoilY * 50) / 100));
				}
			}
			// Determine stance and anti-recoil adjustment
			if(!stancePosition) {
				output(aimY, antiRecoilY * iif(userData[vInverted], -1, 1));
			} else {
				output(aimY, (antiRecoilY - iif(stancePosition == 1, antiRecoilCrouch, antiRecoilProne)) * iif(userData[vInverted], -1, 1));
			}
		}
	} else {
		// Get anti-recoil value based on scope
		antiRecoilY = weaponData[weaponIndex[currentWeapon[currentProfile]] + 2][0];
		// Check for "spam" or "burst fire"
		if((get_brtime(button[fire]) < 180) && !rapidFire[currentProfile]) {
			// Perform DMR specific spam adjustment
			if(currentCategory[currentProfile] == DMR) {
				if((currentWeapon[currentProfile] == slr) && (antiRecoilFireCount > 1) && (antiRecoilCounter >= 90)) {
					antiRecoilAttachmentSpamAdjust += iif(antiRecoilMuzzle[currentProfile], muzzlePercentage_DMR[antiRecoilMuzzle[currentProfile]] - 6, 0);
					antiRecoilPerformSpamAdjust = TRUE;
				} else if((currentWeapon[currentProfile] == mini14) && (antiRecoilFireCount > 2) && (antiRecoilCounter >= 110)) {
					antiRecoilAttachmentSpamAdjust += iif(antiRecoilMuzzle[currentProfile], muzzlePercentage_DMR[antiRecoilMuzzle[currentProfile]], 10) + 2;
					antiRecoilPerformSpamAdjust = TRUE;
				} else if((currentWeapon[currentProfile] == sks) && (antiRecoilFireCount > 1) && (antiRecoilCounter >= 200)) {
					antiRecoilAttachmentSpamAdjust += iif(antiRecoilMuzzle[currentProfile], muzzlePercentage_DMR[antiRecoilMuzzle[currentProfile]], 0);
					antiRecoilPerformSpamAdjust = TRUE;
				} else if((currentWeapon[currentProfile] == qbu) && (antiRecoilFireCount > 2) && (antiRecoilCounter >= 110)) {
					antiRecoilAttachmentSpamAdjust += iif(antiRecoilMuzzle[currentProfile], muzzlePercentage_DMR[antiRecoilMuzzle[currentProfile]] + 5, 15);
					antiRecoilPerformSpamAdjust = TRUE;
				} else if((currentWeapon[currentProfile] == mk14_semi) && (antiRecoilFireCount > 1) && (antiRecoilCounter >= 90)) {
					antiRecoilAttachmentSpamAdjust += iif(antiRecoilMuzzle[currentProfile], muzzlePercentage_DMR[antiRecoilMuzzle[currentProfile]] - 6, 0);
					antiRecoilPerformSpamAdjust = TRUE;
				} else if((currentWeapon[currentProfile] == mk12) && (antiRecoilFireCount > 2) && (antiRecoilCounter >= 80)) {
					antiRecoilAttachmentSpamAdjust += iif(antiRecoilMuzzle[currentProfile], muzzlePercentage_DMR[antiRecoilMuzzle[currentProfile]], 6);
					antiRecoilPerformSpamAdjust = TRUE;
				}
			} else if(currentCategory[currentProfile] == AR) {
				if ((antiRecoilFireCount > 1) && (antiRecoilCounter >= 80)) {
					if(antiRecoilMuzzle[currentProfile] != Muzzle_None) {
						antiRecoilAttachmentSpamAdjust = muzzlePercentage_AR[antiRecoilMuzzle[currentProfile]];
					}
					antiRecoilPerformSpamAdjust = TRUE;
				}
			}
			
			if(antiRecoilPerformSpamAdjust) {
				// Calculate "spam" or "burst fire" compensation
				if(currentCategory[currentProfile] == AR) {
					// Scope adjustment
					if(currentWeapon[currentProfile] != mutant) {
						if(antiRecoilScope[currentProfile] == 3) {
							antiRecoilAttachmentSpamAdjust -= 10;
						}
					} else {
						//if(antiRecoilMuzzle[currentProfile] == Muzzle_None) {
							antiRecoilAttachmentSpamAdjust += 15;
						//}
						//if(antiRecoilForegrip[currentProfile]) {
						//	antiRecoilAttachmentSpamAdjust -= (foregripPercentage_AR[antiRecoilForegrip[currentProfile]] >> 1);
						//}
					}
					// Calculate adjustment for AR attachments
					antiRecoilAttachmentSpamAdjust += muzzlePercentage_AR[antiRecoilMuzzle[currentProfile]] + foregripPercentage_AR[antiRecoilForegrip[currentProfile]];
					// Calculate adjustment specifically
					antiRecoilAttachmentSpamAdjust += stockPercentage[antiRecoilStock[currentProfile]];
					// Calculate overall percentage adjustment
					antiRecoilSpamAdjust = antiRecoilY - (antiRecoilY - (antiRecoilY * (30 + antiRecoilAttachmentSpamAdjust) / 100));
				} else {
					// Calculate DMR foregrip spam adjustment
					if(canUseForegrip(currentWeapon[currentProfile])) {
						if(currentWeapon[currentProfile] != sks) {
							antiRecoilAttachmentSpamAdjust += iif(antiRecoilForegrip[currentProfile], foregripPercentage_AR[antiRecoilForegrip[currentProfile]], 4);
						} else {
							// Perform SKS-specific spam adjustment based on foregrip w/o stock
							antiRecoilAttachmentSpamAdjust += iif(antiRecoilForegrip[currentProfile], foregripPercentage_AR[antiRecoilForegrip[currentProfile]], 0);
							if(antiRecoilForegrip[currentProfile] && !antiRecoilStock[currentProfile]) {
								switch(antiRecoilForegrip[currentProfile]) {
									case Foregrip_Vertical {
										antiRecoilAttachmentSpamAdjust -= 5;
										break;
									} case Foregrip_Half {
										antiRecoilAttachmentSpamAdjust -= 10;
										break;
									} case Foregrip_Thumb {
										antiRecoilAttachmentSpamAdjust -= 5;
										break;
									} case Foregrip_Lightweight {
										if(antiRecoilMuzzle[currentProfile] == Muzzle_None || antiRecoilMuzzle[currentProfile] == Muzzle_Suppressor) {
											antiRecoilAttachmentSpamAdjust -= 5;
										} else {
											antiRecoilAttachmentSpamAdjust -= 15;
											if(antiRecoilStock[currentProfile]) {
												antiRecoilAttachmentSpamAdjust -= 5;
											}
										}
										break;
									}
								}
							}
						}
					}

					// Calculate adjustment specifically for SKS stock difference
					if(currentWeapon[currentProfile] == sks && antiRecoilStock[currentProfile]) {
						antiRecoilAttachmentSpamAdjust += -3; // Cheek Pad is "weaker" on SKS
					} else if(antiRecoilStock[currentProfile]) {
						if(currentWeapon[currentProfile] == mk14_semi) {
							if(antiRecoilMuzzle[currentProfile]) {
								antiRecoilAttachmentSpamAdjust -= 10;
							} else {
								antiRecoilAttachmentSpamAdjust -= 15;
							}
						} else {
							antiRecoilAttachmentSpamAdjust += stockPercentage[antiRecoilStock[currentProfile]];
						}
					}
					// Calculate overall percentage adjustment
					if(getCurrentSensitivity() > 100) {
						if(!antiRecoilScope[currentProfile]) {
							antiRecoilHighSensAdjust = ((getCurrentSensitivity() / 10) << 1) + (((getCurrentSensitivity() / 10) << 1) >> 1);
						} else if(antiRecoilScope[currentProfile] == 1) {
							antiRecoilHighSensAdjust = ((getCurrentSensitivity() / 10) << 1);
						} else {
							antiRecoilHighSensAdjust = (getCurrentSensitivity() / 10) << 1;
						}
						antiRecoilSpamAdjust = antiRecoilY - (antiRecoilY - (antiRecoilY * (75 + antiRecoilAttachmentSpamAdjust - antiRecoilHighSensAdjust) / 100));
					} else {
						antiRecoilSpamAdjust = antiRecoilY - (antiRecoilY - (antiRecoilY * (75 + antiRecoilAttachmentSpamAdjust) / 100));
					}
				}
				
				antiRecoilAttachmentSpamAdjust = 0; // Reset attachment spam adjust for next iteration
				antiRecoilY += antiRecoilSpamAdjust; // Apply "spam" or "burst fire" compensation
				antiRecoilPerformSpamAdjust = 0; // Reset DMR Spam Adjust
			}
		}
		
		if(combo_running(cboRapidFire)) {
			antiRecoilAttachmentSpamAdjust = antiRecoilY - (antiRecoilY - (antiRecoilY * getRapidFireBoost() / 100));
			antiRecoilY += antiRecoilAttachmentSpamAdjust;
		}
		
		if((userData[vControllerButtonLayout] > cblTypeA) && !get_ival(button[ads])) {
			if((userData[vControllerButtonLayout] == cblTypeB) && get_ival(button[focus])) {
				antiRecoilY = antiRecoilY - (antiRecoilY - ((antiRecoilY * 80) / 100));
			} else {
				antiRecoilY = antiRecoilY - (antiRecoilY - ((antiRecoilY * 50) / 100));
			}
		}
		
		combo_restart(cboSingleFire);
		
	}
}

// This function returns the rapid fire boost that must be applied
function getRapidFireBoost() {
	switch(currentWeapon[currentProfile]) {
		case mutant { return 65; }
		case m16a4 { return 50; }
	}
	
	return 1;
}

// This function returns the maximum rapid fire speed for a weapon
function getRapidFireSpeed() {
	switch(currentWeapon[currentProfile]) {
		case mutant { return 13; }
		case m16a4 { return 13; }
	}
	
	return 1;
}

// Applies Exponential Smoothing to smoothen out rapid stick movement
function exponentialSmoothing(current_value, previous_forecast) {
  return (((current_value << 1) + 8 * previous_forecast) + 5) / 10;
}

// Flushes the display buffer
function flushBuffer(x, y, size, color) {
	// Decrement value as it must begin at 1
	displayBuffer--; 
	
	// Check horizontal alignment
	switch(x) { 
		case alignRight {
			x = OLED_WIDTH - (displayBuffer * fontWidth[size]) - 4;
			break;	
		} case alignCenter {
			x = (OLED_WIDTH >> 1) - ((displayBuffer * fontWidth[size]) >> 1);
			break;
		}
	}
	
	// Check vertical alignment
	switch(y) { 
		case alignCenter {
			y = (OLED_HEIGHT >> 1) - (fontHeight[size] >> 1);
			break;
		} case alignBottom {
			y = OLED_HEIGHT - fontHeight[size] - 4;
			break;	
		}
	}
	
	puts_oled(x, y, size, displayBuffer, color); // Output display buffer
	displayBuffer = 1; // Reset display buffer
}

// Flushes the display buffer for a multiple item menu
function flushSelectedItemBuffer(item, line) {
	if(editMenuSelectedRow == item) {
		flushBuffer(alignLeft, line, OLED_FONT_SMALL, OLED_BLACK);
	} else {
		flushBuffer(alignLeft, line, OLED_FONT_SMALL, OLED_WHITE);
	}
}
 
// Checks if a weapon is fully automatic
function isAutomatic(index) {
	return iif((index != m16a4) && (index != mutant) && (index < slr) || (index == vss) /*|| (index == mk14_auto)*/, TRUE, FALSE);
}

// Alternative for the ternary operator
function iif(expression, truepart, falsepart) {
	// Evaluate if expression is true
	if(expression) {
		return truepart; // Return truepart
	}
	
	// Return falsepart
	return falsepart;
}

// Inserts a character into the display buffer
function insertCharacter(int value) {
	putc_oled(displayBuffer, value);
	displayBuffer++;
}

// Inserts a number into the display buffer
function insertNumber(int value) {
	
	if(value < 0) { // Check if value is negative
		insertCharacter(ASCII_MINUS); // Insert '-' into the display buffer
		value = abs(value); // Convert value to positive
	}
	
	displayBufferInsertCopyValue = value; // Create a copy of value to perform work on
	displayBufferInsertNumberOfDigits = 0; // Reset number of digits to 0
	
    // Determine the number of digits in the number by
    // dividing it by 10 repeatedly until it becomes 0
    // while not ignoring a value of 0
    do {
        displayBufferInsertCopyValue /= 10;
        displayBufferInsertNumberOfDigits++;
    } while(displayBufferInsertCopyValue)
    
    // Extract each digit of the number and store it in an array
    for(i = 0; i < displayBufferInsertNumberOfDigits; i++) {
        displayBufferInsertDigits[i] = (value % 10) + 48;
        value /= 10;
    }
    
    // Insert the digits in the order that they appear in the number
    for(i = displayBufferInsertNumberOfDigits - 1; i >= 0; i--) {
        insertCharacter(displayBufferInsertDigits[i]);
    }
}

// Inserts a string into the display buffer
function insertString(s) {
	// Loop through each character of the string
    do {
    	insertCharacter(duint8(s)); // Insert character into display buffer
    	s++; // Move to next character
    } while(duint8(s)) // Loop until no more characters
}

// Determine if the option is a profile-specific setting or not
function isGlobalOption() {
	
	// Auto Focus, Auto Lean & Crouch Shot
	if((editMenuIndex == editMenuAutoFocus)
		|| (editMenuIndex == editMenuAutoLean)
		|| (editMenuIndex == editMenuCrouchShot)) {
		return FALSE;
	}
	
	return TRUE;
}

// Edit menu action not allowed
function menuActionFailed() {
	// Make sure it is not running, if so, terminate it
	if(combo_running(cboActionFailed)) { 
		combo_stop(cboActionFailed);
	}
	
	displayUpdate = FALSE;
	combo_run(cboActionFailed); // Execute alert
}

// Menu action allowed
function menuActionSuccess() {
	// Make sure it is not running, if so, terminate it
	if(combo_running(cboActionSuccess)) { 
		combo_stop(cboActionSuccess);
	}
	
	combo_run(cboActionSuccess); // Execute alert
}

// Output value to stick and gradually reduce it as it approaches maximum movement
function output(stick, value) {
	if(value) {
		set_val(stick, clamp(value * (32767 - abs(get_val(stick))) / 32767 + get_val(stick), -32768, 32767));
	} else {
		set_val(stick, clamp(value * (-32768 + abs(get_val(stick))) / -32768 + get_val(stick), -32768, 32767));
	}
}

// Prints a number to the screen
function printNumber(x, y, number, size, color) {
	insertNumber(number);
	flushBuffer(x, y, size, color);
}

// Prints text to the screen
function printText(x, y, text, size, color) {
	insertString(text);
	flushBuffer(x, y, size, color);
}

// Removes any "movement" inside calibrated drift area and applies a deadzone
function removeDriftAndApplyDeadzone() {
	// If anti-drift is not enabled, we use 0 for low/high values.  Deadzone doesn't matter
	if(userData[vAntiDrift]) {
		correctStickInput(userData[vAntiDriftLeft + antiDriftLeft], userData[vAntiDriftLeft + antiDriftRight], userData[vDeadzone + deadzoneLeft], moveX);
		correctStickInput(userData[vAntiDriftLeft + antiDriftUp], userData[vAntiDriftLeft + antiDriftDown], userData[vDeadzone + deadzoneLeft], moveY);
		correctStickInput(userData[vAntiDriftRight + antiDriftLeft], userData[vAntiDriftRight + antiDriftRight], userData[vDeadzone + deadzoneRight], aimX);
		correctStickInput(userData[vAntiDriftRight + antiDriftUp], userData[vAntiDriftRight + antiDriftDown], userData[vDeadzone + deadzoneRight], aimY);
	} else {
		// This is done because it's possible user has values saved
		// but for whatever reason wants anti-drift off
		// Deadzone doesn't matter, if user doesn't want to use script deadzone
		// they can leave it at 0
		correctStickInput(0, 0, userData[vDeadzone + deadzoneLeft], moveX);
		correctStickInput(0, 0, userData[vDeadzone + deadzoneLeft], moveY);
		correctStickInput(0, 0, userData[vDeadzone + deadzoneRight], aimX);
		correctStickInput(0, 0, userData[vDeadzone + deadzoneRight], aimY);
	}
}

// Reset Stance Tracker state and alert user (if required)
function resetStance(alert) {
	stanceCounter = 0; // Reset stance counter
	weaponDisplayCounter = 3500;
	displayUpdate = TRUE;
	
	if(alert) {
		combo_run(cboStanceReset);
	}
}

// Sets button variables based on in-game settings
function setButtonLayout() {
	button[aim] = buttonLayoutMap[userData[vControllerButtonLayout] ][aim];
	button[ads] = buttonLayoutMap[userData[vControllerButtonLayout] ][ads];
	button[melee] = buttonLayoutMap[userData[vControllerButtonLayout] ][melee];
	button[fire] = buttonLayoutMap[userData[vControllerButtonLayout] ][fire];
	button[weapon] = buttonLayoutMap[userData[vControllerButtonLayout] ][weapon];
	button[interact] = buttonLayoutMap[userData[vControllerButtonLayout] ][interact];
	button[action] = buttonLayoutMap[userData[vControllerButtonLayout] ][action];
	button[jump] = buttonLayoutMap[userData[vControllerButtonLayout] ][jump];
	button[leanL] = buttonLayoutMap[userData[vControllerButtonLayout] ][leanL];
	button[leanR] = buttonLayoutMap[userData[vControllerButtonLayout] ][leanR];
	button[focus] = buttonLayoutMap[userData[vControllerButtonLayout] ][focus];
	button[zoom] = buttonLayoutMap[userData[vControllerButtonLayout] ][zoom];
}

// Attempts to bind button_to_set to a toggle combination
function setToggleButton(button_to_use, button_to_set, button_to_compare) {
	
	// Holding 'View' button will undo a previously set toggle combination button
	if(button_to_set == XB1_VIEW) {
		// Check if a buttin is set
		if(button_to_use) {
			button_to_use = 0; // Reset value
			displayUpdate = TRUE; // Enable display update
		}
	} else if(button_to_set != button_to_use) { // Check if value to set is different than current stored value for toggle
		if(button_to_set == button_to_compare) { // Make sure toggle combination [hold] button #1 does not equal [press] button #2
			combo_run(cboActionFailed); // Cannot map same buttons
		} else {
			button_to_use = button_to_set; // Set toggle button
		}
	}
	
	return button_to_use;
}

// Set controller configuration
function setControllerConfig() {
	setButtonLayout();
	setStickLayout();
}

// Sets the LED to the color provided as the parameter
function setLedColor(color) {
	set_hsb(colorValues[color][hue], colorValues[color][saturation], colorValues[color][brightness]);
}

// Sets the LED to a color based on the profile being used
function setProfileLedColor(profile) {
	if(!checkCombos()) { // Do not overlap with running combos that use the LEDs
		set_hsb(colorValues[userData[vProfileColor + profile]][hue], colorValues[userData[vProfileColor + profile]][saturation], colorValues[userData[vProfileColor + profile]][brightness]);
	}
}

// Sets joystick-related variables
function setStickLayout() {
	// Set movement and aiming sticks
	aimX = POLAR_RX;
	aimY = POLAR_RY;
	moveX = POLAR_LX;
	moveY = POLAR_LY;
}

// Stop combos that may take up the OLED
function stopCombos() {
	combo_stop(cboToggleBurstFire); // Stop Burst Fire incase it is running taking up the OLED
	combo_stop(cboToggleRapidFire); // Stop Rapid Fire incase it is running taking up the OLED
	combo_stop(cboSwitchProfile); // Just incase it was using OLED
	reset_rumble();
}

// Fix PS4 controller issue (from TD21) [edited]
function swapPS4() {
	if((get_console() == PIO_PS4) || (get_console() == PIO_PS5)) {
	    if((get_controller() != PIO_PS4) && (get_controller() != PIO_PS5)) {
	        if(get_ival(PS4_SHARE)) {
	            if(get_ival(PS4_R3)) {
	                set_val(PS4_SHARE, 100);
	                set_val(PS4_TOUCH, 0);
	                set_val(PS4_R3, 0);
	            } else {
	                set_val(PS4_TOUCH, 100);
	                set_val(PS4_SHARE, 0);
	            }
	        }
	    }
	} else if(get_console() == PIO_XB360) {
	    if((get_controller() == PIO_PS4) || (get_controller() == PIO_PS5)) {
	        swap(PS4_TOUCH, PS4_SHARE);
	    }
	}
}

// Switches profiles
function switchProfile(profile) {
	
	// Set last weapon info
	lastCategory = currentCategory[currentProfile];
	lastWeapon = currentWeapon[currentProfile];
	lastMuzzle = antiRecoilMuzzle[currentProfile];
	lastForegrip = antiRecoilForegrip[currentProfile];
	lastStock = antiRecoilStock[currentProfile];
	lastScope = antiRecoilScope[currentProfile];
	
	currentProfile = profile; // Set current profile
	combo_stop_all(); // Stop any combos that may disrupt the notification
	reset_rumble(); // Stop and reset any rumbles
	
	screenSaverCounter = 0; // Reset counter
	
	if(!displayDepth) {
		// Display notification only if not in a menu
		if(userData[vOptionWeaponDisplay] != displayAlways) {
			combo_run(cboSwitchProfile);
		} else {
			combo_run(cboWeaponDisplay);
		}
	} else if(displayDepth == 3) {
		menuProfile = currentProfile;
	}
}

// Verifies that a toggle combination is not already set
function verifyToggleCombo(verify_button, index) {
	
	// Loop through each set of toggle buttons
	for(j = 0; j < NUMBER_OF_TOGGLE_BUTTONS; j += 2) {
		if(userData[vToggleButton + j] && userData[vToggleButton + j + 1]) { // Make sure the buttons are accepted (0 = rejected from prior function)
			if(j != index) { // Do not compare against self, is already done in prior function
				if(userData[vToggleButton + j] == userData[vToggleButton + index] && userData[vToggleButton + j + 1] == userData[vToggleButton + index + 1]) {
					combo_run(cboActionFailed);
					return 0;
				}
			}
		}
	}
	
	displayUpdate = TRUE; // Enable display update
	combo_run(cboActionSuccess); // Notify user of success setting toggle button
	
	return verify_button; // Return button
}


/**************************************************************/
// User-defined settings
/**************************************************************/
// Load user-defined configuration settings
function loadSettings() {

	reset_spvar();
	
	// Read and check the first bit, if it is set, we know something should have been saved, otherwise we fall back on our default setting
	if(read_spvar(0, 1, 0)) {
		/* Anti-drift */
		userData[vAntiDrift]								= read_spvar(0, 1, 0);
		userData[vAntiDriftLeft + antiDriftUp]				= read_spvar(-4095, 4095, 0);
		userData[vAntiDriftLeft + antiDriftDown]			= read_spvar(-4095, 4095, 0);
		userData[vAntiDriftLeft + antiDriftLeft]			= read_spvar(-4095, 4095, 0);
		userData[vAntiDriftLeft + antiDriftRight]			= read_spvar(-4095, 4095, 0);
		userData[vAntiDriftRight + antiDriftUp]				= read_spvar(-4095, 4095, 0);
		userData[vAntiDriftRight + antiDriftDown]			= read_spvar(-4095, 4095, 0);
		userData[vAntiDriftRight + antiDriftLeft]			= read_spvar(-4095, 4095, 0);
		userData[vAntiDriftRight + antiDriftRight]			= read_spvar(-4095, 4095, 0);
		
		/* Anti-recoil */
		for(i = 0; i < 6; i++) {
			userData[vAntiRecoil1x + i]						= read_spvar(0, 200, 0);
		}
		
		/* Controller */
		userData[vControllerButtonLayout] 					= read_spvar(cblTypeA, cblTypeC, cblTypeB);
		userData[vControllerBumperTriggers] 				= read_spvar(0, 1, 0);
		
		/* Options */
		userData[vOptionAutoFocus]							= read_spvar(0, 1, 0);
		userData[vOptionAutoFocus + 1]						= read_spvar(0, 1, 0);
		userData[vOptionAutoLean]							= read_spvar(0, 1, 0);
		userData[vOptionAutoLean + 1]						= read_spvar(0, 1, 0);
		userData[vOptionCrouchShot]							= read_spvar(crouchOff, crouchOnFire, crouchOff);
		userData[vOptionCrouchShot + 1]						= read_spvar(crouchOff, crouchOnFire, crouchOff);
		userData[vOptionFastLean] 							= read_spvar(0, 1, 0);
		userData[vOptionStanceTracker] 						= read_spvar(stanceTrackerOff, stanceTrackerTrainingMode, stanceTrackerOff);
		userData[vOptionWeaponDisplay]						= read_spvar(displayOff, displayAlways, displayOn);
		
		/* Profiles */
		userData[vProfileColor]								= read_spvar(red, pink, blue);
		userData[vProfileColor + 1]							= read_spvar(red, pink, purple);
		
		/* Settings */
		userData[vAimAcceleration + aimAccelReduction]		= read_spvar(1, 100, 100);
		userData[vAimAcceleration + aimAccelThreshold]		= read_spvar(1, 100, 100);
		userData[vBlockRumble]								= read_spvar(0, 1, 0);
		userData[vDeadzone + deadzoneLeft]					= read_spvar(0, 50, 0);
		userData[vDeadzone + deadzoneRight]					= read_spvar(0, 50, 0);
		userData[vDefaultWeapon]							= read_spvar(akm, sniper_shotgun, akm);
		userData[vDefaultWeapon + 1]						= read_spvar(akm, sniper_shotgun, akm);
		userData[vInverted]									= read_spvar(0, 1, 0);
		userData[vKeyboardSwitch]							= read_spvar(0, 1, 0);
		userData[vSmoothing] 								= read_spvar(0, 1, 0);
		
		/* Toggles */
		userData[vToggleButton + toggleProfile]				= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleProfile + 1]			= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleAutoFocus]			= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleAutoFocus + 1]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleAutoLean]			= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleAutoLean + 1]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleAutoParachute]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleAutoParachute + 1]	= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleAutoTurbo]			= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleAutoTurbo + 1]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleBurstFire]			= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleBurstFire + 1]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleCrouchShot]			= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleCrouchShot + 1]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleRapidFire]			= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleButton + toggleRapidFire + 1]		= read_spvar(0, XB1_X, 0); // RB is lowest value and X is highest value
		userData[vToggleCrouchShot]							= read_spvar(crouchOnAds, crouchOnFire, crouchOnAds);
	} else {
		if(!DEVELOPER) {
			/* Anti-drift */
			userData[vAntiDrift]								= 0;
			userData[vAntiDriftLeft + antiDriftUp]				= 0;
			userData[vAntiDriftLeft + antiDriftDown]			= 0;
			userData[vAntiDriftLeft + antiDriftLeft]			= 0;
			userData[vAntiDriftLeft + antiDriftRight]			= 0;
			userData[vAntiDriftRight + antiDriftUp]				= 0;
			userData[vAntiDriftRight + antiDriftDown]			= 0;
			userData[vAntiDriftRight + antiDriftLeft]			= 0;
			userData[vAntiDriftRight + antiDriftRight]			= 0;
			
			/* Anti-recoil */
			for(i = 0; i < 6; i++) {
				userData[vAntiRecoil1x + i]						= 0;
			}
			
			/* Controller  */
			userData[vControllerButtonLayout] 					= cblTypeB;
			userData[vControllerBumperTriggers] 				= 0;
			
			/* Options */
			userData[vOptionAutoFocus]							= 0;
			userData[vOptionAutoFocus + 1]						= 0;
			userData[vOptionAutoLean]							= 0;
			userData[vOptionAutoLean + 1]						= 0;
			userData[vOptionCrouchShot]							= crouchOff;
			userData[vOptionCrouchShot + 1]						= crouchOff;
			userData[vOptionFastLean] 							= 0;
			userData[vOptionStanceTracker] 						= stanceTrackerOff;
			userData[vOptionWeaponDisplay]						= 0;
			
			/* Profiles */
			userData[vProfileColor]								= green;
			userData[vProfileColor + 1]							= purple;
			
			/* Settings */
			userData[vAimAcceleration + aimAccelReduction]		= 100;
			userData[vAimAcceleration + aimAccelThreshold]		= 100;
			userData[vBlockRumble]								= 0;
			userData[vDeadzone + deadzoneLeft]					= 0;
			userData[vDeadzone + deadzoneRight]					= 0;
			userData[vDefaultWeapon]							= akm;
			userData[vDefaultWeapon + 1]						= slr;
			userData[vInverted]									= 0;
			userData[vKeyboardSwitch]							= 0;
			userData[vSmoothing] 								= 0;
			
			/* Toggles */
			userData[vToggleButton + toggleProfile]				= XB1_RB;
			userData[vToggleButton + toggleProfile + 1]			= XB1_Y;
			userData[vToggleButton + toggleAutoFocus]			= 0;
			userData[vToggleButton + toggleAutoFocus + 1]		= 0;
			userData[vToggleButton + toggleAutoLean]			= 0;
			userData[vToggleButton + toggleAutoLean + 1]		= 0;
			userData[vToggleButton + toggleAutoParachute]		= 0;
			userData[vToggleButton + toggleAutoParachute + 1]	= 0;
			userData[vToggleButton + toggleAutoTurbo]			= 0;
			userData[vToggleButton + toggleAutoTurbo + 1]		= 0;
			userData[vToggleButton + toggleBurstFire]			= 0;
			userData[vToggleButton + toggleBurstFire + 1]		= 0;
			userData[vToggleButton + toggleCrouchShot]			= 0;
			userData[vToggleButton + toggleCrouchShot + 1]		= 0;
			userData[vToggleButton + toggleRapidFire]			= 0;
			userData[vToggleButton + toggleRapidFire + 1]		= 0;
			userData[vToggleCrouchShot]							= crouchOnAds;
		} else {
			/* Anti-drift */
			userData[vAntiDrift]								= 1;
			userData[vAntiDriftLeft + antiDriftUp]				= -2666;
			userData[vAntiDriftLeft + antiDriftDown]			= 763;
			userData[vAntiDriftLeft + antiDriftLeft]			= 683;
			userData[vAntiDriftLeft + antiDriftRight]			= 3160;
			userData[vAntiDriftRight + antiDriftUp]				= -4078;
			userData[vAntiDriftRight + antiDriftDown]			= -2735;
			userData[vAntiDriftRight + antiDriftLeft]			= 2528;
			userData[vAntiDriftRight + antiDriftRight]			= 4523;
			
			/* Anti-recoil */
			userData[vAntiRecoil1x]								= 90;
			userData[vAntiRecoil2x]								= 150;
			userData[vAntiRecoil3x]								= 155;
			userData[vAntiRecoil4x]								= 150;
			userData[vAntiRecoil6x]								= 125;
			userData[vAntiRecoil8x]								= 125;
			
			/* Controller */
			userData[vControllerButtonLayout] 					= cblTypeB;
			userData[vControllerBumperTriggers] 				= 0;
			
			/* Options */
			userData[vOptionAutoFocus]							= 1;
			userData[vOptionAutoFocus + 1]						= 1;
			userData[vOptionAutoLean]							= 0;
			userData[vOptionAutoLean + 1]						= 1;
			userData[vOptionCrouchShot]							= crouchOff;
			userData[vOptionCrouchShot + 1]						= crouchOff;
			userData[vOptionFastLean] 							= 1;
			userData[vOptionStanceTracker] 						= stanceTrackerOn;
			userData[vOptionWeaponDisplay]						= 1;
			
			/* Profiles  */
			userData[vProfileColor]								= green;
			userData[vProfileColor + 1]							= purple;
			
			/* Settings */
			userData[vAimAcceleration + aimAccelReduction]		= 66;
			userData[vAimAcceleration + aimAccelThreshold]		= 85;
			userData[vBlockRumble]								= 1;
			userData[vDeadzone + deadzoneLeft]					= 5;
			userData[vDeadzone + deadzoneRight]					= 5;
			userData[vDefaultWeapon]							= akm;
			userData[vDefaultWeapon + 1]						= slr;
			userData[vInverted]									= 1;
			userData[vKeyboardSwitch]							= 1;
			userData[vSmoothing] 								= 1;
			
			/* Toggles */
			userData[vToggleButton + toggleProfile]				= XB1_RB;
			userData[vToggleButton + toggleProfile + 1]			= XB1_Y;
			userData[vToggleButton + toggleAutoFocus]			= 0;
			userData[vToggleButton + toggleAutoFocus + 1]		= 0;
			userData[vToggleButton + toggleAutoLean]			= XB1_LT;
			userData[vToggleButton + toggleAutoLean + 1]		= XB1_LEFT;
			userData[vToggleButton + toggleAutoParachute]		= XB1_LT;
			userData[vToggleButton + toggleAutoParachute + 1]	= XB1_UP;
			userData[vToggleButton + toggleAutoTurbo]			= XB1_RT;
			userData[vToggleButton + toggleAutoTurbo + 1]		= XB1_RIGHT;
			userData[vToggleButton + toggleBurstFire]			= XB1_LT;
			userData[vToggleButton + toggleBurstFire + 1]		= XB1_RIGHT;
			userData[vToggleButton + toggleCrouchShot]			= XB1_LB;
			userData[vToggleButton + toggleCrouchShot + 1]		= XB1_DOWN;
			userData[vToggleButton + toggleRapidFire]			= XB1_LB;
			userData[vToggleButton + toggleRapidFire + 1]		= XB1_LEFT;
			userData[vToggleCrouchShot]							= crouchOnAds;
		}
	}
	
	// Set default weapons & categories
	currentWeapon[0] = userData[vDefaultWeapon];
	currentWeapon[1] = userData[vDefaultWeapon + 1];
	currentCategory[0] = getWeaponCategory(userData[vDefaultWeapon]);
	currentCategory[1] = getWeaponCategory(userData[vDefaultWeapon + 1]);
	
	setControllerConfig(); // Set controller configuration
}

// Save user-defined configuration settings
function saveSettings() {

	// Always reset the spvar state before saving to ensure that we are saving at the same location as we will later read
	reset_spvar();
	
	// Set Weapon and category IDs
	//userData[vDefaultWeapon] = currentWeapon[0];
	//userData[vDefaultWeapon + 1] = currentWeapon[1];
	
	// Save a constant 1 to denote previously saved data, this range uses 1 bit
	save_spvar(1, 0, 1);
	
	/* Anti-drift */
	save_spvar(userData[vAntiDrift], 0, 1);
	save_spvar(userData[vAntiDriftLeft + antiDriftUp], -4095, 4095);
	save_spvar(userData[vAntiDriftLeft + antiDriftDown], -4095, 4095);
	save_spvar(userData[vAntiDriftLeft + antiDriftLeft], -4095, 4095);
	save_spvar(userData[vAntiDriftLeft + antiDriftRight], -4095, 4095);
	save_spvar(userData[vAntiDriftRight + antiDriftUp], -4095, 4095);
	save_spvar(userData[vAntiDriftRight + antiDriftDown], -4095, 4095);
	save_spvar(userData[vAntiDriftRight + antiDriftLeft], -4095, 4095);
	save_spvar(userData[vAntiDriftRight + antiDriftRight], -4095, 4095);
	
	/* Anti-recoil */
	for(i = 0; i < 6; i++) {
		save_spvar(userData[vAntiRecoil1x + i], 0, 200);
	}
	
	/* Controller */
	save_spvar(userData[vControllerButtonLayout] , cblTypeA, cblTypeC);
	save_spvar(userData[vControllerBumperTriggers] , 0, 1);
	
	/* Options */
	save_spvar(userData[vOptionAutoFocus], 0, 1);
	save_spvar(userData[vOptionAutoFocus + 1], 0, 1);
	save_spvar(userData[vOptionAutoLean], 0, 1);
	save_spvar(userData[vOptionAutoLean + 1], 0, 1);
	save_spvar(userData[vOptionCrouchShot], crouchOff, crouchOnFire);
	save_spvar(userData[vOptionCrouchShot + 1], crouchOff, crouchOnFire);
	save_spvar(userData[vOptionFastLean], 0, 1);
	save_spvar(userData[vOptionStanceTracker] , stanceTrackerOff, stanceTrackerTrainingMode);
	save_spvar(userData[vOptionWeaponDisplay], displayOff, displayAlways);
	
	/* Profiles */
	save_spvar(userData[vProfileColor], red, pink);
	save_spvar(userData[vProfileColor + 1], red, pink);
	
	/* Settings */
	save_spvar(userData[vAimAcceleration + aimAccelReduction], 1, 100);
	save_spvar(userData[vAimAcceleration + aimAccelThreshold], 1, 100);
	save_spvar(userData[vBlockRumble], 0, 1);
	save_spvar(userData[vDeadzone + deadzoneLeft], 0, 50);
	save_spvar(userData[vDeadzone + deadzoneRight], 0, 50);
	save_spvar(userData[vDefaultWeapon], akm, sniper_shotgun);
	save_spvar(userData[vDefaultWeapon + 1], akm, sniper_shotgun);
	save_spvar(userData[vInverted], 0, 1);
	save_spvar(userData[vKeyboardSwitch], 0, 1);
	save_spvar(userData[vSmoothing] , 0, 1);

	/* Toggles */
	save_spvar(userData[vToggleButton + toggleProfile], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleProfile + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleAutoFocus], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleAutoFocus + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleAutoLean], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleAutoLean + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleAutoParachute], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleAutoParachute + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleAutoTurbo], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleAutoTurbo + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleBurstFire], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleBurstFire + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleCrouchShot], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleCrouchShot + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleRapidFire], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleButton + toggleRapidFire + 1], 0, XB1_X); // RB is lowest value and X is highest value
	save_spvar(userData[vToggleCrouchShot], crouchOnAds, crouchOnFire);
	
	// Debug purposes to make sure we have enough space
	set_val(TRACE_1, spvar_current_slot);
	
	setControllerConfig();
}

function reset_spvar() {
	 // Change this to say where it's safe to Roset storing data
	spvar_current_slot = SPVAR_1; 
	
	// Should always be 0, unless you're using part of the first SPVAR 
	// in which case you should also change the next line to include the 
	// value you are storing in the bits you are using
	spvar_current_bit = 0; 
	spvar_current_value = 0;
}

// Function used to count the number of bits used by the given value
function get_bit_count(val) {
	// We need to Roset at 0, we use spvar_tmp here as we need to track
	// the bits during our loop below
	spvar_tmp = 0; 
	
	// Loop while val is anything but 0
	while (val) { 
		// Increment the bit count by 1
		spvar_tmp++; 
		
		// Shift the value down 1 bit, once we have no more bits set this
		// will result in 0, unless the value is negative - in which case
		// this will be endless, we do abs here to make it always
		val = abs(val >> 1);
	}
	return spvar_tmp;
}

// Function used to count the number of bits used by 2 given values
function get_bit_count2(val1, val2) {
	// Get the highest bit count required for either min or max
	spvar_tmp = max(get_bit_count(val1), get_bit_count(val2));
	
	// Check if we need to know if the value is negative or not
	if (is_signed2(val1, val2)) {
		// If we need to track if the saved value is negative, we need 1 bit
		// for that specifically - the others are used to store the actual value
		spvar_tmp++;
	}
	return spvar_tmp;
}

// Function used to determine if either of 2 given values is negative
function is_signed2(val1, val2) {
	return (val1 < 0) || (val2 < 0);
}

// Function used to generate a bitmask for the sign bit, this will always be
// the highest bit in the range we're requesting it for, to do that - we need
// to Roset with the lowest bit set and move it up the number of steps there
// is between 1 and the bits we need, this needs to be a maximum of 31 but can
// never be negative
function make_sign(bits) { 
	return 1 << clamp(bits - 1, 0, 31);
}

// Function used to generate a full bitmask (essentially all bits set up to
// and including the number of bits given)
function make_full_mask(bits) {	
	// If we're wanting a bitmask for all bits, we can simply return -1
	// (which is all bits set to 1)
	if (bits == 32) { 
		return -1;
	}
	
	// What we do here is basically take a value with all bits except the highest
	// set and shift them down as many times as we need to get a mask that fits
	// the bit count we're looking for
	return 0x7FFFFFFF >> (31 - bits);
}

// Function used to generate a bitmask for just the bits required for the value
// part of a signed range, this means all the bits below the sign bit
function make_sign_mask(bits) {
	return make_full_mask(bits - 1);
}

// Function used to pack a value that has potential for being negative in a way
// that we use the least number of bits we really need to represent the value
function pack_i(val, bits) {

	// Check if we have a negative value, if so - handle it accordingly
	if (val < 0) { 
		// Get the positive version of the value and keep the bits that are within
		// range of what we're doing and add the sign bit since we have a negative
		// value and return the result
		return (abs(val) & make_sign_mask(bits)) | make_sign(bits);
	}
	
	// Get the bits that are within our range
	return val & make_sign_mask(bits); 
}

// Function used to unpack (restore) a value that has potential for being negative,
// essentially reversing what pack_i does above
function unpack_i(val, bits) {

	// Check if the stored value is supposed to be negative
	if (val & make_sign(bits)) {
		// Retrieve the stored positive value and subtract it from 0 (resulting in
		// the same value except negative), return the result
		return 0 - (val & make_sign_mask(bits));
	}
	
	// Retrieve the stored positive value and return it
	return val & make_sign_mask(bits);
}

// Function used to read the value of a SPVAR without any limits
function read_spvar_slot(slot) {
	return get_pvar(slot, 0x80000000, 0x7FFFFFFF, 0);
}

// Function used to save your value in the SPVARs, this is the function you'll be
// calling when saving a value. You need to provide the value to save aswell as
// the range (minimum and maximum value, this is how we determine how many bits
// to use when saving this value)
function save_spvar(val, min, max) {

	// Set spvar_bits to the number of bits we need for this range
	spvar_bits = get_bit_count2(min, max); 
	
	// Make sure the value is within our defined range to begin with
	val = clamp(val, min, max); 
	
	// If either min or max is negative, we need to pack this value as a
	// possibly negative value
	if (is_signed2(min, max)) { 
		// Pack as signed value (possibly negative)
		val = pack_i(val, spvar_bits);
	}
	
	// Pack as unsigned value (always positive), this essentially just makes the
	// resulting value not have any extra bits set - it's safe to use after the
	// signed packing since we're not using any bits outside of the unsigned range anyways
	val = val & make_full_mask(spvar_bits); 
	
	// Check if there is not enough bits remaining to save this value as-is. if
	// there aren't enough bits, we save what we can here and store the remaining
	// bits in the next spvar, if this means we're hitting the end, we can make
	// this smaller by handling the case where we use all bits here aswell
	if (spvar_bits >= 32 - spvar_current_bit) { 
		// Add what we can to the current value where there is bits available to use
		spvar_current_value = spvar_current_value | (val << spvar_current_bit); 
		// Save the current SPVAR before advancing to the next one
		set_pvar(spvar_current_slot, spvar_current_value); 
		// Move to the next slot
		spvar_current_slot++; 
		// Update the required bits according to our needs for the next slot, 
		// if we don't do this here, we'll screw up the saved value by moving
		// it too far out of range
		spvar_bits -= (32 - spvar_current_bit);
		// Move the remaining bits down, discarding the bits we've already saved
		val = val >> (32 - spvar_current_bit); 
		// Reset the current bit counter since we're Roseting with a new SPVAR
		spvar_current_bit = 0; 
		// Reset our value so we Roset clean, we aren't currently using any bits anyways
		spvar_current_value = 0; 
	}
	
	// Merge the current SPVAR value with our currently value where there is space to keep our value
	spvar_current_value = spvar_current_value | (val << spvar_current_bit); 
	// Move up the counter of next available bit to where we are currently saving data at
	spvar_current_bit += spvar_bits; 
	
	if (!spvar_current_bit) {
		// Reset our value so we Roset clean, we aren't currently using any bits anyways
		spvar_current_value = 0; 
	}
	
	// Save the SPVAR with the current value, this won't write anything to flash unless
	//the value changed - so we can do this for each variable saved to no risk missing anything
	set_pvar(spvar_current_slot, spvar_current_value); 
}

// Function used to read your value from the SPVARs, this is the function you'll be
// calling when reading a value. You need to provide the range (minimum and maximum
// value, this is how we determine how many bits to use when reading the value) aswell
// as a default value if what we read is out of range
function read_spvar(min, max, def) {

	// Set spvar_bits to the number of bits we need for this range
	spvar_bits = get_bit_count2(min, max); 
	
	// Read the current SPVAR value from flash and shift them into position,
	// we'll handle split values next
	spvar_current_value = (read_spvar_slot(spvar_current_slot) >> spvar_current_bit) & make_full_mask(spvar_bits);
	
	// Check if we are dealing with a split SPVAR value, essentially if the current
	// position means we're using more than 32 bits in the SPVAR, we need to retrieve
	// the missing bits from the next SPVAR and put them back to our current value,
	// we use the same space saving trick here as in the save function
	if (spvar_bits >= 32 - spvar_current_bit) {
		spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | ((read_spvar_slot(spvar_current_slot + 1) & make_full_mask(spvar_bits - (32 - spvar_current_bit))) << (32 - spvar_current_bit));
		//Below is a breakdown of the line above, with each step done one at a time instead of all at once - this however increases codesize - the below code is to explain how it all works tho
		//spvar_tmp = read_spvar_slot(spvar_current_slot + 1); // Read the SPVAR slot coming after the initial one we used to spvar_tmp from flash, we need to maintain the data we've read thus far, but also add on what we have in flash for the next SPVAR
		//spvar_tmp = spvar_tmp & make_full_mask(spvar_bits - (32 - spvar_current_bit)); // Extract the bits we need need (the ones that didn't fit in the previous SPVAR)
		//spvar_tmp = spvar_tmp << (32 - spvar_current_bit); // Move the bits into their original position, they were stored at the beginning of the new SPVAR but belong at the top of the currently read value
		//spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | spvar_tmp; // put all bits together again with the part read from the first SPVAR cleaned up to only include the bits from this variable/value and not all bits set in the upper range like they normally are
	}
	
	// Move up the counter of next available bit to where we are will be reading data from next
	spvar_current_bit += spvar_bits;
	// Extract all bits included for this value and discard any other bits
	spvar_current_value = spvar_current_value & make_full_mask(spvar_bits); 
	
	if (spvar_current_bit >= 32) {
		// Move to the next SPVAR slot
		spvar_current_slot++;
		// Remove 32 from the spvar_current_bit tracker since we've gone beyond what we can do here
		spvar_current_bit -= 32;
	}
	
	// Check if the value can be negative and handle it accordingly
	if (is_signed2(min, max)) { 
		// Restore the signed, possibly negative value
		spvar_current_value = unpack_i(spvar_current_value, spvar_bits); 
	}
	
	// Check if the value is below our specified min or above our specified max,
	// if so - return the default value instead
	if (spvar_current_value < min || spvar_current_value > max) { 
		// This can be changed to min instead as a reasonable default with the
		// default parameter being removed if you don't need to have a override
		// value for the default when out of range, that will save a bit of code size
		return def; 
	}
	
	// Return the retrieved value to the user since it's within the expected range
	return spvar_current_value;
}


/**************************************************************/
// Combos
/**************************************************************/
combo cboActionSuccess {
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	set_rumble(RUMBLE_B, 80);
	wait(240);
	reset_rumble();
}

combo cboActionFailed {
	set_hsb(colorValues[red][hue], colorValues[red][saturation], colorValues[red][brightness]);
	set_rumble(RUMBLE_A, 80);
	wait(240);
	reset_rumble();
}

combo cboAlertToggleEngaged {
	setProfileLedColor(currentProfile);
	wait(240);
	if(stancePosition) {
		setLedColor(iif(stancePosition == 1, teal, orange));
	}
	wait(iif(stancePosition, 240, 0));
	if(burstFire[currentProfile]) {
		setLedColor(white);
	} else {
		set_hsb(0, 0, 0);
	}
	wait(240);
}

combo cboAlertVehicleMode {
	setLedColor(gold);
	wait(120);
	set_hsb(0, 0, 0);
	wait(120);
}

combo cboAlertStance {
	setLedColor(iif(stancePosition == 1, teal, orange));
	wait(240);
	if(stance == stanceGrenade) {
		setLedColor(gold);
	} else if(stance == stanceNoWeapon || stance == stancePistol) {
		setLedColor(yellow);
	} else {
		setProfileLedColor(currentProfile);
	}
	wait(240);
}

combo cboAutoFocus {
	set_val(XB1_LX, 0);
	set_val(XB1_LY, 0);
	wait(250);
	set_val(button[focus], 100);
	wait(8000);
	set_val(button[focus], 0);
	wait(10000);
	set_val(button[focus], 100);
	wait(3000);
	set_val(button[focus], 0);
	wait(6000);
	set_val(button[focus], 100);
	wait(3200);
	set_val(button[focus], 0);
	wait(6200);
	set_val(button[focus], 100);
	wait(3200);
	set_val(button[focus], 0);
	wait(6000);
}

combo cboAutoLean {
	set_val(leanDirection, 100);
	wait(40);
	/*if(leanDirection == XB1_LS) {
		crouchShotAdjustValue = (polarValues[35] + (sensitivity[getCurrentSensitivity()] * 64));
		crouchShotScopeAdjust = crouchShotAdjustValue - (crouchShotAdjustValue - (crouchShotAdjustValue * scopePercentage_DMR[antiRecoilScope[currentProfile]] / 100));
		crouchShotAdjustValue += crouchShotScopeAdjust;
		output(aimX, crouchShotAdjustValue * iif(userData[vInverted], 1, -1));
	} else {
		crouchShotAdjustValue = (polarValues[35] + (sensitivity[getCurrentSensitivity()] * 64));
		crouchShotScopeAdjust = crouchShotAdjustValue - (crouchShotAdjustValue - (crouchShotAdjustValue * scopePercentage_DMR[antiRecoilScope[currentProfile]] / 100)); 
		crouchShotAdjustValue += crouchShotScopeAdjust;
		output(aimX, crouchShotAdjustValue * iif(userData[vInverted], -1, 1));
	}*/
	//wait(120);
}

combo cboBurstFire {
	wait(60);
	set_val(button[fire], 0);
	wait(60);
	set_val(button[fire], 100);
	wait(60);
	set_val(button[fire], 0);
	wait(60);
	set_val(button[fire], 100);
	wait(60);
}

combo cboFastLean {
	set_val(button[leanR], 100);
	wait(250);
	set_val(button[leanL], 100);
	wait(250);
}

combo cboCalibrationComplete {
	cls_oled(OLED_BLACK);
	set_rumble(RUMBLE_B, 100);
	setLedColor(iif(antiDriftCalibrationCanSet == 2, yellow, iif(antiDriftCalibrationCanSet, green, red)));
	printText(alignCenter, alignCenter, antiDriftCalibrationResult[antiDriftCalibrationCanSet], OLED_FONT_SMALL, OLED_WHITE);
	wait(1440);
	reset_rumble();
	antiDriftCalibrationState = !antiDriftCalibrationState; // Clear calibration state
	displayUpdate = TRUE; // Enable display update
	antiDriftCalibrationCanSet = FALSE; // Reset calibration variable
	antiDriftCalibrationInRange = FALSE; // Reset calibration variable
}

combo cboChangeForegrip {
	set_rumble(RUMBLE_A, antiRecoilForegrip[currentProfile] * 20);
	wait(240);
	reset_rumble();
	combo_restart(cboWeaponDisplay);
}

combo cboChangeMuzzle {
	set_rumble(RUMBLE_A, antiRecoilMuzzle[currentProfile] * 33);
	wait(240);
	reset_rumble();
	combo_restart(cboWeaponDisplay);
}

combo cboChangeStock {
	set_rumble(RUMBLE_A, antiRecoilStock[currentProfile] * 33);
	wait(240);
	reset_rumble();
	combo_restart(cboWeaponDisplay);
}

combo cboChangeScope {
	set_rumble(RUMBLE_A, (antiRecoilScope[currentProfile] + 1) * 33);
	wait(240);
	reset_rumble();
	combo_restart(cboWeaponDisplay);
}

combo cboCrazyShot {
	set_val(button[action], 100);
	wait(40);
	wait(360);
}

combo cboRapidFire {
	// Low value (LCM of possible VM speeds) for immediate fire
	wait(120 / getRapidFireSpeed());
	set_val(button[fire], 0);
	wait(880 / getRapidFireSpeed());
}

int crouchShotAdjustValue, crouchShotScopeAdjust;

combo cboOptionCrouchShot {
	set_val(button[action], 100);
	wait(40);
	if(stancePosition) {
		crouchShotAdjustValue = (polarValues[24] + (sensitivity[getCurrentSensitivity()] * 64));
		crouchShotScopeAdjust = crouchShotAdjustValue - (crouchShotAdjustValue - (crouchShotAdjustValue * scopePercentage_DMR[antiRecoilScope[currentProfile]] / 100));
		crouchShotAdjustValue += crouchShotScopeAdjust;
		output(aimY, crouchShotAdjustValue * iif(userData[vInverted], 1, -1));
	} else {
		crouchShotAdjustValue = (polarValues[12] + (sensitivity[getCurrentSensitivity()] * 64));
		crouchShotScopeAdjust = crouchShotAdjustValue - (crouchShotAdjustValue - (crouchShotAdjustValue * scopePercentage_DMR[antiRecoilScope[currentProfile]] / 100)); 
		crouchShotAdjustValue += crouchShotScopeAdjust;
		output(aimY, crouchShotAdjustValue * iif(userData[vInverted], -1, 1));
	}
	wait(120);
}

combo cboSaveSettings {
	cls_oled(OLED_BLACK);
	printText(alignCenter, alignCenter, settingsSaved[0], OLED_FONT_SMALL, OLED_WHITE);
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	set_rumble(RUMBLE_B, 100);
	wait(500);
	reset_rumble();
	saveSettings();
	displayUpdate = TRUE; // Enable display update
}

combo cboSingleFire {
	switch(stancePosition) {
		case 0 {
			output(aimY, adjustAntiRecoil(antiRecoilY) * iif(userData[vInverted], -1, 1));
			break;	
		} case 1 {
			output(aimY, (adjustAntiRecoil(antiRecoilY) - antiRecoilCrouch) * iif(userData[vInverted], -1, 1));
			break;
		} case 2 {
			output(aimY, (adjustAntiRecoil(antiRecoilY)  - antiRecoilProne) * iif(userData[vInverted], -1, 1));
			break;
		}
	}
	wait(110);
}

combo cboStanceAlert {
	set_rumble(RUMBLE_B, 35);
	wait(240);
	reset_rumble();
}

combo cboStanceReset {
	set_rumble(RUMBLE_A, 50);
	wait(240);
	reset_rumble();
}

combo cboSwitchProfile {
	cls_oled(OLED_BLACK);
	insertString(weaponName[currentWeapon[currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(1000);
	weaponDisplayCounter = 3500; // Reset display
}

combo cboToggleOff {
	
	set_hsb(colorValues[userData[vProfileColor + currentProfile]][hue], colorValues[userData[vProfileColor + currentProfile]][saturation], colorValues[userData[vProfileColor + currentProfile]][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	set_hsb(colorValues[red][hue], colorValues[red][saturation], colorValues[red][brightness]);
	wait(240);
	set_hsb(colorValues[userData[vProfileColor + currentProfile]][hue], colorValues[userData[vProfileColor + currentProfile]][saturation], colorValues[userData[vProfileColor + currentProfile]][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	reset_rumble();
}

combo cboToggleOn {
	set_hsb(colorValues[userData[vProfileColor + currentProfile]][hue], colorValues[userData[vProfileColor + currentProfile]][saturation], colorValues[userData[vProfileColor + currentProfile]][brightness]);
	set_rumble(RUMBLE_B, 75);
	wait(120);
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	wait(240);
	set_hsb(colorValues[userData[vProfileColor + currentProfile]][hue], colorValues[userData[vProfileColor + currentProfile]][saturation], colorValues[userData[vProfileColor + currentProfile]][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	reset_rumble();
}

combo cboToggleAutoFocus {
	cls_oled(OLED_BLACK);
	if(userData[vOptionAutoFocus + currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	printText(alignCenter, alignCenter, toggleMessages[toggleAutoFocus - 2 + userData[vOptionAutoFocus + currentProfile]], OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleAutoLean {
	cls_oled(OLED_BLACK);
	if(userData[vOptionAutoLean + currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	printText(alignCenter, alignCenter, toggleMessages[toggleAutoLean - 2 + userData[vOptionAutoLean + currentProfile]], OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleAutoParachute {
	cls_oled(OLED_BLACK);
	if(autoParachute) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	printText(alignCenter, alignCenter, toggleMessages[toggleAutoParachute - 2 + autoParachute], OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	if(!autoParachute) {
		cls_oled(OLED_BLACK);
	}
}

combo cboToggleAutoTurbo {
	cls_oled(OLED_BLACK);
	if(autoTurbo) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	printText(alignCenter, alignCenter, toggleMessages[toggleAutoTurbo - 2 + autoTurbo], OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleBurstFire {
	cls_oled(OLED_BLACK);
	if(burstFire[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	printText(alignCenter, alignCenter, toggleMessages[toggleBurstFire - 2 + burstFire[currentProfile]], OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleCrouchShot {
	cls_oled(OLED_BLACK);
	if(userData[vOptionCrouchShot + currentProfile]) {
		combo_run(cboToggleOn);
		insertString(toggleMessages[toggleCrouchShot - 1]);
		insertString(crouchShot[userData[vOptionCrouchShot + currentProfile]]);
		flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	} else {
		combo_run(cboToggleOff);
		printText(alignCenter, alignCenter, toggleMessages[toggleCrouchShot - 2], OLED_FONT_SMALL, OLED_WHITE);
	}
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleRapidFire {
	cls_oled(OLED_BLACK);
	if(rapidFire[currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	printText(alignCenter, alignCenter, toggleMessages[toggleRapidFire - 2 + rapidFire[currentProfile]], OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

int weaponDisplayLineCounter;

combo cboWeaponDisplay {
	if(stance == stanceWeapon) {
		weaponDisplayLineCounter = 0; // Reset line counter
		drawBorder();
		if((currentWeapon[currentProfile] != sniper_shotgun) && (canUseMuzzle(currentWeapon[currentProfile]) || canUseForegrip(currentWeapon[currentProfile]) || canUseStock(currentWeapon[currentProfile]))) {
			line_oled(1, OLED_FONT_SMALL_HEIGHT + 7, 127, OLED_FONT_SMALL_HEIGHT + 7, 1, OLED_WHITE);
			insertString(weaponName[currentWeapon[currentProfile]]);
			if(canUseScope(currentProfile)) {
				insertCharacter(ASCII_SPACE);
				insertCharacter(ASCII_LEFT_PARENTHESIS);
				insertString(scopeName[antiRecoilScope[currentProfile]]);
				insertCharacter(ASCII_RIGHT_PARENTHESIS);
			}
			flushBuffer(alignCenter, alignTop, OLED_FONT_SMALL, OLED_WHITE);
			if(canUseMuzzle(currentWeapon[currentProfile])) {
				printText(alignLeft, lineNumber[weaponDisplayLineCounter], muzzles[antiRecoilMuzzle[currentProfile]], OLED_FONT_SMALL, OLED_WHITE);
				weaponDisplayLineCounter++;
			}
			if(canUseForegrip(currentWeapon[currentProfile])) {
				printText(alignLeft, lineNumber[weaponDisplayLineCounter], foregrips[antiRecoilForegrip[currentProfile]], OLED_FONT_SMALL, OLED_WHITE);
				weaponDisplayLineCounter++;
			}
			if(canUseStock(currentWeapon[currentProfile])) {
				printText(alignLeft, lineNumber[weaponDisplayLineCounter], stocks[antiRecoilStock[currentProfile]], OLED_FONT_SMALL, OLED_WHITE);
			}
		} else if(currentWeapon[currentProfile] == sniper_shotgun) {
			insertString(weaponName[currentWeapon[currentProfile]]);
			flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
		} else {
			insertString(weaponName[currentWeapon[currentProfile]]);
			if(canUseScope(currentProfile)) {
				insertCharacter(ASCII_SPACE);
				insertCharacter(ASCII_LEFT_PARENTHESIS);
				insertString(iif(currentWeapon[currentProfile] != p90, scopeName[antiRecoilScope[currentProfile]], p90Scopes[antiRecoilScope[currentProfile]]));
				insertCharacter(ASCII_RIGHT_PARENTHESIS);
			}
			flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
		}
		if(inVehicle) {
			printText(alignCenter, alignBottom, vehicleModeMsg[0], OLED_FONT_SMALL, OLED_WHITE);
		}
	}
}

/**************************************************************/
// Tables
/**************************************************************/
//
// Polar stick values (0 - 100)
const int16 polarValues[] = {
    0,
	328, 656, 984, 1312, 1640, 1968, 2296, 2624, 2952, 3280,
    3608, 3936, 4264, 4592, 4920, 5248, 5576, 5904, 6232, 6560,
    6888, 7216, 7544, 7872, 8200, 8528, 8856, 9184, 9512, 9840,
    10168, 10496, 10824, 11152, 11480, 11808, 12136, 12464, 12792, 13120,
    13448, 13776, 14104, 14432, 14760, 15088, 15416, 15744, 16072, 16400,
    16728, 17056, 17384, 17712, 18040, 18368, 18696, 19024, 19352, 19680,
    20008, 20336, 20664, 20992, 21320, 21648, 21976, 22304, 22632, 22960,
    23288, 23616, 23944, 24272, 24600, 24928, 25256, 25584, 25912, 26240,
    26568, 26896, 27224, 27552, 27880, 28208, 28536, 28864, 29192, 29520,
    29848, 30176, 30504, 30832, 31160, 31488, 31816, 32144, 32472, 32767

} 