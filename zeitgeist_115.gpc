/*

												 Zeitgeist: Call of Duty: Modern Warfare II [Warzone 2]

							"...an invisible agent or force dominating the characteristics of a given epoch in world history"

														Author:		Swedemafia
														Script:		Zeitgeist
														Version:	1.15
														Build Date:	5 April 2023
														Support:	https://discord.gg/e27AarXYMJ
														
														
							REQUIREMENTS:
								* 'Controller Vibration' *MUST* be enabled in the in-game settings for some Options.
								* 'Controller Vibration Intensity' *MUST* be set to 1.00 in the in-game settings for some Options.
								* Zen Studio (current version: v1.3.1 Beta 11).
								* In Zen Studio, 'Use Legacy 16Bit Compiler' found in the Device tab *MUST* be disabled.
								* Use a 0.00 in-game Min Stick deadzone and set your deadzones on the script instead.
							
							SUPPORT:
								* https://discord.gg/e27AarXYMJ
								
							README:
								* https://docs.google.com/document/d/12kAlXmhebmGV0kuSiK4oNmfgxcjtbvoHG8TM4z7wdDo
							
							FEATURES:
								* Aim Assist, Rotation Assist, Idle Target Asist, Motion Assist, Shape Pulse, Shape Spin
									- Customize to your personal preference or use default settings.
									- Thousands of possible Aim Assist setting combinations.
								* Anti-drift
									- Got stick drift?  No problem.  You can run a 0 in-game deadzone and have no stick drift at all.
									- Unique feature only found in scripts from this developer.
									- Quick & easy calibration process to determine your stick drift so the script will cancel it out.
								* Anti-recoil
									- Basic, Advanced, Expert, or Weapon Select.
									- Weapon Select allows you to select which weapon you are using.
										- Script has built-in recoil profiles for every weapon.
										- Adjust the strength using the Compensation Values.
										- Works with any combination of attachments.
								* Akimbo
									- Select Rapid Fire or Fully Automatic.
								* Auto ADS/Fire
									- Select ADS on Fire or Fire on ADS.
								* Auto Focus
									- Automatically hold your breath to focus, useful for sniping or with marksman rifles.
								* Auto Ping
									- Select Ping Once on Fire or select an interval to repeatedly ping at when firing.
								* Backpack Swap (Warzone 2)
									- Select Double Tap Swap or Use Toggle.
										* Double Tap weapon Swap button to engage or set up a quick toggle.
								* Bunny Hop
									- Hold the Jump button to repeatedly jump as fast as possible.
								* Drop Shot
									- Tap the crouch/prone button while aiming and firing to quickly drop to the ground.
										* Configure Aim Adjust to tilt your weapon upwards while you drop prone.
								* Fast Melee
									- Select Hold or Toggle.
										* 'Hold' the melee button to melee as fast as possible.
										* 'Toggle' allows you to enable/disable fast melee by pressing the melee button.
								* G-Walk
									- Use either Sprint Button or Replace Slide/Dive to engage.
								* Hair Triggers
									- Enable hair triggers for your controller.
								* Rapid Fire
									- Using a semi-automatic weapon, choose how many Shots per Second you wish to fire by holding your trigger.
								* Rapid Fire Pistols
									- Choose how many Shots per Second you wish to fire pistols by holding your trigger.
									- This option *may not* work properly with PlayStation 5 controllers due to Cronus rumble issues!
								* Tactical Sprint
									- Use this with the Akimbo option enabled to seamlessly transition from tactical sprint to akimbo fire.
										* Requires changes to your in-game settings.
										* Settings > Controller > Gameplay ---> Set Automatic Sprint to Off
										* Settings > Controller (Advanced) > Movement Behaviors ---> Set Tactical Sprint Behavior to Double Tap
								* Quick Scope
									- Select a delay after ADS to automatically fire your sniper rifle.

							MISCELLANEOUS:
								* Adjustable profile LED color on your Cronus Zen device.
								* Configure your loadout to Primary/Secondary profiles (tune your guns using Weapon Select).
								* Compatible for Inverted players.
								* Deadzone capabilities to allow you to run a 0 in-game deadzone setting.
									- By running a 0 in-game deadzone you can have the strongest possible Aim Assist. 
								* FULL support for every combination of controller settings in Call of Duty.
									- No support for Custom settings.
								* Support for Toggles (set a hold button + double-tap button) to quickly enable/disable Options.
								* Universal profile
									- Useful for "ground loot" or use one profile for all weapons.
								
							NAVIGATION:
								* Enter script menu:
									* Hold LT and press Menu (Xbox).
									* Hold L2 and press Options (PlayStation).
								* Enter Anti-recoil Quick Edit or Weapon Select Menu
									* Hold LT and press View (Xbox).
									* Hold L2 and press Share (PlayStation).
								* Selecting values to edit or enabling/disabling Options
									* Press Up or Down.
								* Editing values
									* Hold LT/L2 and press Right/Left (cycle setting/increase by 1/decrease by 1).
									* Hold LT/L2 and press Up/Down (increase by 10/decrease by 10).
								* Save Settings
									* Press B/Circle until your Cronus Zen device says "Settings Saved."
									
							CHANGE LOG:
								[Version 1.15]
								* [BUGS]
									- Fixed an issue where "G-Walk" would not save.
								* [UPGRADE]
									- Refined the recoil pattern for the Vaznev-9K.
									- Modified the timings of all combos to mitigate Ricochet detection (experimental).
								[Version 1.14]
								* [BUGS]
									- Fixed an issue where anti-recoil would not function properly (it would pull down excessively) for Xbox Series X users with certain Xbox controllers.
								* [REMOVED]
									- Removed "Reactive" feature from Rotation Assist.
								* [NEW]
									- Inverse Assist: moved "Reactive" to its own assist option.
									- Inverse Assist can be used without Rotation Assist on to provide inverse right stick movement to the left stick.
								[Version 1.13]
								* [BUGS]
									- Fixed an issue where Expert anti-recoil would not update the display to show the values.
								[Version 1.12]
								* [BUGS]
									- Fixed an issue where Weapon Select horizontal anti-recoil values were not properly being calculated.
									- Fixed an issue where Expert horizontal anti-recoil values would not save.
								* [NEW]
									Aim Assist
										* New Shape: Ecstasy - let your aim assist experience ascension.
									Anti-recoil
										* ISO Hemlock has been added.
									Rotation Assist
										* Rotation Assist Type
											- Stable; Reactive; Reactive ADS; Reactive Fire.
											- This setting will cause the Rotation Assist Shape to be reactive to your aimer stick.
											- Stable = no change, Reactive = change on ADS or Fire, Reactive ADS = change only on ADS, Reactive Fire = change only on Fire
											- Threshold determines at what point of right stick movement will the reactive inverse stick behavior engage.
										* New Shape: Random
											- Random will randomly cycle through Rotation Assist shapes.
										* New Shape: Ceorin
											- This shape draws "four corners" of square at the given radius and uses a delay like Strafe.
								* [UPGRADE]
									Internal to the script
										* Completely redesigned the way the script handles menus to reduce the script size by nearly 15%.
									Aim Assist
										* Adjusted values in the cosine/sine table.
										* Adjusted the Orbit shape.
									Anti-recoil
										* Refined anti-recoil patterns for Season 2 update.
									Options
										* 'Auto Focus' now can be 'Instant' or 'Delayed'.
										* 'Rapid Fire Pistols' now has PlayStation 5 rumble values (use controller in A3 port).
											- note: this still may not work as intended for PlayStation 5 controller users.
									Settings
										* Relocated the Smoothing function to properly be called after the anti-stick drift & deadzone algorithm is executed.
									Vehicle Mode
										* Vehicle Mode screen display now shows whether you are in a vehicle or leaning out of the window.
								[Version 1.11]
								* [UPGRADE]
									Aim Assist
										- Aim Assist Type now has nine (9) options.
								[Version 1.10]
								* [BUGS]
									- Fixed an issue with Toggles.  Toggles should be HOLD button + Double-tap Button.
								* [UPGRADE]
									- Motion Assist will now always have the shape in motion instead of waiting for the shape to entirely draw.
									- Fixed Rapid Fire Pistols so they will reamain firing if you are being shot (rumble feedback interference removed).
								* [NEW]
									Settings
										- Smoothing: exponential smoothing to smoothen out rapid movements when aiming/firing.
								[Version 1.09]
								* [BUGS]
									- Fixed an issue where resyncing profiles would not work correctly.
								* [NEW]
									Options
									 - "Rapid Fire Pistols": script will now detect pistols and apply rapid fire.
								[Version 1.08]
								* [NEW]
									Options
										- "G-Walk": use either Sprint Button or Replace Slide/Dive to engage.
								* [BUGS]
									- Fixed an issue with anti-recoil improperly pulling down for mouse & keyboard players.
								* [UPGRADE]
									- Refined bunny hop.
								[Version 1.07]
								* [NEW]
									Aim Assist
										- New 'Heart Curve' shape
									Controller
										- New 'Invert Slide/Dive' Controller setting to match in-game settings.
									Options
										- Dolphin Cancel
										- Slide Cancel (MW 2019 w/ delay setting or MW2)
								* [BUGS]
									- Fixed an issue with Bunny Hop causing your jump button to have unwanted behavior.
									- Fixed an issue with Advanced Anti-recoil where it would not engage for PlayStation controller users.
									- Fixed an issue where applying Armor Plates would switch your profile on the script.
								* [UPGRADE]
									Smart Vehicle Mode
									- You can now switch seats or move to the roof and Vehicle Mode will disable.
									- You can now lean out the window while driving and you can get Aim Assist.
								[Version 1.06]
								* [NEW]
									Aim Assist
										- Shape Pulse
											- Set a radius that the Aim Assist shape pulses into
											- i.e. AA Radius 10 and Shape Pulse Radius 20, the shape will grow in size to 20 and back to 10
										- Shape Spin
											- Offset or Spinning
												- 'Offset' the shape by an angle you set.
												- 'Spinning' spins the shape stepping by the angle you set.
								[Version 1.05 BETA]
								* [BUGS]
									- Fixed an issue where Auto Focus would disengage while firing.
								* [NEW]
									- Aim Assist, Rotation Assist, Motion Assist new activation: ADS and Fire / ADS
									- Hair Triggers (Options) is now optional.
								* [UPGRADE]
									Aim Assist
										- Rotation Aim Assist now includes a Type option which can be Strafe or a shape.
									Anti-Recoil
										- Anti-recoil algorithm now uses rumble feedback for smoother recoil control.
								* [NEW]
									Aim Assist
										- Aim & Rotation Assist Shape: Diamond, Horizon.
									Anti-recoil
										- Built in adjustable anti-recoil patterns for 28 weapons (AR/BR/SMG/LMG).
									Motion Assist
										- Puts your Aim Assist shape in motion based on the shape you select.
									Options
										- Auto Ping: automatically ping when firing or repeatedly on an interval when firing.
									Miscellaneous
										- Change Log introduced to record bug fixes, upgrades, changes, and new features.
									
*/

/**************************************************************/
//	Variables
/**************************************************************/
// (Aim Assist)
int aimAssistAngle;
int aimAssistShapeMin, aimAssistShapeMax;
int aimAssistX, aimAssistY;
int aimAssistRadius, aimAssistShape, aimAssistSpeed;
int aimAssistRandomShape;
// (Aim Assist) Aim Assist Type
int polarStick, polarValue;
// (Aim Assist) Idle Target Assist
int idleTargetEngaged, idleTargetTimer;
// (Aim Assist) Rotation Assist
int rotationAngle, rotationCounter, rotationType, rotationSpeed, rotationDirection, rotationRadius, rotationRandomShape;
// (Aim Assist) Shape Motion
int motionShape, motionRadius, motionSpeed;
int motionAngle;
int motionX, motionY;
// (Aim Assist) Shape Pulse
int pulseRadius, pulseDirection;
// (Aim Assist) Shape Spin
int spinX, spinY, spinAngle, spinSpeed, spinType;
// (Anti-drift)
int antiDriftStickValue;
int antiDriftLowValue, antiDriftHighValue;
int antiDriftCalibrationLow, antiDriftCalibrationHigh;
int antiDriftCalibrationValue, antiDriftCalibrationRangeValue;
int antiDriftCalibrationState, antiDriftCalibrationInRange, antiDriftCalibrationCanSet;
int antiDriftCalibrationPolarStick, antiDriftCalibrationStick, antiDriftCalibrationDirection;
// (Anti-recoil)
int antiRecoilQuickEdit;
int antiRecoilX, antiRecoilY;
int antiRecoilCounterX, antiRecoilCounterY;
int antiRecoilStateX, antiRecoilStateY;
int antiRecoilMaxX, antiRecoilMaxY;
int antiRecoilStepX, antiRecoilStepY;
// Author
const string author = "Swedemafia";
const string script = "Zeitgeist";
const string version = "Version 1.15";
// Assist/option activation flags
int assistFlags;
// (Controller) Button and Stick Layout
int button[10];
int stick[4];
// (Controller) Current ADS & Fire button values
int holdingADS, holdingFire;
// Display
int displayBuffer, displayBufferInsertCopyValue, displayBufferInsertNumberOfDigits;
int displayBufferInsertDigits[5];
int displayDepth, displayUpdate;
// Check Event variables
int checkEventChangeTime;
// Edit menu variables
int editMenuIndex;
int editMenuSelectedColumn, editMenuSelectedPage, editMenuSelectedRow;
int editMenuType, editMenuAdsType, editMenuVariable1, editMenuVariable2, editMenuParent, editMenuMinValue, editMenuMaxValue, editMenuAdsMinValue, editMenuAdsMaxValue;
// Loop iterators
int i, j;
// Mod menu variables
int modMenuIndex;
// Profiles
int currentProfile, menuProfile;
// (Options)
int fastMeleeEnabled, rapidFirePistols;
// (Screen saver)
int screenSaverEnabled, screenSaverCounter;
// (Screen saver) Script uptime
int uptimeCounter, uptimeDays, uptimeHours, uptimeMinutes, uptimeSeconds;
// Script paused
int vehicleMode, vehicleModeInCar, vehicleModeLeaning;
// (Settings) Smoothing
int forecast_x, forecast_y;
// User-defined configuration data
int userData[321];

enum {
	/* Aim Assist */
	vAimAssist, vAimAssistType = 3,
	vAimAssistAdsShape = 6, vAimAssistFireShape = 9,
	vAimAssistAdsRadius = 12, vAimAssistFireRadius = 15,
	vAimAssistAdsSpeed = 18, vAimAssistFireSpeed = 21,
	
	/* Rotation Assist */
	vRotationAssist = 24,
	//vRotationAssistType = 27, vRotationAssistThreshold = 30,
	vRotationAdsShape = 27, vRotationFireShape = 30,
	vRotationAdsRadius = 33, vRotationFireRadius = 36,
	vRotationAdsSpeed = 39, vRotationFireSpeed = 42,
	
	/* Inverse Assist */
	vInverseAssist = 45, vInverseAssistThreshold = 48,
	
	/* Idle Target Assist */
	vIdleTargetAssist = 51,
	vIdleTargetShape = 54, vIdleTargetTime = 57, vIdleTargetRadius = 60, vIdleTargetSpeed = 63,
	
	/* Motion Assist */
	vMotionAssist = 66,
	vMotionAdsShape = 69, vMotionFireShape = 72,
	vMotionAdsRadius = 75, vMotionFireRadius = 78,
	vMotionAdsSpeed = 81, vMotionFireSpeed = 84,
	
	/* Shape Pulse */
	vShapePulse = 87,
	vShapePulseAdsRadius = 90, vShapePulseFireRadius = 93,
	
	/* Shape Spin */
	vShapeSpin = 96,
	vShapeSpinAdsType = 99, vShapeSpinFireType = 102,
	vShapeSpinAdsAngle = 105, vShapeSpinFireAngle = 108,
	
	/* Anti-drift */
	vAntiDrift = 111, vAntiDriftLeft = 112, vAntiDriftRight = 116,
	
	/* Anti-recoil */
	vAntiRecoil = 120, vAntiRecoilStrength = 123,
	vAntiRecoilKickStrength = 126, vAntiRecoilKickDuration = 129,
	vAntiRecoilStart = 132, vAntiRecoilMid = 135, vAntiRecoilEnd = 138,
	vAntiRecoilStartH = 141, vAntiRecoilMidH = 144, vAntiRecoilEndH = 147,
	vAntiRecoilStartTime = 150, vAntiRecoilMidTime = 153,
	vAntiRecoilStartTimeH = 156, vAntiRecoilMidTimeH = 159,
	vAntiRecoilCategory = 162, vAntiRecoilWeapon = 165,
	vAntiRecoilCorrectionV = 168, vAntiRecoilCorrectionH = 196, // 28 each
	
	/* Controller */
	vControllerButtonLayout = 224, vControllerStickLayout = 225, vControllerBumperPing = 226,
	vControllerBumperTriggers = 227, vControllerAdsStickSwap = 228, vControllerSlideDive = 229,
	
	/* Options */
	vOptionAkimbo = 232, vOptionAkimboSpeed = 231,
	vOptionAutoAdsFire = 236,
	vOptionAutoFocus = 239, vOptionAutoFocusInterval = 242,
	vOptionAutoPing = 245, vOptionAutoPingInterval = 248,
	vOptionBackpackSwap = 249, vOptionBackpackSwapType = 250,
	vOptionBunnyHop = 251,
	vOptionDolphinCancel = 252,
	vOptionDropShot = 253, vOptionDropShotAimAdjust = 256,
	vOptionFastMelee = 259,
	vOptionGWalk = 262,
	vOptionHairTriggers = 263,
	vOptionRapidFire = 264, vOptionRapidFireSpeed = 267,
	vOptionRapidFirePistols = 270, vOptionRapidFirePistolsSpeed = 273,
	vOptionSlideCancel = 276, vOptionSlideCancelDelay = 277,
	vOptionTacticalSprint = 278,
	vOptionQuickScope = 279, vOptionQuickScopeDelay = 282,
	
	/* Profiles */
	vProfileColor = 285,
	
	/* Settings */
	vAimAccelerationReduction = 288, vAimAccelerationThreshold = 289, vBlockRumble = 290, vDeadzone = 291,
	vInverted = 293, vScreenSaver = 294, vSmoothing = 295, vVMSpeed = 296,
	vToggleButton = 297
}

// Menu Type
enum {
	menuNone,
	menuAntiDriftCalibrate,
	menuAntiRecoilExpert,
	menuAssistDualSelection, menuAssistRowSelection,
	menuCycleListOption,
	menuMultiSelection,
	menuToggle, menuToggleOnOff
}

// Menu Type ADS
enum {
	menuAdsNone,
	menuAdsAntiRecoilExpert, menuAdsAntiRecoilWeapon,
	menuAdsAssistDualSelection, menuAdsDualSelectionEdit,
	menuAdsAntiDriftCalibrate,
	menuAdsCycleEditValue, menuAdsCycleListOption,
	menuAdsMultiSelection,
	menuAdsToggle, menuWeaponSelectionEdit
}

// Menu Data IDs
enum { menuType, menuAdsType, menuVariable1, menuVariable2, menuParent, menuMinValue, menuMaxValue, menuAdsMinValue, menuAdsMaxValue }

const int16 menuData[][] = {
/* Menu ID		  Menu type (No ADS)		Menu type w/ ADS    		Value 1				Value 2					Parent value 		Min			Max						Ads Min		Ads Max
/* AA */ 		{ menuCycleListOption, 		menuAdsNone, 				vAimAssist, 		-1,						-1,					assistOff, 	assistAdsAndFireOrAds,	-1,			-1 },
/* AAType */ 	{ menuCycleListOption, 		menuAdsNone, 				vAimAssistType, 	-1, 					-1,					aat_mRadius, aat_pRadius,			-1,			-1 },
/* AAShape */	{ menuAssistDualSelection, 	menuAdsAssistDualSelection,	vAimAssistAdsShape, vAimAssistFireShape, 	vAimAssist,			aasCircle, 	aasEcstasy, 				aasCircle, 	aasEcstasy },
/* AARadius */	{ menuAssistRowSelection, 	menuAdsDualSelectionEdit,	vAimAssistAdsRadius,vAimAssistFireRadius, 	vAimAssist, 		1, 			100,					1,			100 },
/* AASpeed */	{ menuAssistRowSelection, 	menuAdsDualSelectionEdit,	vAimAssistAdsSpeed, vAimAssistFireSpeed, 	vAimAssist, 		1, 			100,					1,			100 },
	
/* RA */		{ menuCycleListOption,		menuAdsNone,				vRotationAssist,	-1						,-1,				assistOff,	assistAdsAndFireOrAds,	-1,			-1 },
/* RAShape */	{ menuAssistDualSelection,	menuAdsAssistDualSelection,	vRotationAdsShape,	vRotationFireShape,		vRotationAssist,	rasStrafe,	rasRandom, 				rasStrafe,	rasRandom },
/* RARadius*/	{ menuAssistRowSelection,	menuAdsDualSelectionEdit,	vRotationAdsRadius,	vRotationFireRadius,	vRotationAssist, 	1, 			100,					1,			100 },
/* RASpeed*/	{ menuAssistRowSelection,	menuAdsDualSelectionEdit,	vRotationAdsSpeed,	vRotationFireSpeed,		vRotationAssist,	1, 			120,					1,			120 },

/* IA */		{ menuCycleListOption,		menuAdsCycleEditValue,		vInverseAssist,		vInverseAssistThreshold,-1,					assistOff,	assistAdsAndFireOrAds,	0,			100 },

/* ITA */		{ menuToggle,				menuAdsNone,				vIdleTargetAssist,	-1,						-1,					assistOff, 	assistOn,				-1,			-1 },
/* ITShape */	{ menuCycleListOption,		menuAdsNone,				vIdleTargetShape,	-1,						-1,					aasCircle,	aasEcstasy,				-1,			-1  },
/* ITTime */	{ menuNone,					menuAdsCycleEditValue,		-1,					vIdleTargetTime,		-1,					-1,			-1,						0,			100 },
/* ITRadius */	{ menuNone,					menuAdsCycleEditValue,		-1,					vIdleTargetRadius,		-1,					-1,			-1,						1,			100 },
/* ITRSpeed */	{ menuNone,					menuAdsCycleEditValue,		-1,					vIdleTargetSpeed,		-1,					-1,			-1,						1,			100 },
	
/* MA */		{ menuCycleListOption,		menuAdsNone,				vMotionAssist,		-1,						-1,					assistOff, 	assistAdsAndFireOrAds,	-1,			-1 },
/* MAType */	{ menuAssistDualSelection,	menuAdsAssistDualSelection,	vMotionAdsShape,	vMotionFireShape,		vMotionAssist,		aasCircle,	aasHorizon,				aasCircle,	aasHorizon },
/* MARadius */	{ menuAssistRowSelection,	menuAdsDualSelectionEdit,	vMotionAdsRadius,	vMotionFireRadius,		vMotionAssist,		1,			100,					1,			100  },
/* MASpeed */	{ menuAssistRowSelection,	menuAdsDualSelectionEdit,	vMotionAdsSpeed,	vMotionFireSpeed,		vMotionAssist,		1,			100,					1,			100  },
	
/* SP */		{ menuCycleListOption,		menuAdsNone,				vShapePulse,		-1,						-1,					assistOff, 	assistAdsAndFireOrAds,	-1,			-1 },
/* SPRadius */	{ menuAssistRowSelection,	menuAdsDualSelectionEdit,	vShapePulseAdsRadius,vShapePulseFireRadius, vShapePulse,		1,			100,					1,			100 },
	
/* SS */		{ menuCycleListOption,		menuAdsNone,				vShapeSpin,			-1,						-1,					assistOff,	assistAdsAndFireOrAds,	-1,			-1 },
/* SSType */	{ menuAssistDualSelection,	menuAdsAssistDualSelection, vShapeSpinAdsType,	vShapeSpinFireType,		vShapeSpin,			spinOffset, spinSpinning,			spinOffset, spinSpinning },
/* SSAngle */	{ menuAssistRowSelection,	menuAdsDualSelectionEdit, 	vShapeSpinAdsAngle,	vShapeSpinFireAngle,	vShapeSpin,			1,			180,					1,			180 },
	
/* AD */		{ menuToggleOnOff,			menuAdsNone,				vAntiDrift,			-1,						-1,					-1,			-1,						-1,			-1 },
/* ADCal */		{ menuAntiDriftCalibrate,	menuAdsAntiDriftCalibrate,	-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* ADDT */		{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* ADDV */		{ menuNone,					menuAdsNone,				-1,					-1,						-1,					-1,			-1,						-1,			-1 },
	
/* AR */		{ menuCycleListOption,		menuAdsNone,				vAntiRecoil,		-1,						-1,					antiRecoilOff, antiRecoilWeapon,	-1,			-1 },
/* ARBasc */	{ menuNone,					menuAdsCycleEditValue,		-1,					vAntiRecoilStrength,	-1,					-1,			-1,						1,			100 },
/* ARAdvaKS */	{ menuNone,					menuAdsCycleEditValue,		-1,					vAntiRecoilKickStrength,-1,					-1,			-1,						1,			100 },
/* ARAdvaKD */	{ menuNone,					menuAdsCycleEditValue,		-1,					vAntiRecoilKickDuration,-1,					-1,			-1,						1,			200 },
/* ARExpert */	{ menuAntiRecoilExpert,		menuAdsAntiRecoilExpert,	-1,					-1,						-1,					-1,			-1,						-1,			-1 },
/* ARWeapon*/   { menuNone,					menuAdsAntiRecoilWeapon,	vAntiRecoilCategory,vAntiRecoilWeapon,		-1,					-1,			-1,						-1,			-1 },
/* ARWpnCorVal*/{ menuMultiSelection,		menuWeaponSelectionEdit,	vAntiRecoilCorrectionV,vAntiRecoilCorrectionH,-1,				0,			1,						-512,		512 },
	
/* BtnLayout*/	{ menuCycleListOption,		menuAdsNone,				vControllerButtonLayout, -1,				-1,					cblDefault, cblBumperPingTactical,	-1,			-1 },
/* BmpPing */	{ menuCycleListOption,		menuAdsNone,				vControllerBumperPing,	-1,					-1,					cbpDefault, cbpSwapped,				-1,			-1 },
/* BmprTrig*/	{ menuCycleListOption,		menuAdsNone,				vControllerBumperTriggers, -1,				-1,					cbtDefault, cbtFlipped,					-1,			-1 },
/* StckLayout*/	{ menuCycleListOption,		menuAdsNone,				vControllerStickLayout, -1,					-1,					slDefault, slLegacySouthpawNoClickSwap,	-1,			-1 },
/* AdsStckSwp*/	{ menuCycleListOption,		menuAdsNone,				vControllerAdsStickSwap, -1,				-1,					0,			1,							-1,			-1 },
/* InvtSldDve*/	{ menuCycleListOption,		menuAdsNone,				vControllerSlideDive, -1,					-1,					slideDiveStandard,	slideDiveInverted,	-1,			-1 },
	
/* Akimbo */	{ menuToggleOnOff,			menuAdsCycleEditValue,		vOptionAkimbo,		vOptionAkimboSpeed,		-1,					-1,			-1,						0,			60 },
/* AutoADSFire*/{ menuCycleListOption,		menuAdsNone,				vOptionAutoAdsFire,	-1,						-1,					autoADSFireOff, autoADSFireAutoFire, -1,		-1 },
/* AutoFocus */	{ menuToggleOnOff,			menuAdsCycleEditValue,		vOptionAutoFocus,	vOptionAutoFocusInterval,-1,				-1,			-1,						0,			8 },
/* AutoPing */	{ menuToggleOnOff,			menuAdsCycleEditValue,		vOptionAutoPing,	vOptionAutoPingInterval,-1,					-1,			-1,						0,			8 },
/* BckPckSwp*/	{ menuToggleOnOff,			menuAdsToggle,				vOptionBackpackSwap,vOptionBackpackSwapType,-1,					-1,			-1,						0,			1 },
/* BunnyHop*/	{ menuToggleOnOff,			menuAdsNone,				vOptionBunnyHop,	-1,						-1,					-1,			-1,						-1,			-1 },
/* DolpCncl*/	{ menuToggleOnOff,			menuAdsNone,				vOptionDolphinCancel,-1,					-1,					-1,			-1,						-1,			-1 },
/* DropShot */	{ menuToggleOnOff,			menuAdsCycleEditValue,		vOptionDropShot,	vOptionDropShotAimAdjust,-1,				-1,			-1,						0,			50 },
/* FastMelee*/	{ menuCycleListOption,		menuAdsNone,				vOptionFastMelee,	-1,						-1,					fastMeleeOff, fastMeleeToggle,		-1,			-1  },
/* G-Walk*/		{ menuCycleListOption,		menuAdsNone,				vOptionGWalk,		-1,						-1,					gWalkOff, gWalkReplace,				-1,			-1  },
/* HairTrig*/	{ menuToggleOnOff,			menuAdsNone,				vOptionHairTriggers,-1,						-1,					-1,			-1,						-1,			-1 },
/* RpdFire */	{ menuToggleOnOff,			menuAdsCycleEditValue,		vOptionRapidFire,	vOptionRapidFireSpeed,	-1,					-1,			-1,						1,			60 },
/* RpdFrPstl */	{ menuToggleOnOff,			menuAdsCycleEditValue,		vOptionRapidFirePistols,	vOptionRapidFirePistolsSpeed,	-1,	-1,			-1,						1,			60 },
/* SlideCncl */	{ menuCycleListOption,		menuAdsCycleEditValue,		vOptionSlideCancel,	vOptionSlideCancelDelay,-1,					slideCancelOff, slideCancelMW2,		1,			30 },
/* TactSprint*/	{ menuToggleOnOff,			menuAdsNone,				vOptionTacticalSprint,-1,					-1,					-1,			-1,						-1,			-1 },
/* QckScope */	{ menuToggleOnOff,			menuAdsCycleEditValue,		vOptionQuickScope,	vOptionQuickScopeDelay,	-1,					-1,			-1,						1,			50 },
	
/* ProBtns */	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* UniProf */	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* ProClrs */	{ menuMultiSelection,		menuAdsCycleListOption,		-1,					vProfileColor,			-1,					0,			2,						red,		pink },

/* AimAccel*/	//{ menuMultiSelection,		menuAdsMultiSelection,		-1,					vAimAccelerationReduction,-1,				0,			1,						1,			100 },
/* BlckRmbl*/	{ menuToggleOnOff,			menuAdsNone,				vBlockRumble,		-1,						-1,					-1,			-1,						-1,			-1 },
/* Deadzone*/	{ menuMultiSelection,		menuAdsMultiSelection,		-1,					vDeadzone,				-1,					0,			1,						0,			15 },
/* Inverted*/	{ menuToggleOnOff,			menuAdsNone,				vInverted,			-1,						-1,					-1,			-1,						-1,			-1 },
/* ScreenSvr*/	{ menuCycleListOption,		menuAdsNone,				vScreenSaver,		-1,						-1,					screenSaverOff,	screenSaverVisualizer, -1,		-1 },
/* Smoothing*/	{ menuToggleOnOff,			menuAdsNone,				vSmoothing,			-1,						-1,					-1,			-1,						-1,			-1 },
/* VMSpeed*/	{ menuCycleListOption,		menuAdsNone,				vVMSpeed,			-1,						-1,					vmSpeed4,	vmSpeed10,				-1,			-1 },

/* T-Akmbo*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-Auto*/		{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-AFocus*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-APing*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-BSwap*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-DShot */	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-FMelee*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-RpdFire */	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-TSprint*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 },
/* T-QScpe*/	{ menuMultiSelection,		menuAdsNone,				-1,					-1,						-1,					0,			1,						-1,			-1 }
}

/**************************************************************/
//	Enumerations
/**************************************************************/
// (Aim Assist) Aim Assist Type IDs
enum { aat_mRadius, aat_mSpeed, aat_mRadius_mSpeed, aat_mRadius_pSpeed, aatSteady, aat_pRadius_mSpeed, aat_pRadius_pSpeed, aat_pSpeed, aat_pRadius }
// (Aim Assist) Shape IDs
enum { aasCircle, aasOval, aasEllipse, aasLemniscate, aasDiamond, aasHorizon, aasRose, aasHeart, aasFlower, aasOrbit, aasSpiral, aasEcstasy }
// (Aim Assist) Rotation Shape IDs
enum { rasStrafe, rasCeorin, rasCircle, rasOval, rasEllipse, rasLemniscate, rasDiamond, rasRandom }
// (Aim Assist) Aim/Rotation/Idle Target Assist status IDs
enum { assistOff, assistAdsOnly, assistFireOnly, assistAdsAndFire, assistAdsOrFire, assistAdsAndFireOrFire, assistAdsAndFireOrAds, assistOn }
// (Aim Assist) Spin Type IDs
enum { spinOffset, spinSpinning }
// (Anti-drift) Calibration direction
enum { antiDriftUp, antiDriftDown, antiDriftLeft, antiDriftRight }
// (Anti-drift) Calibratoin stick
enum { antiDriftLeftStick, antiDriftRightStick }
// (Anti-recoil) Weapon categories ID
enum { antiRecoilCategoryAR, antiRecoilCategoryBR, antiRecoilCategorySMG, antiRecoilCategoryLMG }
// (Anti-recoil) Weapons ID
enum {
	/* Assault Rilfes */ 	M4, TAQ56, Kastov762, Lachmann556, STB_556, Kastov74u, Kastov545, Chimera, M13B, ISOHemlock,
	/* Battle Rifles */ 	Lachmann762, SO_14, TAQ_V, FTAC_RECON, 
	/* Sub-machine Guns */ 	VEL_46, MX9, LachmannSub, Vaznev9k, FSS_Hurricane, Minibak, BAS_P, PDSW528, Fennec,
	/* Light Machine Guns */ SAKINMG38, HCR_56, Icarus556, RAAL_MG, RPK, RAPP_H
}
// (Anti-recoil) Status IDs
enum { antiRecoilOff, antiRecoilBasic, antiRecoilAdvanced, antiRecoilExpert, antiRecoilWeapon }
// (Controller) Bumper/Triggers Flipped IDs
enum { cbtDefault, cbtFlipped }
// (Controller) Bumper Ping Swap IDs
enum { cbpDefault, cbpSwapped }
// (Controller) Button IDs
enum { ads, tactical, ping, focus, fire, lethal, weapon, action, jump, melee }
// (Controller) Button Layout IDs
enum {
	cblDefault, cblTactical, cblLefty, cblNomadCharlie, cblNomadCharlieTactical, cblNomadCharlieLefty, cblBumperJumper,
	cblBumperJumperTactical, cblOneHandGunslinger, cblStickAndMove, cblBrawler, cblBeast, cblBumperPing, cblBumperPingTactical
}
// (Controller) Stick layout IDs
enum { moveY, moveX, aimY, aimX }
// (Controller) Stick layout map IDs
enum { slDefault, slSouthpaw, slLegacy, slLegacySouthpaw, slSouthpawNoClickSwap, slLegacySouthpawNoClickSwap }
// (Controller) Invert slide/dive Behavior
enum { slideDiveStandard, slideDiveInverted }
// (Display) Formatting IDs
enum { displayString, displayNumber }
// (Display) Text formatting & alignment IDs
enum { alignCenter = -2, alignRight, alignLeft = 5, alignBottom = -1, alignTop = 5 }
// (Display) Home screen message IDs
enum { homeScriptName, homeScriptVersion }
// (Display) LED color IDs
enum { red, orange, gold, white, yellow, green, teal, blue, purple, pink }
// (Display) LED (HSB) IDs
enum { hue, saturation, brightness }
// (Menu) Cycle value IDs
enum { cycleValueUp, cycleValueDown }
// (Menu) Edit menu navigation & event IDs
enum { editMenuMin, editMenuMax, editMenuShowProfile }
// (Menu) Mod navigation
enum {
	// Table Lookup IDs
	modMenuPrevious, modMenuCurrent, modMenuNext,
	// Event IDs
	modMenuDown, modMenuUp,
	modMenuEnter, modMenuExit
}
// (Options) Auto ADS/Fire
enum { autoADSFireOff, autoADSFireAutoADS, autoADSFireAutoFire }
// (Options) Fast Melee
enum { fastMeleeOff, fastMeleeHold, fastMeleeToggle }
// (Options) G-Walk
enum { gWalkOff, gWalkSprint, gWalkReplace }
// (Options) Slide Cancel
enum { slideCancelOff, slideCancelMW, slideCancelMW2 }
// (Settings) Deadzone IDs
enum { deadzoneLeft, deadzoneRight }
// (Settings) Screen saver IDs
enum { screenSaverOff, screenSaverBlank, screenSaverUptime, screenSaverVisualizer }
// (Settings) VM speed IDs
enum { vmSpeed4, vmSpeed6, vmSpeed8, vmSpeed10 }
// (Toggle) Array IDs
enum {
	toggleProfile = 0,
	toggleUniversal = 2,
	// Options
	toggleAkimbo = 4,
	toggleAutoADS = 6,
	toggleAutoFocus = 8,
	toggleAutoPing = 10,
	toggleBackpackSwap = 12,
	toggleDropShot = 14,
	toggleFastMelee = 16,
	toggleRapidFire = 18,
	toggleTacticalSprint = 20,
	toggleQuickScope = 22
}
/**************************************************************/
//	Constants (strings)
/**************************************************************/
// (Aim Assist) Aim Assist Type
const string aimAssistTypeName[] = { "-Radius", "-Speed", "-Radius/-Speed", "-Radius/+Speed", "Constant", "+Radius/-Speed", "+Radius/+Speed", "+Speed", "+Radius" }
// (Aim Assist) Aim/Rotation/Idle Target Assist status
const string assistStatus[] = { "Off", "ADS Only", "Fire only", "ADS & Fire", "ADS or Fire", "ADS & Fire / Fire", "ADS & Fire / ADS", "On" }
// (Aim Assist) Shapes
const string aimAssistShapeName[] = { "Circle", "Oval", "Ellipse", "Lemniscate", "Diamond", "Horizon", "Rose", "Heart", "Flower", "Orbit", "Spiral", "Ecstasy" }
// (Aim Assist) Rotation Shape
const string aimAssistRotationShape[] = { "Strafe", "Ceorin", "Circle", "Oval", "Ellipse", "Lemniscate", "Diamond", "Random"  }
// (Aim Assist) Rotation Type
const string aimAssistRotationType[] = { "Stable", "Reactive", "Reactive ADS", "Reactive Fire" }
// (Aim Assist) Rotation Type Threshold
const string aimAssistRotationThreshold[] = { "Threshold: ", "none" }
// (Aim Assist) Idle Target Assist prompt
const string aimAssistIdleTarget = "Instant"
// (Aim Assist) Type prompt
const string aimAssistTypeMsg[] = { "ADS: ", "Fire: " }
// (Aim Assist) Shape Spinner
const string aimAssistSpinType[] = { "Offset", "Spinning" }
// (Anti-drift) Calibration direction
const string antiDriftCalibrationDirectionPrompt[] = { "Direction: Up", "Direction: Down", "Direction: Left", "Direction: Right" }
// (Anti-drift) Calibration prompt
const string antiDriftCalibrationResult[] = { "Failed", "Success", "Cancelled", "Reset Value" }
// (Anti-drift) Calibration state
const string antiDriftCalibrationStateMsg[] = { "Press A/Cross", "Waiting", "Release Joystick" }
// (Anti-drift) Calibration stick
const string antiDriftCalibrationStickPrompt[] = { "Joystick: Left", "Joystick: Right" }
// (Anti-drift) Values display
const string antiDriftValues[] = { "U: ", "D: ", "L: ", "R: " }
// (Anti-recoil) Anti-recoil Type
const string antiRecoilStatus[] = { "Off", "Basic", "Advanced", "Expert", "Weapon Select" }
// (Anti-recoil) Anti-recoil Expert Menu
const string antiRecoilExpertMenu[] = { "V-Beg: ", "V-Mid: ", "V-End: ", "H-Beg: ", "H-Mid: ", "H-End: " }
// (Anti-recoil) Weapon Select weapons
const string weaponName[] = {
	"M4", "TAQ-56", "Kastov 762", "Lachmann-556", "STB 556", "Kastov-74u", "Kastov 545", "Chimera", "M13B", "ISO Hemlock",
	"Lachmann-762", "SO-14", "TAQ-V", "FTAC Recon",
	"VEL 46", "MX9", "Lachmann Sub", "Vaznev-9k", "FSS Hurricane", "Minibak", "BAS-P", "PDSW 528", "Fennec 45",
	"Sakin MG38", "HCR 56", "556 Icarus", "RAAL MG", "RPK", "RAPP H"
}
// (Anti-recoil) Weapon Select categories
const string weaponCategory[] = { "Assault Rifles", "Battle Rifles", "Sub-machine Guns", "Light Machine Guns" }
// (Anti-recoil) Weapon Select correction
const string weaponSelectCorrection[] = { "V-Value: ", "H-Value: " }
// (Controller) Bumper/triggers Flipped status
const string flippedBumperTriggers[] = { "Default", "Flipped" }
// (Controller) Bumper Ping & ADS Stick Swap status
const string swappedStatus[] = { "Default", "Swapped" }
// (Controller) Button Layout names
const string buttonLayoutName[] = {
	"Default", "Tactical", "Lefty",
	"N0M4D/Charlie", "N0M4D/Charlie Tact", "N0M4D/Charlie L3F7",
	"Bumper Jumper", "Bumper Jumper Tact", "OneHand Gunslinger",
	"Stick and Move", "Brawler", "Beast", "Bumper Ping",
	"Bumper Ping Tac"
}

// (Controller) Button names [PlayStation]
const string controllerButtonsPS4[] = { "not set", "", "", "R1", "R2", "", "L1", "L2", "", "", "", "", "", "Up", "Down", "Left", "Right", "Triangle", "Circle", "Cross", "Square" }
// (Controller) Button names [XBOX]
const string controllerButtonsXBOX[] = { "not set", "", "", "RB", "RT", "", "LB", "LT", "", "", "", "", "", "Up", "Down", "Left", "Right", "Y", "B", "A", "X" }
// (Controller) Stick Layout names
const string stickLayoutName[] = { "Default", "Southpaw", "Legacy", "Legacy Southpaw", "Southpaw NCS", "Legacy SP NCS" }
// (Controller) Invert slide/dive behavior
const string invertSlideDive[] = { "Standard", "Inverted" }
// (Display) Greeting
const string zeitgeist[] = { "ZEITGEIST" };
// (Display) LED color names
const string colorName[] = { "Red", "Orange", "Gold", "White", "Yellow", "Green", "Teal", "Blue", "Purple", "Pink" }
// (Display) On/off Toggle
const string toggleOffOn[] = { "Off", "On" }
// (Display) Script paused notification
const string vehicleModeMsg[] = {  "Paused / Vehicle", "Leaning / Vehicle" }
// (Options) Akimbo Fire Mode
const string akimboAuto = "Full Automatic";
// (Options) Auto Focus
const string autoFocus[] = { "Delay: ", "Instant" }
// (Options) Auto ADS/Fire
const string autoADSFireType[] = { "Off", "ADS on Fire", "Fire on ADS" }
// (Options) Auto Ping
const string autoPing[] = { "Interval: ", "Ping Once on Fire" }
// (Options) Backpack Swap
const string backpackSwap[] = { "Double Tap Swap", "Use Toggle" }
// (Options) Drop Shot Aim Adjust
const string dropShotAimAdjust = "Aim Adjust: "
// (Options) Fast Melee
const string fastMeleeType[] = { "Off", "Hold", "Toggle" }
// (Options) Fire Speed
const string fireSpeed = "Shots/Second: "
// (Options) G-Walk
const string gWalkType[] = { "Off", "Sprint Button", "Replace Slide", "Replace Dive" }
// (Options) Slide Cancel 
const string slideCancel[] = { "Off", "MW 2019", "MW2" }
// (Options) Slide Cancel Delay
const string slideDelay = "Slide Delay: "
// (Options) Quick Scope Delay
const string quickScopeDelay = "Fire Delay: "
// (Profiles) Profile toggle/color prompts
const string profileToggleMsg[] = {
	"Resync: ", "Switch: ", // Profile Switch
	"Button 1: ", "Button 2: ", // Universal Switch
	"Primary:   ", "Secondary: ", "Universal: " // Profile Colors
}
// (Profiles) Profile names
const string profileName[] = { "Primary", "Secondary", "Universal", "All Profiles" }
// (Controller) Aim Acceleration
const string aimAcceleration[] = { "Reduction: ", "Threshold: " }
// (Settings) Deadzone prompt
const string stickName[] = { "Left: ", "Right: " }
// (Settings) Screen saver names
const string screenSaver[] = { "Off", "Blank", "Uptime", "Visualizer" }
// (Settings) VM speed display
const string vmSpeed[] = { "4ms", "6ms", "8ms", "Default (10ms)" }
// (Settings) Settings saved notification
const string settingsSaved = "Settings Saved";
// (Toggles) Toggle combo messages
const string toggleMessages[] = { "Akimbo: ", "Auto ADS/Fire: ", "Auto Focus: ", "Auto Ping: ", "Drop Shot: ", "Fast Melee: ", "Rapid Fire: ", "Tact. Sprint: ", "Quick Scope: " }
// (Toggles) Reset Message
const string toggleReset[] = {  "Reset: Hold Share", "Reset: Hold View" }

/**************************************************************/
//	Constants (integers)
/**************************************************************/
// (Anti-recoil) Weapon Recoil data
const int16 weaponData[][] = {
	/* M4 */ { 9, 4 },
		/* 30 round (2200) */ { 0, 250 }, { -5, 250 }, { 12, 500 }, { -3, 1200 },
		/* 45 Round (3300) */ { -4, 700 }, { -3, 200 }, { 0, 200 },
		/* 60 Round (4410) */ { 4, 400 }, { 0, 710 },
		/* Vertical */ { 34, 1100 }, { 22, 2200 }, { 30, 500 }, { 31, 610 },
	/* TAQ_56 */ { 7, 4 },
		/* 30 Round (2800) */ { 0, 1250 }, { -10, 750 }, { -1, 800 },
		/* 40 Round (3800) */ { -1, 1000},
		/* 60 Round (5700) */ { -10, 700}, { -1, 700}, { -5, 700},
		/* Vertical */ { 27, 1000 }, { 19, 750 }, { 18, 2050 }, { 20, 2100 },
	/* Kastov762 */ { 7, 5 },
		/* 20 Round (1900) */ { -5, 500 }, { -7, 500 }, { -12, 100 }, { -10, 700 }, { -5, 200 },
		/* 30 Round (3000) */ { -3, 1000 },
		/* 40 Round (4000) */ { -4, 1000 },
		/* Vertical */ { 30, 1200 }, { 28, 400 }, { 25, 300 }, { 24, 1100 }, { 27, 1000 },
	/* Lachmann556 */ { 9, 6 },
		/* 15 Round Mag (1250) */ { 0, 1250 },
		/* 30 Round Mag (2500) */ { 0, 1250 }, { -16, 500 }, { -17, 250 }, { -8, 350 }, { 0, 150 },
		/* 40 Round Mag (3300) */ { 19, 500 }, { 0, 300 },
		/* 60 Round Mag (5000) */ { 8, 1700 },
		/* Vertical */ { 37, 600 }, { 28, 650 }, { 8, 650 }, { 6, 600 }, { 5, 800 }, { 9, 1700 },
	/* STB 556 */ { 4, 3 },
		/* 30 Round Mag (2500) */ { 0, 1000 }, { -10, 1500 },
		/* 42 Round Mag (3350) */ { -6, 650 }, { -2, 200 },
		/* Vertical */ { 30, 1000 }, { 12, 1500 }, { 10, 850 },
	/* Kastov 74u */ { 5, 5 },
		/* 20 Round Mag (1900) */ { 0, 400 }, { -3, 700 }, { -6, 800 },
		/* 30 Round Mag (2800) */ { -4, 900 },
		/* 45 Round Mag (4100) */ { -0, 1300 },
		/* Vertical */ { 34, 400 }, { 30, 700 }, { 22, 800 }, { 12, 900 }, { 15, 1300 },
	/* Kastov 545 */ { 6, 7 },
		/* 20 Round Mag (1900) */ { -9, 600 }, { -10, 1300 },
		/* 30 Round Mag (2800) */ { -8, 900 },
		/* 45 Round Mag (4100) */ { -7, 1300 },
		/* 60 Round Mag (5600) */ { -2, 1000 }, { 0, 500 },
		/* Vertical */ { 23, 300 }, { 30, 300 }, { 14, 1300 }, { 12, 900 }, { 13, 1300 }, { 13, 1000 }, { 16, 1500 },
	/* Chimera */ { 6, 5 },
		/* 20 Round Mag (1400) */ { 0, 500 }, { 2, 400 }, { 6, 500 },
		/* 30 Round Mag (2100) */ { 12, 400 }, { 16, 300 },
		/* 45 Round Mag (3500) */ { 7, 1400 },
		/* Vertical */ { 44, 500 }, { 29, 400 }, { 16, 500 }, { 12, 700 }, { 18, 1400 },
	/* M13B */ { 6, 3 },
		/* 30 Round Mag (2200) */ { 0, 1200 }, { 8, 500 }, { 10, 300 }, { 6, 200 },
		/* 45 Round Mag (3300) */ { 8, 1100 },
		/* 60 Round Mag (4400) */ { 2, 1100 },
		/* Vertical */ 	{ 33, 500 }, { 32, 1700 }, { 30, 2200 },
	/* ISO Hemlock */ { 2, 4 },
		/* 30 Round Mag (3000) */ { -6, 3000 },
		/* 45 Round Mag (4500) */ { -6, 1500 },
		/* Vertical */ { 22, 800 }, { 23, 800 }, { 16, 1400 }, { 14, 1500 },
	/* Lachmann 762 */ { 6, 9 },
		/* 10 Round Mag (1000) */ { -5, 1000 },
		/* 15 Round Mag (1500) */ { 5, 500 },
		/* 20 Round Mag (2000) */ { -6, 500 },
		/* 30 Round Mag (3000) */ { -8, 500 },
		/* 50 Round Mag (5000) */ { -6, 1000 }, { -3, 1000 },
		/* Vertical */ { 46, 200 }, { 43, 800 }, { 44, 500 }, { 45, 500 }, { 46, 500 }, { 45, 500 }, { 46, 500 }, { 47, 500 }, { 49, 500 },
	/* SO-14 */ { 4, 5 },
		/* 20 Round Mag (1700) */ { -5, 1500 }, { -8, 200 },
		/* 25 Round Mag (2100) */ { -7, 400 },
		/* 50 Round Mag (4200) */ { -3, 2100 },
		/* Vertical */ { 56, 200 }, { 40, 1200 }, { 35, 300 }, { 32, 400 }, { 36, 2100 },
	/* TAQ-V */ { 4, 6 },
		/* 20 Round Mag (2200) */ { 0, 2200 },
		/* 30 Round Mag (3100) */ { 0, 900 },
		/* 50 Round Mag (5300) */ { -2, 1700 }, { -5, 500 },
		/* Vertical */ { 48, 500 }, { 30, 1300 }, { 24, 400 }, { 26, 900 }, { 37, 1700 }, { 26, 500 },
	/* FTAC RECON */ { 3, 4 },
		/* 5 Round Mag */ { -5, 600 },
		/* 10 Round Mag */ { 14, 600 },
		/* 15 Round Mag */ { 13, 600 },
		/* Vertical */ { 50, 600 }, { 35, 600 }, { 36, 300 }, { 33, 300 },
	/* VEL 46 */ { 4, 3 },
		/* 30 Round Mag (2000) */ { 0, 2000 },
		/* 40 Round Mag (2600) */ { 0, 600 },
		/* 50 Round Mag (3200) */ { -1, 600 },
		/* 60 Round Mag (3800) */ { -1, 600 },
		/* Vertical */ { 31, 2000 }, { 33, 600 }, { 35, 1200 },
	/* MX-9 */ { 4, 4 },
		/* 25 Round Mag (2000) */ { 0, 1200 }, { -10, 400 }, { -11, 400 },
		/* 32 Round Mag (2700 */ { -2, 700 },
		/* Vertical */ { 30, 800 }, { 9, 1000 }, { 20, 200 }, { 28, 700 },
	/* Lachmann Sub */ { 6, 5 },
		/* 15 Round Mag (1100) */ { 0, 800 }, { -10, 300 },
		/* 30 Round Mag (2200) */ { -5, 500 }, { 6, 600 },
		/* 40 Round Mag (3100) */ { 9, 900 },
		/* 50 Round Mag (3800) */ { -2, 700 },
		/* Vertical */ { 37, 200 }, { 26, 900 }, { 26, 1100 }, { 23, 900 }, { 33, 700 },
	/* Vaznev 9k */ { 5, 5 },
		/* 30 Round Mag (2400) */ { 0, 1100 }, { -10, 900 }, { -8, 400 },
		/* 45 Round Mag (3500) */ { -6, 200 }, { 9, 900 },
		/* Vertical */ { 30, 700 }, { 12, 1100 }, { 18, 600 }, { 18, 700 }, { 17, 400 },
	/* FSS Hurricane */ { 6, 4 },
		/* 50 Round Mag (4300) */ { 0, 300 }, { -10, 200 }, { -5, 300 }, { 8, 500 }, { 0, 2400 }, { 4, 600 },
		/* Vertical */ { 30, 500 }, { 19, 800 }, { 18, 2500 }, { 26, 500 },
	/* Minibak */ { 4, 3 },
		/* 64 Round Mag (6000) */ { 0, 500 }, { -3, 400 }, { -10, 600 }, { -2, 4500 },
		/* Vertical */ { 30, 700 }, { 13, 1400 }, { 19, 3900 },
	/* BAS-P */ { 6, 4 },
		/* 20 Round Mag (1400) */ { 0, 100 }, { -8, 500 }, { 4, 800 },
		/* 30 Round Mag (2100) */ { -5, 500 }, { -8, 200 },
		/* 50 Round Mag (3600) */ { -4, 1500 },
		/* Vertical */ { 29, 1000 }, { 26, 400 }, { 25, 700 }, { 28, 1500 },
	/* PDSW 528 */ { 2, 2 },
		/* 50 Round Mag (3400) */ { 0, 2500 }, { 1, 900 },
		/* Vertical */ { 32, 2500 }, { 30, 900 },
	/* Fennec */ { 2, 2 },
		/* 30 Round Mag (1700) */ { 0, 1700 },
		/* 45 Round Mag (2500) */ { 1, 800 },
		/* Vertical */ { 35, 700 }, { 23, 1800 },
	/* Sakin MG38 */ { 6, 5 },
		/* 100 Round Mag (9300) */ { 3, 2000 }, { 7, 2700 }, { -3, 2600 },
		/* 125 Round Mag (11600) */ { 8, 1200 }, { 7, 1100 },
		/* 150 Round Mag (13900) */ { 5, 2300 },
		/* Vertical */ { 20, 2200 }, { 2, 4100 }, { 8, 1200 }, { 27, 900 }, { 11, 5500 },
	/* HCR 56 */ { 7, 2 },
		/* 30 Round Mag (2400) */ { 0, 500 }, { 8, 700 }, { -5, 1200 },
		/* 42 Round Mag (3500) */ { 0, 1100 },
		/* 60 Round Mag (4900) */ { 1, 700 }, { 3, 700 },
		/* 100 Round Mag (8300) */ { 0, 3400 },
		/* Vertical */ { 30, 2000 }, { 27, 6300 },
	/* Icarus 556 */ { 6, 6 }, 
		/* 75 Round Mag (5800) */ { 0, 800 }, { -14, 2100 }, { -6, 2900 },
		/* 100 Round Mag (7800) */ { -11, 800 }, { -18, 400 }, { -8, 800 },
		/* Vertical */ { 30, 800 }, { 20, 2500 }, { 17, 2500 }, { 23, 800 }, { 25, 400 }, { 28, 800 },
	/* RAAL MG */ { 6, 3 },
		/* 50 Round Mag (5500) */ { 0, 1000 }, { -9, 1600 }, { 5, 500 }, { -1, 2400 },
		/* 75 Round Mag (8200) */ { -1, 2700 },
		/* 100 Round Mag (10900) */ { -1, 2700 },
		/* Vertical */ { 35, 500 }, { 26, 1600 }, { 25, 8800 },
	/* RPK */ { 10, 8 },
		/* 30 Round Mag (3100) */ { -5, 500 }, { 1, 1500 }, { 6, 1100 },
		/* 40 Round Mag (4000) */ { 3, 200 }, { 5, 700 },
		/* 75 Round Mag (7600) */ { 5, 1000 }, { 6, 1400 }, { 4, 1200 },
		/* 100 Round Mag (10100) */ { -3, 1800 }, { 4, 700 },
		/* Vertical */ { 25, 500 }, { 20, 2600 }, { 12, 900 }, { 12, 2000 }, { 15, 800 }, { 22, 800 }, { 20, 2000 }, { 17, 500 },
	/* RAPP H */ { 6, 3 },
		/* 75 Round Mag (5600) */ { 0, 1000 }, { -6, 1600 }, { -6, 2400 }, { -7, 600 },
		/* 100 Round Mag (7600) */ { -7, 1500 }, { -5, 500 },
		/* Vertical */ { 30, 1000 }, { 22, 4000 }, { 23, 2600 }
}

// (Anti-recoil) Weapon ID lookup indexes
const int16 weaponIndex[] = {
	/* Assault Rilfes */ 	0, 14, 26, 39, 55, 63, 74, 88, 100, 110,
	/* Battle Rifles */ 	117, 133, 143, 154,
	/* Sub-machine Guns */ 	162, 170, 179, 191, 202, 213, 221, 232, 237,
	/* Light Machine Guns */ 242, 254, 264, 277, 287, 306
}
// (Anti-recoil) Weapon Select Menu
const int16 weaponSelectCategoryMenu[][] = {
	/* Assault Rilfes */ 	{ M4, ISOHemlock },
	/* Battle Rifles */ 	{ Lachmann762, FTAC_RECON },
	/* Sub-machine Guns */ 	{ VEL_46, Fennec },
	/* Light Machine Guns */ { SAKINMG38, RAPP_H }
}

// (Controller) Available toggle buttons
const int8 controllerButtons[] = { XB1_VIEW, XB1_RB, XB1_RT, XB1_LB, XB1_LT, XB1_UP, XB1_DOWN, XB1_LEFT, XB1_RIGHT, XB1_Y, XB1_B, XB1_A, XB1_X }

// (Controller) Button Layout map
const int8 buttonLayoutMap[][] = {
	// ADS	  Tact	  Ping	  Focus	  Fire	  Lethal  Switch Action Jump	Melee
	{ XB1_LT, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_B, XB1_A, XB1_RS }, // Default
	{ XB1_LT, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_RS, XB1_A, XB1_B }, // Tactical
	{ XB1_RT, XB1_RB, XB1_UP, XB1_RS, XB1_LT, XB1_LB, XB1_Y, XB1_B, XB1_A, XB1_LS }, // Lefty
	{ XB1_RB, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_LT, XB1_Y, XB1_B, XB1_A, XB1_RS }, // Nomad/Charlie
	{ XB1_RB, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_LT, XB1_Y, XB1_RS, XB1_A, XB1_B }, // Nomad/Charlie Tac
	{ XB1_LB, XB1_RB, XB1_UP, XB1_RS, XB1_LT, XB1_RT, XB1_Y, XB1_B, XB1_A, XB1_LS }, // Nomad/Charlie Left
	{ XB1_LT, XB1_A, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_B, XB1_LB, XB1_RS }, // Bumper Jumper
	{ XB1_LT, XB1_A, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_RS, XB1_LB, XB1_B }, // Bumper Jumper Tact
	{ XB1_LT, XB1_RB, XB1_UP, XB1_LS, XB1_LB, XB1_RT, XB1_Y, XB1_B, XB1_A, XB1_RS }, // One-hand Gunslinger
	{ XB1_LT, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_B, XB1_RS, XB1_A }, // Stick and Move
	{ XB1_LT, XB1_LB, XB1_UP, XB1_LS, XB1_RT, XB1_RS, XB1_Y, XB1_B, XB1_A, XB1_RB }, // Brawler
	{ XB1_LT, XB1_A, XB1_UP, XB1_LS, XB1_RT, XB1_RS, XB1_Y, XB1_B, XB1_LB, XB1_RB }, // Beast
	{ XB1_LT, XB1_RB, XB1_LB, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_B, XB1_A, XB1_RS }, // Bumper Ping
	{ XB1_LT, XB1_RB, XB1_LB, XB1_LS, XB1_RT, XB1_RB, XB1_Y, XB1_RS, XB1_A, XB1_B }  // Bumper Ping Tactical
}

// (Controller) Stick Layout map
const int8 stickLayoutMap[][] = {
	// Move   	Strafe  	Look    Rotate    
	{ POLAR_LY, POLAR_LX, POLAR_RY, POLAR_RX }, // Default
	{ POLAR_RY, POLAR_RX, POLAR_LY, POLAR_LX }, // Southpaw
	{ POLAR_LY, POLAR_RX, POLAR_RY, POLAR_LX }, // Legacy
	{ POLAR_RY, POLAR_LX, POLAR_LY, POLAR_RX }, // Legacy Southpaw
	{ POLAR_RY, POLAR_RX, POLAR_LY, POLAR_LX }, // Southpaw No Click Swap
	{ POLAR_RY, POLAR_LX, POLAR_LY, POLAR_RX }  // Legacy Southpaw No Click Swap
}

// (Display) HSB color values
const int16 colorValues[][] = {
	{ 0, 100, 75 }, // Red
	{ 10, 100, 75 }, // Orange
	{ 17, 100, 100 }, // Gold
	{ 20, 50, 100 }, // White
	{ 30, 100, 100 }, // Yellow
	{ 120, 100, 75 }, // Green
	{ 135, 100, 75 }, // Teal
	{ 200, 100, 50 }, // Blue
	{ 300, 100, 50 }, // Purple
	{ 359, 50, 75 } // Pink
}
// (Display) Menu action buttons
const uint8 menuButtons[] = { 
	XB1_UP, XB1_DOWN, XB1_LEFT, XB1_RIGHT, XB1_A, XB1_B, XB1_RB, XB1_LB, XB1_VIEW
}
// (Display) Line numbers for OLED_FONT_SMALL
const int8 lineNumber[] = { 22, 34, 46 }
// (Display) Font height
const int8 fontHeight[] = { OLED_FONT_SMALL_HEIGHT, OLED_FONT_MEDIUM_HEIGHT, OLED_FONT_LARGE_HEIGHT }
// (Display) Font width
const int8 fontWidth[] = { OLED_FONT_SMALL_WIDTH, OLED_FONT_MEDIUM_WIDTH, OLED_FONT_LARGE_WIDTH }
// (Setings) VM Speed
const int8 vmSpeedValue[] = { -6, -4, -2, 0 }

/**************************************************************/
//	Menus
/**************************************************************/
// (Menu) Edit menu names
const string editMenuNames[] = {
	/* Aim Assist */			"Aim Assist", "Aim Assist Type", "Aim Assist Shape", "Aim Assist Radius", "Aim Assist Speed",
	/* Rotation Assist */		"Rotation Assist", /*"Rotation Type",*/ "Rotation Shape", "Rotation Radius", "Rotation Speed",
	/* Inverse Assist */		"Inverse Assist",
	/* Idle Target Assist */	"Idle Target Assist", "Idle Target Shape", "Idle Target Time", "Idle Target Radius", "Idle Target Speed",
	/* Motion Assist */			"Motion Assist", "Motion Shape", "Motion Radius", "Motion Speed",
	/* Shape Pulse */			"Shape Pulse", "Pulse Radius",
	/* Shape Spin */			"Shape Spin", "Spin Type", "Spin Angle",
	//
	// Anti-drift
	"Anti-drift", "Calibration", "Drift Test", "Drift Values",
	// Anti-recoil
	"Anti-recoil",
	/* Basic */					"Strength",
	/* Advanced */				"Kick Strength", "Kick Duration",
	/* Expert */				"Expert Settings",
	/* Weapon */				"Weapon Select", "Correction Value",
	//
	// Controller
	"Button Layout", "Bumper Ping", "Bumper/Triggers", "Stick Layout", "ADS Stick Swap", "Invert Slide/Dive",
	// Options
	"Akimbo", "Auto ADS/Fire", "Auto Focus", "Auto Ping", "Backpack Swap", "Bunny Hop", "Dolphin Cancel", "Drop Shot",
	"Fast Melee", "G-Walk", "Hair Triggers", "Rapid Fire", "Rapid Fire Pistols", "Slide Cancel", "Tactical Sprint", "Quick Scope",
	// Profiles
	"Profile Buttons", "Universal Profile", "Profile Colors",
	// Settings
	/*"Aim Acceleration",*/ "Block Rumble", "Deadzone", "Inverted", "Screen Saver", "Smoothing", "VM Speed",
	// Toggles
	"Akimbo", "Auto ADS/Fire", "Auto Focus", "Auto Ping", "Backpack Swap", "Drop Shot", "Fast Melee", "Rapid Fire", "Tactical Sprint", "Quick Scope"
}

// (Menu) Edit menu IDs
enum {
	// Aim Assist
	editMenuAimAssist, editMenuAimAssistBoost, editMenuAimAssistShape, editMenuAimAssistRadius, editMenuAimAssistSpeed,
	/* Rotation Assist  */	editMenuRotationAssist, /*editMenuRotationType,*/ editMenuRotationShape, editMenuRotationRadius, editMenuRotationSpeed,
	/* Inverse Assist */	editMenuInverseAssist,
	/* Idle Target */		editMenuIdleTargetAssist, editMenuIdleTargetShape, editMenuIdleTargetTime, editMenuIdleTargetRadius, editMenuIdleTargetSpeed,
	/* Shape Motion */		editMenuMotionAssist, editMenuMotionShape, editMenuMotionRadius, editMenuMotionSpeed,
	/* Shape Pulse */		editMenuShapePulse, editMenuShapePulseRadius,
	/* Shape Spin */		editMenuShapeSpin, editMenuShapeSpinType, editMenuShapeSpinAngle,
	//
	// Anti-drift
	editMenuAntidrift, editMenuAntidriftCalibration, editMenuAntidriftTest, editMenuAntidriftValues,
	// Anti-recoil
	editMenuAntiRecoil,
	/* Basic */ 			editMenuAntiRecoilStrength,
	/* Advanced */			editMenuAntiRecoilKickStrength, editMenuAntiRecoilKickCounter,
	/* Expert */			editMenuAntiRecoilExpert,
	/* Weapon */			editMenuAntiRecoilWeapon, editMenuAntiRecoilWeaponCorrectionValue,
	//
	// Controller
	editMenuControllerButtonLayout, editMenuControllerBumperPing, editMenuControllerBumperTriggers, editMenuControllerStickLayout,
	editMenuControllerAdsStickSwap, editMenuControllerSlideDiveBehavior,
	// Options
	editMenuAkimbo, editMenuAutoADS, editMenuAutoFocus, editMenuAutoPing, editMenuBackpackSwap, editMenuBunnyHop, editMenuDolphinCancel, editMenuDropShot,
	editMenuFastMelee, editMenuGWalk, editMenuHairTriggers, editMenuRapidFire, editMenuRapidFirePistols, editMenuSlideCancel, editMenuTacticalSprint, editMenuQuickScope,
	// Profiles
	editMenuProfileSwitch, editMenuUniversalSwitch, editMenuProfileColors,
	// Settings
	/*editMenuAimAcceleration,*/ editMenuBlockRumble, editMenuDeadzone, editMenuInverted, editMenuScreenSaver, editMenuSmoothing, editMenuVMSpeed,
	// Toggles
	editMenuToggleAkimbo, editMenuToggleAutoADS, editMenuToggleAutoFocus, editMenuToggleAutoPing, editMenuToggleBackpackSwap, editMenuToggleDropShot,
	editMenuToggleFastMelee, editMenuToggleRapidFire, editMenuToggleTacticalSprint, editMenuToggleQuickScope
}

// (Display) Edit menu items
const int8 editMenuItems[][] = {
	  // Menu			Head							Tail										Show Profile
	{ /* Aim Assist */ 	editMenuAimAssist, 				editMenuShapeSpinAngle, 					TRUE },
	{ /* Anti-drift */ 	editMenuAntidrift, 				editMenuAntidriftValues, 					FALSE },
	{ /* Anti-recoil */ editMenuAntiRecoil, 			editMenuAntiRecoilWeaponCorrectionValue,	TRUE },
	{ /* Controller */	editMenuControllerButtonLayout, editMenuControllerSlideDiveBehavior, 		FALSE },
	{ /* Options */		editMenuAkimbo, 				editMenuQuickScope, 						TRUE },
	{ /* Profiles */	editMenuProfileSwitch, 			editMenuProfileColors, 						FALSE },
	{ /* Settings */	editMenuBlockRumble, 			editMenuVMSpeed, 							FALSE },
	{ /* Toggles */		editMenuToggleAkimbo, 			editMenuToggleQuickScope, 					FALSE }
}

// (Menu) Mod menu names
const string modMenuNames[] = { "Aim Assist", "Anti-drift", "Anti-recoil", "Controller", "Options", "Profiles", "Settings", "Toggles" }

// (Menu) Mod menu IDs
enum { modMenuAimAssist, modMenuAntidrift, modMenuAntiRecoil, modMenuController, modMenuOptions, modMenuProfiles, modMenuSettings, modMenuToggles }

// (Display) Mod menu items
const int8 modMenuItems[][] = {
	  // Menu			Previous			Data				Next
	{ /* Aim Assist */	modMenuToggles, 	modMenuAimAssist, 	modMenuAntidrift },
	{ /* Anti-drift */	modMenuAimAssist, 	modMenuAntidrift, 	modMenuAntiRecoil },
	{ /* Anti-recoil */	modMenuAntidrift, 	modMenuAntiRecoil, 	modMenuController },
	{ /* Controller */	modMenuAntiRecoil, 	modMenuController, 	modMenuOptions },
	{ /* Options */		modMenuController, 	modMenuOptions, 	modMenuProfiles },
	{ /* Profiles */	modMenuOptions, 	modMenuProfiles, 	modMenuSettings },
	{ /* Settings */	modMenuProfiles, 	modMenuSettings, 	modMenuToggles },
	{ /* Toggles */		modMenuSettings, 	modMenuToggles,	 	modMenuAimAssist }
}

/**************************************************************/
//	Begin script
/**************************************************************/
init {
	// Initialize menu min/max
	aimAssistShapeMin = aasCircle;
	aimAssistShapeMax = aasEcstasy;
	
	displayBuffer = 1; // Initialize display buffer
	loadSettings(); // Load user-defined settings
	combo_run(cboGreeting); // Run greeting
}

main {
	calculateUptime(); // Calculate uptime
	if(!displayDepth && !combo_running(cboGreeting)) { // Home screen
		swapPS4(); // Fix PS4 issue
		if(!checkPause() || (vehicleModeInCar && vehicleModeLeaning)) { // Do not do anything if any specific combos are running
			if(!checkCombos() && !vehicleModeInCar) {
				// Check for Screen Saver, otherwise display Home Screen
				if(!screenSaverEnabled) {
					if(!screenSaverCounter) {
						displayHomeScreen(); // Display Home Screen
						vm_tctrl(vmSpeedValue[userData[vVMSpeed]]); // Set VM speed
						screenSaverCounter = 1; // Prevent from constant update
					} else if(screenSaverCounter >= 2000) {
						screenSaverEnabled = TRUE; // Enable Screen Saver
						cls_oled(OLED_BLACK); // Clear screen
					}
					if(userData[vScreenSaver] != screenSaverOff) {
						screenSaverCounter += get_rtime(); // Increase Screen Saver counter
					}
				} else if(userData[vScreenSaver] != screenSaverVisualizer) {
					displayScreenSaver(); // Display Screen Saver
				}
				
				// Check for menu action
				if(get_ival(button[ads]) && !antiRecoilQuickEdit && !combo_running(cboSwitchProfile)) {
					// Determine menu to enter, if any
					if(event_press(XB1_MENU)) {
						displayDepth = 1; // Set display depth
						displayUpdate = TRUE; // Enable update
						screenSaverCounter = 0; // Reset Screen Saver
						screenSaverEnabled = FALSE; // Make sure Screen Saver is diabled
						menuProfile = currentProfile; // Set current profile
					} else if(event_press(XB1_VIEW)) {
						displayDepth = 2; // Set display depth
						displayUpdate = TRUE;// Enable update
						screenSaverCounter = 0; // Reset Screen Saver
						screenSaverEnabled = FALSE; // Make sure Screen Saver is disabled
						antiRecoilQuickEdit = TRUE; // Enable Anti-recoil Quick Edit
						modMenuIndex = modMenuAntiRecoil; // Set mod menu ID
						menuProfile = currentProfile; // Set current profile
						
						// Determine menu to show based on being enabled or not
						if(!userData[vAntiRecoil + menuProfile]) {
							editMenuIndex = editMenuAntiRecoil;
						} else if(userData[vAntiRecoil + menuProfile] < antiRecoilExpert) {
							editMenuIndex = editMenuAntiRecoilStrength;
						} else if(userData[vAntiRecoil + menuProfile] == antiRecoilExpert) {
							editMenuIndex = editMenuAntiRecoilExpert;
						} else {
							editMenuIndex = editMenuAntiRecoilWeapon;
						}
					}
				}
			}
			
			// Remove drift and apply deadzone if calibration is not running
			if(!antiDriftCalibrationState) {
				removeDriftAndApplyDeadzone(); // Remove stick drift and apply deadzone
				applySmoothing(); // Apply Exponential Smoothing
				//applyAimAcceleration(); // Apply Aim Acceleration
				checkAdsStickSwap(); // Perform check for 'ADS Stick Swap' setting
				checkOptions(); // Execute any running options
				checkTriggers(); // Get trigger state & set hair triggers
				checkAssist(); // Execute any enabled assists (Aim Assist [+etc.], Rotation Assist, Anti-Recoil)
				checkToggles(); // Execute any toggles
				blockActionButtons(); // Block any buttons used in toggles/profile switches
				
				if(!userData[vOptionRapidFire + currentProfile] ) {
					//if(holdingFire && userData[vAimAssistFireShape + currentProfile] == aasEcstasy) {
					//	setLedColor(aimAssistShape); // Rave
					//} else {
						setProfileLedColor(currentProfile); // Set LED color to notify user of current profile
					//}
				} else {
					combo_run(cboAlertRapidFire); // If Rapid Fire enabled, enable alert
				}
			}
		}
	} else if(displayDepth == 1) { // Mod menu
		setProfileLedColor(menuProfile); // Set LED to Profile being edited
		checkModMenuEvent(); // Check for mod menu events
		checkToggles(); // Check for Profile switches
	} else if(displayDepth == 2) { // Edit menu
		if(editMenuIndex == editMenuProfileColors) {
			setProfileLedColor(editMenuSelectedRow); // Set LED to Profile Color being edited
		} else if(antiDriftCalibrationState) {
			// Determine stick being calibrated
			if(antiDriftCalibrationStick == antiDriftLeftStick) {
				antiDriftCalibrationPolarStick = iif(antiDriftCalibrationDirection == antiDriftUp || antiDriftCalibrationDirection == antiDriftDown, POLAR_LY, POLAR_LX);
			} else {
				antiDriftCalibrationPolarStick = iif(antiDriftCalibrationDirection == antiDriftUp || antiDriftCalibrationDirection == antiDriftDown, POLAR_RY, POLAR_RX);
			}
			checkCalibrationRange(); // Check calibration range
			setLedColor(iif(antiDriftCalibrationInRange, green, orange)); // Notify user of calibration state
			
			// Display to user "Release Joystick" if they are in range and remove if they are not
			if(antiDriftCalibrationInRange) {
				antiDriftCalibrationState = 2;
				displayUpdate = TRUE;
			} else {
				if(antiDriftCalibrationState == 2 && !antiDriftCalibrationInRange) {
					antiDriftCalibrationState = 1;
					displayUpdate = TRUE;
				}
			}
		} else {
			// Remove drift only in drift test menu
			if(editMenuIndex == editMenuAntidriftTest) {
				removeDriftAndApplyDeadzone();
			}
			setProfileLedColor(menuProfile); // Set LED to Profile being edited
		}
		
		checkEditMenuEvent(); // Check for edit menu event
		checkToggles(); // Check for Profile switches
	}
	
	blockMenuButtons(); // Block any buttons pressed if in a menu
	checkBlockRumble(); // Always check for blocking rumbled called for by the game
}


/**************************************************************/
//	Functions
/**************************************************************/
// Joystick response curve adjustment
// Will set any % stick movement under THRESHOLD to a REDUCTION percentage
// 	i.e. 66 Threshold 75 Reduction:
//	- Any movement under 66 is only 75% movement output to game
// Will only activate if user is ADS or Firing
function aimAcceleration(z) {
	// Determine if movement is at or below the threshold
	if(abs(z) <= polarValues[userData[vAimAccelerationThreshold]]) {
		return z - (z - (z * userData[vAimAccelerationReduction] / 100));
	}
	
	return z - (z - (z * (abs(z) / 327) / 100));
}

// This function applies Aim Acceleration to both joysticks when aiming or firing
function applyAimAcceleration() {
	if(get_ival(button[ads]) || get_ival(button[fire]) && (userData[vAimAccelerationThreshold] < 100)) {
		// Apply joystick 'Aim Acceleration'
		set_val(POLAR_RX, aimAcceleration(get_val(POLAR_RX)));
		set_val(POLAR_RY, aimAcceleration(get_val(POLAR_RY)));
	}
}

// This function applies Exponential Smoothing to the stick movement, if enabled
function applySmoothing() {
	if(userData[vSmoothing] && (get_ival(button[ads]) || get_ival(button[fire]))) {
		forecast_x = exponentialSmoothing(get_val(POLAR_RX) * 10, forecast_x); // Calculate X
		forecast_y = exponentialSmoothing(get_val(POLAR_RY) * 10, forecast_y); // Calculate Y
		set_val(POLAR_RX, forecast_x / 10); // Set X
		set_val(POLAR_RY, forecast_y / 10); // Set Y
	}
}

// Block output to controller from menu actions
function blockActionButtons() {
	// Loop through each toggle combination and block if being used
	for(i = 0; i < 24; i += 2) {
		if(userData[vToggleButton + i] && userData[vToggleButton + i + 1]) {
			if(get_val(userData[vToggleButton + i]) && get_ptime(userData[vToggleButton + i + 1]) < 250) {
				set_val(userData[vToggleButton + i + 1], 0);
			}
		}
	}
	// Block quick edit recoil and entering the menu buttons
	if(get_ival(button[ads])) {
		set_val(XB1_MENU, 0);
		set_val(XB1_VIEW, 0);
	}
}

// Block output to controller from menu actions
function blockMenuButtons() {
	// Block all buttons while in a menu
	if(displayDepth || antiRecoilQuickEdit) {
		block_all_inputs();
	}
}

// Prepares the display buffer for a multiple item menu
function buildSelectedItemBuffer(type, message, value) {
	// Build display
	insertString(message);
	
	// Determine data type being used
	if(type == displayString) {
		insertString(value);
	} else {
		insertNumber(value);
	}
}

// Calculates the adjustment made to the left stick based on Inverse Assist threshold
function calculateRotationThresholdAdjustment(value) {
	// Determine the proper adjustment value based on stick moving left/right
	if(get_val(stick[aimX]) > 0) {
		return iif(rotationDirection, value - polarValues[userData[vInverseAssistThreshold + currentProfile]], inv(value - polarValues[userData[vInverseAssistThreshold + currentProfile]]));
	}
	
	return iif(rotationDirection, value + polarValues[userData[vInverseAssistThreshold + currentProfile]], inv(value + polarValues[userData[vInverseAssistThreshold + currentProfile]]));
}

// Calculate uptime values
function calculateUptime() {
	uptimeCounter += get_rtime();
	if(uptimeCounter >= 1000) {
		uptimeSeconds++;
		uptimeCounter -= 1000;
		if(uptimeSeconds >= 60) {
			uptimeMinutes++;
			uptimeSeconds = 0;
			if(uptimeMinutes >= 60) {
				uptimeHours++;
				uptimeMinutes = 0;
				if(uptimeHours >= 24) {
					uptimeDays++;
					uptimeHours = 0;
				}
			}
		}
	}
}

// Checks the stick when in calibration mode to make sure the
// user has moved the stick to the appropriate range prior to
// releasing the stick and setting the new value
function checkCalibrationRange() {
	// Determine target range
	if((antiDriftCalibrationDirection == antiDriftLeft) || (antiDriftCalibrationDirection == antiDriftUp)) {
		antiDriftCalibrationLow = -11468; // 35
		antiDriftCalibrationHigh = -8191 // 25
	} else {
		antiDriftCalibrationLow = 8191; // 25
		antiDriftCalibrationHigh = 11468; // 35
	}
	
	// Get stick value
	antiDriftCalibrationRangeValue = get_ival(antiDriftCalibrationPolarStick);
	
	// See if stick is moved within boundaries
	if((antiDriftCalibrationRangeValue >= antiDriftCalibrationLow) && (antiDriftCalibrationRangeValue <= antiDriftCalibrationHigh)) {
		antiDriftCalibrationInRange = antiDriftCalibrationCanSet = TRUE; // Notify user it is in range and allow calibration to proceed
	} else if(((antiDriftCalibrationDirection == antiDriftLeft) || (antiDriftCalibrationDirection == antiDriftUp)) && antiDriftCalibrationRangeValue < antiDriftCalibrationLow) {
		antiDriftCalibrationCanSet = antiDriftCalibrationInRange = FALSE; // Stick moved too far, reading will be inaccurate.  Stick pulls to hard back to center
	} else if(((antiDriftCalibrationDirection == antiDriftRight) || (antiDriftCalibrationDirection == antiDriftDown)) && antiDriftCalibrationRangeValue > antiDriftCalibrationHigh) {
		antiDriftCalibrationCanSet = antiDriftCalibrationInRange = FALSE; // Stick moved too far, reading will be inaccurate.  Stick pulls to hard back to center
	} else {
		antiDriftCalibrationInRange = FALSE; // Release zone not met
	} 
}

// Checks if a status change combo is running (i.e. action failed/success)
function checkCombos() {
	if(combo_running(cboActionFailed)) {
		return TRUE;
	} else if(combo_running(cboActionSuccess)) {
		return TRUE;
	} else if(combo_running(cboSaveSettings)) {
		return TRUE;
	} else if(combo_running(cboToggleOn) || combo_running(cboToggleOff)) {
		return TRUE;
	}
	return FALSE;
}

// Checks for activation based on ADS and Fire flags
function checkActivation(activation) {
	// Check activation flags
	if(activation) {
		//	ADS Only / Fire Only / ADS & Fire				ADS or Fire										(ADS & Fire / Fire)											(ADS & Fire / ADS)
		return ((activation == assistFlags) || ((activation == assistAdsOrFire) && assistFlags) || ((activation == assistAdsAndFireOrFire) && (assistFlags & 2)) || (activation == assistAdsAndFireOrAds) && (assistFlags & 1));
	}
	
	return 0;
}

// Controller ADS stick swap
function checkAdsStickSwap() {
	// Check if ADS stick swap is enabled
	if(userData[vControllerAdsStickSwap] == cbpSwapped) {
		stick[aimX] = iif(holdingADS, stickLayoutMap[userData[vControllerStickLayout]][moveX], stickLayoutMap[userData[vControllerStickLayout]][aimX]);
		stick[aimY] = iif(holdingADS, stickLayoutMap[userData[vControllerStickLayout]][moveY], stickLayoutMap[userData[vControllerStickLayout]][aimY]);
		stick[moveX] = iif(holdingADS, stickLayoutMap[userData[vControllerStickLayout]][aimX], stickLayoutMap[userData[vControllerStickLayout]][moveX]);
		stick[moveY] = iif(holdingADS, stickLayoutMap[userData[vControllerStickLayout]][aimY], stickLayoutMap[userData[vControllerStickLayout]][moveY]);
	}
}

// Determine which Assist mods must be executed
// - Aim Assist (+etc.), Rotation Assist, Anti-recoil
function checkAssist() {
	
	// Set flags (disable ADS for Akimbo)
	assistFlags = (holdingADS > 0) | ((holdingFire > 0) << 1) & ~userData[vOptionAkimbo + currentProfile];
	
	// Check Inverse Assist
	if(checkActivation(userData[vInverseAssist + currentProfile])) {
		executeInverseAssist();
	}
	
	// Check Aim Assist
	if(checkActivation(userData[vAimAssist + currentProfile])) {
		executeAimAssist();
	} else if (userData[vAimAssist + currentProfile]) {
		resetAimAssist(); // Correct aim assist
	}
	
	// Check Rotation Assist
	if(checkActivation(userData[vRotationAssist + currentProfile])) {
		executeRotationAssist();
	} else if(userData[vRotationAssist + currentProfile]) {
		rotationCounter = 0; // Reset rotation counter
		rotationDirection = 0;
	}
	
	// Check Anti-recoil
	if(userData[vAntiRecoil + currentProfile] && checkActivation(assistAdsAndFire) && !combo_running(cboOptionDropShot)) {
		executeAntiRecoil();
	} else if(userData[vAntiRecoil + currentProfile]) {
		antiRecoilMaxX = 0; // Reset maximum horizontal step value
		antiRecoilMaxY = 0; // Reset maximum vertical step value
		antiRecoilStepX = 0; // Reset horizontal step counter
		antiRecoilStepY = 0; // Reset vertical step counter
		antiRecoilStateX = 0; // Reset horizontal stage
		antiRecoilStateY = 0; // Reset vertical stage
		antiRecoilCounterX = 0; // Reset horizontal counter
		antiRecoilCounterY = 0; // Reset vertical counter
	}
	
	assistFlags = 0; // Reset assist (aiming/firing) flags
}

// Checks for rumble block state
function checkBlockRumble() {
	if(userData[vBlockRumble]) {
		block_rumble();
	}
}

// Check and perform display update
function checkDisplayUpdate() {
	if(displayUpdate) {
		cls_oled(OLED_BLACK); // Clear display
		if(displayDepth == 1) {
			displayModMenu(); // Display mod menu
		} else if(displayDepth == 2) {
			displayEditMenu(); // Display edit menu
		}
	}
}
	
// Check for edit menu event
function checkEditMenuEvent() {
	
	checkDisplayUpdate(); // See if edit menu needs to update to the display
	
	// TODO: Clean this up further
	if(modMenuIndex == modMenuToggles) {
		// See if we are setting toggle combination buttons
		switch(editMenuIndex) {
			case editMenuToggleAkimbo {
				createToggle(toggleAkimbo);
				break;
			} case editMenuToggleAutoADS {
				createToggle(toggleAutoADS);
				break;
			} case editMenuToggleAutoFocus {
				createToggle(toggleAutoFocus);
				break;
			} case editMenuToggleAutoPing {
				createToggle(toggleAutoPing);
				break;
			} case editMenuToggleBackpackSwap {
				createToggle(toggleBackpackSwap);
				break;
			} case editMenuToggleDropShot {
				createToggle(toggleDropShot);
				break;
			} case editMenuToggleFastMelee {
				createToggle(toggleFastMelee);
				break;
			} case editMenuToggleRapidFire {
				createToggle(toggleRapidFire);
				break;
			} case editMenuToggleTacticalSprint {
				createToggle(toggleTacticalSprint);
				break;
			} case editMenuToggleQuickScope {
				createToggle(toggleQuickScope);
				break;
			}
		}
	} else if(modMenuIndex == modMenuProfiles) {
		switch(editMenuIndex) {
			case editMenuProfileSwitch {
				createToggle(toggleProfile);
				break;
			} case editMenuUniversalSwitch {
				createToggle(toggleUniversal);
				break;
			}
		}
	}
	
	// Check for events (only responsive to presses under 1000ms)
	for(i = 0; i < sizeof(menuButtons) / sizeof(menuButtons[0]); i++) {
		if(checkEvent(menuButtons[i])) {
			cycleEditMenu(menuButtons[i]);
		}
	}
	
	if(editMenuIndex == editMenuAntidriftTest) {
		displayUpdate = TRUE; // Constantly update display
	}
}

// Determine if an event is being called
function checkEvent(b) {
	// Check if user is holding down the button to quickly cycle through values
	if(get_ival(button[ads]) && get_ival(b) && get_ptime(b) > 240) {
		if(checkEventChangeTime >= 120) {
			checkEventChangeTime = 0;
			return TRUE;
		} else {
			checkEventChangeTime += get_rtime();
			return FALSE;
		}
	}
	
	return (event_release(b) && (get_ptime(b) < 720));
}

// Check for mod menu event
function checkModMenuEvent() {
	
	checkDisplayUpdate(); // See if edit menu needs to update to the display
	
	if(event_press(XB1_DOWN)) { // Request mod menu cycle downwards
		cycleModMenu(modMenuDown);
	} else if(event_press(XB1_UP)) {// Request mod menu cycle upwards
		cycleModMenu(modMenuUp); 
	} else if(event_press(XB1_A)) { // Request enter mod menu
		cycleModMenu(modMenuEnter);
	} else if(event_release(XB1_B)) { // Exit mod menu to home screen
		cycleModMenu(modMenuExit);
	} else {
		displayUpdate = FALSE;
	}
}

const int8 handgunValues[][] = {
	{ 19, 5 }, // Xbox
	{ 63, 16 }, // Xbox Elite 2 Controller
	{ 8, 11 }, // Xbox Basilisk Revolver
	{ 63, 0 }, // PlayStation 4
	{ 14, 63 }, // PlayStation 5 (A3 port)
	{ 34, 30 } // PlayStation 5 Basilisk (A3 port)
}

// Checks for running options and executes them if enabled
function checkOptions() {

	// Akimbo
	if(userData[vOptionAkimbo + currentProfile]) {
		if(get_ival(button[ads]) || get_ival(button[fire])) {
			if(userData[vOptionAkimboSpeed + currentProfile]) {
				if(!combo_running(cboOptionAkimbo)) {
					combo_stop(cboOptionTacticalSprint);
					combo_run(cboOptionAkimbo);
				}
			} else {
				set_val(button[ads], 100);
				set_val(button[fire], 100);
			}
		} else {
			combo_stop(cboOptionAkimbo);
		}
	} else {
	
		// Auto ADS/Fire (ignore if Akimbo enabled)
		if((userData[vOptionAutoAdsFire + currentProfile] == autoADSFireAutoADS) && holdingFire) {
			set_val(button[ads], 100);
		} else if((userData[vOptionAutoAdsFire + currentProfile] == autoADSFireAutoFire) && holdingADS /*&& !combo_running(cboOptionSlideCancel)*/) {
			set_val(button[fire], 100);
		}
		
		// Auto Focus
		if(userData[vOptionAutoFocus + currentProfile]) {
			// If aiming, execute combo
			if(combo_running(cboOptionAutoFocus) && !combo_running(cboToggleScope) && holdingADS && get_ival(button[focus]) && (get_ptime(button[focus]) <= 120)) {
				combo_stop(cboOptionAutoFocusDelay);
				combo_stop(cboOptionAutoFocus);
				combo_run(cboToggleScope);
			} else if(holdingADS && get_ival(button[focus])) {
				// Do not want to restart the combo in middle of holding button[focus] or it may just r in a toggle
				if(!((combo_step_time_left(cboOptionAutoFocus) >= 2800) && (combo_step_time_left(cboOptionAutoFocus) <= 2900))) {
					combo_restart(cboOptionAutoFocus); // Execute Auto Focus as long as we are holding ADS
				}
			} else if(holdingADS) {
				if(userData[vOptionAutoFocusInterval + currentProfile]) {
					combo_run(cboOptionAutoFocusDelay); // Execute the delayed Auto Focus
				} else {
					combo_run(cboOptionAutoFocus); // Execute Auto Focus as long as we are holding ADS
				}
			} else {
				combo_stop(cboOptionAutoFocusDelay);
				combo_stop(cboOptionAutoFocus);	 // Stop Auto Focus
			}
		}
		
		// Rapid Fire Pistols
		if(userData[vOptionRapidFirePistols + currentProfile]) {
			if(holdingFire) {
				if(rapidFirePistols) {
					combo_run(cboOptionRapidFirePistols);
				} else {
					if(get_controller() == PIO_XB1) {
						for(i = 0; i < 3; i++) {
							if(get_rumble(RUMBLE_A) == handgunValues[i][0] && get_rumble(RUMBLE_B) == handgunValues[i][1]) {
								combo_run(cboOptionRapidFirePistols);
								rapidFirePistols = TRUE;
								i = 3;
							}
						}
					} else if(get_controller() == PIO_PS4 || get_controller() == PIO_PS5) {
						for(i = 3; i < 6; i++) {
							if(get_rumble(RUMBLE_A) == handgunValues[i][0] && get_rumble(RUMBLE_B) == handgunValues[i][1]) {
								combo_run(cboOptionRapidFirePistols);
								rapidFirePistols = TRUE;
								i = 6;
							} else if(get_rumble(RUMBLE_A) == handgunValues[i][1] && get_rumble(RUMBLE_B) == handgunValues[i][0]) {
								combo_run(cboOptionRapidFirePistols);
								rapidFirePistols = TRUE;
								i = 6;
							}
						}
					}
				}
			} else {
				rapidFirePistols = FALSE;
			}
		}
		
		// Rapid Fire (will not work if Akimbo enabled)
		if(userData[vOptionRapidFire + currentProfile] && holdingFire && !rapidFirePistols) {
			combo_run(cboOptionRapidFire); // Execute Rapid Fire	
		} else {
			combo_stop(cboOptionRapidFire); // Stop Rapid Fire
			
			// Quick Scope (cannot work with Rapid Fire)
			if(userData[vOptionQuickScope + currentProfile]) {
				if(!holdingFire && event_press(button[ads])) {
					combo_run(cboOptionQuickScope);
				}
			}
		}
	}
	
	// Auto Ping
	if(userData[vOptionAutoPing + currentProfile]) {
		if(holdingADS) {
			if(!userData[vOptionAutoPingInterval + currentProfile] && event_press(button[fire])) {
				combo_run(cboOptionAutoPingOnce);
			} else if(userData[vOptionAutoPingInterval + currentProfile] && holdingFire) {
				combo_run(cboOptionAutoPing);
			}
		}
	}
	
	// Backpack Swap
	if(userData[vOptionBackpackSwap]) {
		if(!userData[vOptionBackpackSwapType] && event_press(button[weapon]) && (get_brtime(button[weapon]) < 240)) {
			combo_run(cboOptionBackpackSwap);
			return;
		}
	}
	
	// Bunny Hop
	if(userData[vOptionBunnyHop]) {
		if(get_ival(button[jump]) && (get_ptime(button[jump]) >= 240)) {
			combo_run(cboOptionBunnyHop);
			return;
		}
	}
	
	// Drop shot
	if(userData[vOptionDropShot + currentProfile]) {
		if(((holdingADS && holdingFire) || (combo_running(cboOptionAkimbo))) && event_press(button[action])) {
			combo_run(cboOptionDropShot);
			return;
		}
	}
	
	// Fast Melee
	if(userData[vOptionFastMelee + currentProfile] == fastMeleeToggle) {
		// Only activate upon release in which it was held under 300ms
		// This will allow a user to assassinate/execute another player
		if(event_release(button[melee]) && (get_ptime(button[melee]) < 300)) {
			fastMeleeEnabled = !fastMeleeEnabled; // Toggle Fast Melee
		}
		// Determine whether to continue or not
		if(fastMeleeEnabled) {
			// If user ADS or Fire during Fast Melee, disable Fast Melee
			if(!holdingADS && !holdingFire) {
				combo_run(cboOptionFastMelee);
				return;
			} else {
				fastMeleeEnabled = !fastMeleeEnabled; // Disable Fast Melee
				combo_stop(cboOptionFastMelee);
			}
		} else {
			combo_stop(cboOptionFastMelee);
		}
	} else if((userData[vOptionFastMelee + currentProfile] == fastMeleeHold) && get_ival(button[melee])) {
		combo_run(cboOptionFastMelee); // Execute Fast Melee
		fastMeleeEnabled = TRUE;
		return;
	} else if(fastMeleeEnabled) {
		combo_stop(cboOptionFastMelee); // Stop Rapid Fire
		fastMeleeEnabled = FALSE;
	}
	
	
	// Following combos cannot run if G-Walk is
	if(!combo_running(cboOptionGWalk) && !holdingADS && !holdingFire) {
		// Following combos cannot run if ADS or Firing and are movement options
		if(get_val(stick[moveY]) <= inv(polarValues[74])) {
			// Dolphin Cancel
			if(userData[vOptionDolphinCancel]) {
				if((userData[vControllerSlideDive] == slideDiveStandard) && get_ival(button[action]) && (get_ptime(button[action]) >= 180)) {
					combo_run(cboOptionDolphinCancel);
					return;
				} else if((userData[vControllerSlideDive] == slideDiveInverted) && event_press(button[action]) && (get_ptime(button[action]) < 300)) {
					combo_run(cboOptionDolphinCancel);
					return;
				}
			}
			
			// G-Walk
			if(userData[vOptionGWalk]) {
				if((userData[vOptionGWalk] == gWalkSprint) && event_press(iif(polarStick == POLAR_RS, XB1_LS, XB1_RS))) {
					combo_run(cboOptionGWalk);
					return;
				} else if(userData[vOptionGWalk] == gWalkReplace) {
					if (event_release(button[action]) && (get_ptime(button[action]) < 180)) {
						combo_run(cboOptionGWalk); 
						return;
					} else if((userData[vControllerSlideDive] == slideDiveInverted) && get_ival(button[action]) && (get_ptime(button[action]) >= 300)) {
						combo_run(cboOptionGWalk);
						return;
					}
				}
			}
			
			// Slide Cancel
			if(userData[vOptionSlideCancel]) {
				if((userData[vOptionSlideCancel] == slideCancelMW) && event_release(button[action])) {
					combo_run(cboOptionSlideCancelMW);
					return;
				} else if (userData[vOptionSlideCancel] == slideCancelMW2) {
					if((userData[vControllerSlideDive] == slideDiveStandard) && event_press(button[action]) && (get_ptime(button[action]) < 180)) {
						combo_run(cboOptionSlideCancelMW2);
						return;
					} else if((userData[vControllerSlideDive] == slideDiveInverted) && get_ival(button[action]) && (get_ptime(button[action]) >= 300)) {
						combo_run(cboOptionSlideCancelMW2);
						return;
					}
				}
			}
			
			// Tactical Sprint
			if(userData[vOptionTacticalSprint]) {
				if(!combo_running(cboOptionTacticalSprint) && !combo_running(cboOptionAkimbo)) {
					combo_run(cboOptionTacticalSprint);		
				}
			}
		} else {
			combo_stop(cboOptionTacticalSprint);
		}
	}
}

// Checks if user is attempting to pause the script (i.e. when using a vehicle)
function checkPause() {
	// Check if pause button combination is pressed
	if(!vehicleMode && get_val(button[fire]) && event_press(XB1_RIGHT) && (get_brtime(XB1_RIGHT) <= 240)) {
		cls_oled(OLED_BLACK); // Clear screen
		vehicleModeLeaning = FALSE; // Not leaning, just got in car
		vehicleModeInCar = TRUE; // In car
		vehicleMode = TRUE; // Set pause flag
		screenSaverEnabled = FALSE; // Disable screen saver
		screenSaverCounter = 0; // Reset screen saver timer
		printText(alignCenter, alignCenter, vehicleModeMsg[0], OLED_FONT_SMALL, OLED_WHITE); // Display message
	} else if((vehicleMode || vehicleModeInCar) && (event_press(XB1_X) || event_press(button[action]) || event_press(button[jump]))) {
		cls_oled(OLED_BLACK); // Clear screen
		vehicleModeLeaning = FALSE; // Exiting vehicle / switched seats
		vehicleModeInCar = FALSE;
		vehicleMode = FALSE; // Unpause script
		displayUpdate = TRUE; // Enable display update
		combo_stop(cboAlertvehicleMode); // Disable pause mode notification
	} else if((vehicleMode || vehicleModeInCar) && event_press(button[melee])) {
		vehicleModeLeaning = !vehicleModeLeaning;
		vehicleMode = iif(vehicleModeLeaning, FALSE, TRUE);
		cls_oled(OLED_BLACK);
		printText(alignCenter, alignCenter, vehicleModeMsg[vehicleModeLeaning], OLED_FONT_SMALL, OLED_WHITE); // Display message
	} else if(vehicleMode || vehicleModeInCar) {
		combo_run(cboAlertvehicleMode); // Enable vehicle mode notification
	}
	
	return vehicleMode;
}

// Checks if the aim assist shape to use is different from
// the last shape and resets all aim assist values if needed 
function checkShapeChange(shape) {
	if(shape != aimAssistShape && shape != aasEcstasy) {
		resetAimAssist();
	}
}

// Checks for toggle combination buttons to be pressed
function checkToggles() {
	// Only check for toggles when not in a menu
	if(!displayDepth) {
		// Loop through all toggle combinations
		for(i = 0; i < 24; i += 2) {
			// Only process if a toggle is set
			if(userData[vToggleButton + i] && userData[vToggleButton + i + 1]) {
				// See if toggle is requested
				if(get_ival(userData[vToggleButton + i])) {
					if((i == toggleProfile) || (i == toggleUniversal)) {
						if(event_release(userData[vToggleButton + i + 1])) {
							dispatchToggle(i);
							return;
						}
					} else {
						if(event_press(userData[vToggleButton + i + 1]) && (get_brtime(userData[vToggleButton + i + 1]) <= 240)) {
							dispatchToggle(i);
						}
					}
				}
			}
		}
	
		// Switch profile button pressed
		if((currentProfile != 2) && userData[vToggleButton + toggleProfile + 1] && event_release(userData[vToggleButton + toggleProfile + 1]) && (get_ptime(userData[vToggleButton + toggleProfile + 1]) < 240)) {
			displayUpdate = TRUE;
			switchProfile(!currentProfile);
			return;
		}
	}
	
	// Y/Triangle pressed in a edit menu that supports settings per profile
	if(event_press(XB1_Y) && editMenuItems[modMenuIndex][editMenuShowProfile]) {
		menuProfile = iif(menuProfile == 2, 0, menuProfile++);
		displayUpdate = TRUE;
	}
}

// Checks for triggers
function checkTriggers() {

	// Set trigger values and max out if buttons are pressed
	holdingADS = get_val(button[ads]);
	holdingFire = get_val(button[fire]);
	
	if(holdingADS) {
		if(userData[vOptionHairTriggers]) { // Check for Hair Triggers
			set_val(button[ads], 100);
		}
	}
	
	if(holdingFire) {
		if(userData[vOptionHairTriggers]) { // Check for Hair Triggers
			set_val(button[fire], 100);
		}
	}
}

// Called to check if OLED should be cleared after an action while using Visualizer screen saver
function clearVisualizer() {
	// Check for visualizer screen saver
	if(screenSaverEnabled && (userData[vScreenSaver] == screenSaverVisualizer)) {
		combo_run(cboClearScreen); // Runs faster in a combo
	}
}

// Correct stick input based on drift low/high values including deadzone and compensate for "lost" values
function correctStickInput(low, high, deadzone, stick) {

	// Calculate the boundaries
	antiDriftLowValue = low - polarValues[deadzone];
	antiDriftHighValue = high + polarValues[deadzone];
	antiDriftStickValue = get_ival(stick); // Get stick value
	
	// In the drift zone, so set stick to no movement
	if((antiDriftStickValue >= antiDriftLowValue) && (antiDriftStickValue <= antiDriftHighValue)) {
		set_val(stick, 0);
		
	// If user has moved stick under the lower boundary (left/up)
	} else if(antiDriftStickValue < antiDriftLowValue) {
		set_val(stick, clamp((antiDriftStickValue - antiDriftLowValue) - ((antiDriftStickValue / 327) * antiDriftLowValue) / 100, -32768, 32767));
		
	// If user has moved stick over the upper boundary (right/down)
	} else if(antiDriftStickValue > antiDriftHighValue) {
		set_val(stick, clamp((antiDriftStickValue - antiDriftHighValue) + ((antiDriftStickValue / 327) * antiDriftHighValue) / 100, -32768, 32767));
		
	// Just incase stick_value isn't in driftzone and doesn't meet other conditions
	// (i.e. calculations equate to low/high value)
	// At that point we still do not want to make any adjustment because we're not outside of the drift+deadzone
	} else {
		set_val(stick, 0);
	}
}

// Creates a toggle combination
function createToggle(toggle) {
	// Loop through each controllerButtons and see what is being held down for ~3/4 second
	for(i = 0; i < 13; i++) {	
		if(get_val(controllerButtons[i]) && (get_ptime(controllerButtons[i]) >= 720)) { // 720 is multiple of 4,6,8,10
			if(!editMenuSelectedRow) {
				// Setting HOLD
				userData[vToggleButton + toggle] = setToggleButton(userData[vToggleButton + toggle], controllerButtons[i], userData[vToggleButton + toggle + 1]);
				userData[vToggleButton + toggle] = verifyToggleCombo(userData[vToggleButton + toggle], toggle);
			} else {
				// Setting PRESS
				userData[vToggleButton + toggle + 1] = setToggleButton(userData[vToggleButton + toggle + 1], controllerButtons[i], userData[vToggleButton + toggle]);
				userData[vToggleButton + toggle + 1] = verifyToggleCombo(userData[vToggleButton + toggle + 1], toggle);
			}
		}
	}
}

function dispatchAdsCycleEditValue(direction, profile, variable, min, max) {
	variable += profile;
	switch(direction) {
		case XB1_UP {
			userData[variable] = cycleEditValue(userData[variable], cycleValueUp, 10, max);
			break;
		} case XB1_DOWN {
			userData[variable] = cycleEditValue(userData[variable], cycleValueDown, 10, min);
			break;
		} case XB1_LEFT {
			userData[variable] = cycleEditValue(userData[variable], cycleValueDown, 1, min);
			break;
		} case XB1_RIGHT {
			userData[variable] = cycleEditValue(userData[variable], cycleValueUp, 1, max);
			break;
		} default {
			menuActionFailed();
		}
	}
}

function dispatchCycleListOption(direction, profile) {
	editMenuVariable1 += profile;
	switch(direction) {
		case XB1_UP {
			userData[editMenuVariable1] = cycleListOption(userData[editMenuVariable1], cycleValueUp, editMenuMaxValue, editMenuMinValue);
			break;
		} case XB1_DOWN {
			userData[editMenuVariable1] = cycleListOption(userData[editMenuVariable1], cycleValueDown, editMenuMinValue, editMenuMaxValue);
			break;
		} default {
			dispatchMenuAction(direction);
		}
	}
}

function dispatchAssistDualSelection(direction) {
	switch(direction) {
		case XB1_UP {
			if(userData[editMenuParent + menuProfile] == assistAdsOnly) { // Ads only
				userData[editMenuVariable1 + menuProfile] = cycleListOption(userData[editMenuVariable1 + menuProfile], cycleValueUp, editMenuMaxValue, editMenuMinValue);
			} else if(userData[editMenuParent + menuProfile] == assistAdsOrFire || userData[editMenuParent + menuProfile] == assistAdsAndFireOrAds) { // Ads or fire setting allows selection of ads/fire
				editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
			} else { // Fire only
				userData[editMenuVariable2 + menuProfile] = cycleListOption(userData[editMenuVariable2 + menuProfile], cycleValueUp, editMenuMaxValue, editMenuMinValue);
			}
			break;
		} case XB1_DOWN {
			if(userData[editMenuParent + menuProfile] == assistAdsOnly) { // Ads only
				userData[editMenuVariable1 + menuProfile] = cycleListOption(userData[editMenuVariable1 + menuProfile], cycleValueDown, editMenuMinValue, editMenuMaxValue);
			} else if(userData[editMenuParent + menuProfile] == assistAdsOrFire || userData[editMenuParent + menuProfile] == assistAdsAndFireOrAds) { // Ads or fire setting allows selection of ads/fire
				editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
			} else { // Fire only
				userData[editMenuVariable2 + menuProfile] = cycleListOption(userData[editMenuVariable2 + menuProfile], cycleValueDown, editMenuMinValue, editMenuMaxValue);
			}
			break;
		} default {
			dispatchMenuAction(direction);
		}
	}
}

function dispatchAssistRowSelection(direction) {
	if(userData[editMenuParent + menuProfile] == assistAdsOrFire || userData[editMenuParent + menuProfile] == assistAdsAndFireOrAds) { // Ads or fire
		switch(direction) {
			case XB1_UP {
				editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				break;
			} case XB1_DOWN {
				editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 1);
				break;
			} default {
				dispatchMenuAction(direction);
			}
		}
	} else {
		dispatchMenuAction(direction);
	}
}

function dispatchAdsAssistDualSelection(direction) {
	if(userData[editMenuParent + menuProfile] == assistAdsOrFire || userData[editMenuParent + menuProfile] == assistAdsAndFireOrAds) {
		editMenuSelectionEditVariable = iif(!editMenuSelectedRow, editMenuVariable1, editMenuVariable2);
		switch(direction) {
			case XB1_LEFT {
				userData[editMenuSelectionEditVariable + menuProfile] = cycleListOption(userData[editMenuSelectionEditVariable + menuProfile], cycleValueDown, editMenuAdsMinValue, editMenuAdsMaxValue);
				break;
			} case XB1_RIGHT {
				userData[editMenuSelectionEditVariable + menuProfile] = cycleListOption(userData[editMenuSelectionEditVariable + menuProfile], cycleValueUp, editMenuAdsMaxValue, editMenuAdsMinValue);
				break;
			} default {
				menuActionFailed();
			}
		}
	} else {
		menuActionFailed();
	}
}

function dispatchAdsCycleListOption(direction) {
	switch(direction) {
		case XB1_LEFT {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleListOption(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueDown, editMenuAdsMinValue, editMenuAdsMaxValue);
			break;
		} case XB1_RIGHT {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleListOption(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueUp, editMenuAdsMaxValue, editMenuAdsMinValue);
			break;
		} default {
			menuActionFailed();
		}
	}
}

function dispatchAdsMultiSelection(direction) {
	switch(direction) {
		case XB1_UP {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleEditValue(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueUp, 10, editMenuAdsMaxValue);
			break;
		} case XB1_DOWN {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleEditValue(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueDown, 10, editMenuAdsMinValue);
			break;
		} case XB1_LEFT {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleEditValue(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueDown, 1, editMenuAdsMinValue);
			break;
		} case XB1_RIGHT {
			userData[editMenuVariable2 + editMenuSelectedRow] = cycleEditValue(userData[editMenuVariable2 + editMenuSelectedRow], cycleValueUp, 1, editMenuAdsMaxValue);
			break;
		} default {
			menuActionFailed();
		}
	}
}

function dispatchAdsToggle(direction, profile) {
	editMenuVariable2 += profile;
	if((direction == XB1_LEFT) || (direction == XB1_RIGHT)) {
		userData[editMenuVariable2] = !userData[editMenuVariable2];
	} else {
		menuActionFailed();
	}
}

function dispatchMenuToggle(direction) {
	if((direction == XB1_UP) || (direction == XB1_DOWN)) {
		userData[editMenuVariable1 + menuProfile] = (userData[editMenuVariable1 + menuProfile] ^ editMenuMaxValue);
	} else {
		dispatchMenuAction(direction);
	}
}

function dispatchMenuMultiSelection(direction) {
	switch(direction) {
		case XB1_UP {
			editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, editMenuMinValue);
			break;
		} case XB1_DOWN {
			editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, editMenuMaxValue);
			break;
		} default {
			dispatchMenuAction(direction);
		}
	}
}

function dispatchMenuNone(direction) {
	if((direction == XB1_UP) || (direction == XB1_DOWN)) {
		menuActionFailed();
	} else {
		dispatchMenuAction(direction);
	}
}

function dispatchMenuToggleOnOff(direction, profile) {
	editMenuVariable1 += profile;
	if((direction == XB1_UP) || (direction == XB1_DOWN)) {
		userData[editMenuVariable1] = !userData[editMenuVariable1];
	} else {
		dispatchMenuAction(direction);
	}
}

int editMenuHoldingADS;

function dispatchMenuAction(direction) {
	switch(direction) {
		case XB1_B { // When user presses B/Circle
			if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				antiDriftCalibrationCanSet = 2; // Flag for cancelled
				combo_run(cboCalibrationComplete);
			} else {
				// Check if we are in anti-recoil quick edit
				if(antiRecoilQuickEdit) {
					displayDepth = 0; // Reset to Home Screen
					antiRecoilQuickEdit = FALSE; // Disable anti-recoil quick edit
					combo_run(cboSaveSettings); // Save settings
				} else {
					displayUpdate = TRUE;
					displayDepth--; // Exit to Mod Menu
					editMenuSelectedColumn = 0; // Reset selected column
					editMenuSelectedPage = 0; // Reset selected page
					editMenuSelectedRow = 0; // Reset selected item index
					editMenuIndex = 0; // Reset index
				}
			}
			break;
		} case XB1_LEFT {
			if((editMenuIndex == editMenuAimAssist) && (userData[vShapeSpin + menuProfile] == assistOff)) {
				editMenuIndex = editMenuShapeSpin; // Goto Shape Spin toggle if SS is off
			} else if((editMenuIndex == editMenuInverseAssist) && (userData[vRotationAssist + menuProfile] == assistOff)) {
				editMenuIndex = editMenuRotationAssist;
			//} else if((editMenuIndex == editMenuIdleTargetAssist) && (userData[vRotationAssist + menuProfile] == assistOff)) {
				//editMenuIndex = editMenuRotationAssist; // Goto Rotation Assist toggle if RA is off
			//	editMenuIndex = editMenuInverseAssist;
			} else if((editMenuIndex == editMenuRotationAssist) && (userData[vAimAssist + menuProfile] == assistOff)) {
				editMenuIndex = editMenuAimAssist; // Goto Aim Assist toggle if RA is off
			} else if((editMenuIndex == editMenuMotionAssist) && (userData[vIdleTargetAssist + menuProfile] == assistOff)) {
				editMenuIndex = editMenuIdleTargetAssist; // Goto Idle Target Assist toggle if Shape Motion is off
			} else if((editMenuIndex == editMenuShapePulse) && (userData[vMotionAssist + menuProfile] == assistOff)) {
				editMenuIndex = editMenuMotionAssist;
			} else if((editMenuIndex == editMenuShapeSpin) && (userData[vShapePulse + menuProfile] == assistOff)) {
				editMenuIndex = editMenuShapePulse;
			} else if((editMenuIndex == editMenuAntiRecoil) && (userData[vAntiRecoil + menuProfile] == antiRecoilOff)) {
				menuActionFailed(); // Anti-recoil must be enabled to see rest of options
			} else if((editMenuIndex == editMenuAntiRecoil) && (userData[vAntiRecoil + menuProfile] == antiRecoilBasic)) {
				editMenuIndex = editMenuAntiRecoilStrength; // Basic Anti-Recoil can only access Strength menu
			} else if((editMenuIndex == editMenuAntiRecoil) && (userData[vAntiRecoil + menuProfile] == antiRecoilAdvanced)) {
				editMenuIndex = editMenuAntiRecoilKickCounter; // Advanced Anti-Recoil can access kick counter/duration menu
			} else if((editMenuIndex == editMenuAntiRecoil) && (userData[vAntiRecoil + menuProfile] == antiRecoilExpert)) { 
				editMenuIndex = editMenuAntiRecoilExpert; // Expert Anti-recoil only has one menu
			} else if((editMenuIndex == editMenuAntiRecoil) && (userData[vAntiRecoil + menuProfile] == antiRecoilWeapon)) {
				editMenuIndex = editMenuAntiRecoilWeaponCorrectionValue; // Weapon can only access the Weapon Select menu
			} else if(editMenuIndex == editMenuAntiRecoilExpert || editMenuIndex == editMenuAntiRecoilWeapon) {
				editMenuIndex = editMenuAntiRecoil; // Expert Anti-recoil only has one menu
			} else if((editMenuIndex == editMenuAntidrift) && !userData[vAntiDrift]) {
				menuActionFailed(); // Anti-drift must be enabled to see rest of options
			} else if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				menuActionFailed(); // Cannot leave calibration menu if calibration is running
			} else {
				editMenuSelectedColumn = 0;
				editMenuSelectedRow = 0;
				editMenuIndex = cycleListOption(editMenuIndex, cycleValueDown, editMenuItems[modMenuIndex][editMenuMin], editMenuItems[modMenuIndex][editMenuMax]);
				// Will not alert in DisplayEditMenu due to constant repeat, so enable here
				if(editMenuIndex == editMenuAntidriftTest) {
					menuActionSuccess();	
				}
			}
			break;
		} case XB1_RIGHT {
			if((editMenuIndex == editMenuAimAssist) && (userData[vAimAssist + menuProfile] == assistOff)) {
				editMenuIndex = editMenuRotationAssist; // Goto Rotation Assist toggle if AA is off
			} else if((editMenuIndex == editMenuRotationAssist) && (userData[vRotationAssist + menuProfile] == assistOff)) {
				//editMenuIndex = editMenuIdleTargetAssist; // Goto Idle Target Assist toggle if RA is off
				editMenuIndex = editMenuInverseAssist;
			} else if((editMenuIndex == editMenuIdleTargetAssist) && (userData[vIdleTargetAssist + menuProfile] == assistOff)) {
				editMenuIndex = editMenuMotionAssist;
				//editMenuIndex = editMenuAimAssist; // Goto Aim Assist toggle if ITA is off
			} else if((editMenuIndex == editMenuMotionAssist) && (userData[vMotionAssist + menuProfile] == assistOff)) {
				editMenuIndex = editMenuShapePulse;
			} else if((editMenuIndex == editMenuShapePulse) && (userData[vShapePulse + menuProfile] == assistOff)) {
				editMenuIndex = editMenuShapeSpin;
			} else if((editMenuIndex == editMenuShapeSpin) && (userData[vShapeSpin + menuProfile] == assistOff)) {
				editMenuIndex = editMenuAimAssist;
			} else if((editMenuIndex == editMenuAntiRecoil) && (userData[vAntiRecoil + menuProfile] == antiRecoilOff)) {
				menuActionFailed(); // Anti-recoil must be enabled to see rest of options 
			} else if((editMenuIndex == editMenuAntiRecoil) && (userData[vAntiRecoil + menuProfile] == antiRecoilBasic)) {
				editMenuIndex = editMenuAntiRecoilStrength; // Basic Anti-recoil can only access Strength option
			} else if((editMenuIndex == editMenuAntiRecoil) && (userData[vAntiRecoil + menuProfile] == antiRecoilAdvanced)) {
				editMenuIndex = editMenuAntiRecoilStrength; // Advanced Anti-recoil first has access to Strength option
			} else if((editMenuIndex == editMenuAntiRecoil) && (userData[vAntiRecoil + menuProfile] == antiRecoilExpert)) {
				editMenuIndex = editMenuAntiRecoilExpert; // Expert can only access the Expert menu
			} else if((editMenuIndex == editMenuAntiRecoil) && (userData[vAntiRecoil + menuProfile] == antiRecoilWeapon)) {
				editMenuIndex = editMenuAntiRecoilWeapon; // Weapon can only access the Weapon Select menu
			} else if((editMenuIndex == editMenuAntiRecoilStrength) && (userData[vAntiRecoil + menuProfile] == antiRecoilBasic)) {
				editMenuIndex = editMenuAntiRecoil; // Basic Anti-recoil can only access Strength option and main toggle
			} else if((editMenuIndex == editMenuAntiRecoilStrength) && (userData[vAntiRecoil + menuProfile] == antiRecoilAdvanced)) {
				editMenuIndex = editMenuAntiRecoilKickStrength; // Advanced Anti-recoil can access kick duration/strength
			} else if((editMenuIndex == editMenuAntiRecoilKickStrength) && (userData[vAntiRecoil + menuProfile] == antiRecoilAdvanced)) {
				editMenuIndex = editMenuAntiRecoilKickCounter;
			} else if(editMenuIndex == editMenuAntiRecoilKickCounter) {
				editMenuIndex = editMenuAntiRecoil; // Advanced Anti-recoil cannot go past the counter
			} else if((editMenuIndex == editMenuAntiRecoilExpert) && (userData[vAntiRecoil + menuProfile] == antiRecoilExpert)) {
				editMenuIndex = editMenuAntiRecoil; // Expert Anti-recoil only has one menu
			} else if((editMenuIndex == editMenuAntidrift) && !userData[vAntiDrift]) {
				menuActionFailed(); // Anti-drift must be enabled to see rest of options
			} else if(editMenuIndex == editMenuAntidriftCalibration && antiDriftCalibrationState) {
				menuActionFailed(); // Cannot leave calibration menu if calibration is running
			} else {
				editMenuSelectedColumn = 0;
				editMenuSelectedRow = 0;
				editMenuIndex = cycleListOption(editMenuIndex, cycleValueUp, editMenuItems[modMenuIndex][editMenuMax], editMenuItems[modMenuIndex][editMenuMin]);
				// Will not alert in DisplayEditMenu due to constant repeat, so enable here
				if(editMenuIndex == editMenuAntidriftTest) {
					menuActionSuccess();	
				}
			}
			break;
		} default {
			menuActionFailed();
		}
	}
}

int editMenuSelectionEditValue, editMenuSelectionEditVariable;

function dispatchAdsDualSelectionEdit(direction) {
	
	editMenuSelectionEditValue = iif(direction == XB1_UP || direction == XB1_DOWN, 10, 1);
	editMenuSelectionEditVariable = iif(!editMenuSelectedRow, editMenuVariable1, editMenuVariable2);
	
	if(direction == XB1_UP || direction == XB1_RIGHT) {
		if(userData[editMenuParent + menuProfile] == assistAdsOnly) {
			userData[editMenuVariable1 + menuProfile] = cycleEditValue(userData[editMenuVariable1 + menuProfile], cycleValueUp, editMenuSelectionEditValue, editMenuAdsMaxValue);
		} else if(userData[editMenuParent + menuProfile] == assistAdsOrFire || userData[editMenuParent + menuProfile] == assistAdsAndFireOrAds) {
			userData[editMenuSelectionEditVariable + menuProfile] = cycleEditValue(userData[editMenuSelectionEditVariable + menuProfile], cycleValueUp, editMenuSelectionEditValue, editMenuAdsMaxValue);
		} else {
			userData[editMenuVariable2 + menuProfile] = cycleEditValue(userData[editMenuVariable2 + menuProfile], cycleValueUp, editMenuSelectionEditValue, editMenuAdsMaxValue);
		}
	} else if(direction == XB1_DOWN || direction == XB1_LEFT) {
		if(userData[editMenuParent + menuProfile] == assistAdsOnly) {
			userData[editMenuVariable1 + menuProfile] = cycleEditValue(userData[editMenuVariable1 + menuProfile], cycleValueDown, editMenuSelectionEditValue, editMenuAdsMinValue);
		} else if(userData[editMenuParent + menuProfile] == assistAdsOrFire || userData[editMenuParent + menuProfile] == assistAdsAndFireOrAds) {
			userData[editMenuSelectionEditVariable + menuProfile] = cycleEditValue(userData[editMenuSelectionEditVariable + menuProfile], cycleValueDown, editMenuSelectionEditValue, editMenuAdsMinValue);
		} else {
			userData[editMenuVariable2 + menuProfile] = cycleEditValue(userData[editMenuVariable2 + menuProfile], cycleValueDown, editMenuSelectionEditValue, editMenuAdsMinValue);
		}
	} else {
		menuActionFailed();
	}
	
}

function dispatchAntiRecoilExpert(direction) {
	if((direction == XB1_LB) || (direction == XB1_RB)) {
		editMenuSelectedPage = !editMenuSelectedPage; // Toggle pages
	} else {
		switch(direction) {
			case XB1_UP {
				editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueDown, 1, 0);
				break;
			} case XB1_DOWN {
				if(!(editMenuSelectedColumn == 1 && editMenuSelectedRow == 1)) {
					editMenuSelectedRow = cycleEditValue(editMenuSelectedRow, cycleValueUp, 1, 2);
				} else {
					menuActionFailed();
				}
				break;
			} case XB1_LEFT {
				if(editMenuSelectedColumn) {
					editMenuSelectedColumn--;
				} else {
					editMenuIndex = editMenuAntiRecoil; 
				}
				break;
			} case XB1_RIGHT {
				if(editMenuSelectedRow != 2) {
					if(!editMenuSelectedColumn) {
						editMenuSelectedColumn++;
					} else {
						editMenuSelectedColumn = 0; // Reset column since we are leaving this menu
						editMenuIndex = editMenuAntiRecoil;
					}
				} else {
					menuActionFailed();
				}
				break;
			} default {
				dispatchMenuAction(direction);
			}
		}
	}
}

function dispatchAdsAntiRecoilExpert(direction) {
	switch(direction) {
		case XB1_UP {
			if(!editMenuSelectedPage) { // Vertical values
				if(!editMenuSelectedColumn) { // Strength values
					userData[vAntiRecoilStart + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStart + menuProfile + (editMenuSelectedRow * 3)], cycleValueUp, 10, 100);
				} else {
					userData[vAntiRecoilStartTime + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStartTime + menuProfile + (editMenuSelectedRow * 3)], cycleValueUp, 10, 200);
				}
			} else {
				if(!editMenuSelectedColumn) { // Strength values
					userData[vAntiRecoilStartH + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStartH + menuProfile + (editMenuSelectedRow * 3)], cycleValueUp, 10, 30);
				} else { // Time values
					userData[vAntiRecoilStartTimeH + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStartTimeH + menuProfile + (editMenuSelectedRow * 3)], cycleValueUp, 10, 200);
				}
			}
			break;	
		} case XB1_DOWN {
			if(!editMenuSelectedPage) { // Vertical values
				if(!editMenuSelectedColumn) { // Strength values
					userData[vAntiRecoilStart + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStart + menuProfile + (editMenuSelectedRow * 3)], cycleValueDown, 10, 0);
				} else {
					userData[vAntiRecoilStartTime + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStartTime + menuProfile + (editMenuSelectedRow * 3)], cycleValueDown, 10, 0);
				}
			} else {
				if(!editMenuSelectedColumn) { // Strength values
					userData[vAntiRecoilStartH + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStartH + menuProfile + (editMenuSelectedRow * 3)], cycleValueDown, 10, -30);
				} else { // Time values
					userData[vAntiRecoilStartTimeH + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStartTimeH + menuProfile + (editMenuSelectedRow * 3)], cycleValueDown, 10, 0);
				}
			}
			break;
		} case XB1_LEFT {
			if(!editMenuSelectedPage) { // Vertical values
				if(!editMenuSelectedColumn) { // Strength values
					userData[vAntiRecoilStart + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStart + menuProfile + (editMenuSelectedRow * 3)], cycleValueDown, 1, 0);
				} else {
					userData[vAntiRecoilStartTime + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStartTime + menuProfile + (editMenuSelectedRow * 3)], cycleValueDown, 1, 0);
				}
			} else {
				if(!editMenuSelectedColumn) { // Strength values
					userData[vAntiRecoilStartH + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStartH + menuProfile + (editMenuSelectedRow * 3)], cycleValueDown, 1, -30);
				} else { // Time values
					userData[vAntiRecoilStartTimeH + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStartTimeH + menuProfile + (editMenuSelectedRow * 3)], cycleValueDown, 1, 0);
				}
			}
			break;
		} case XB1_RIGHT {
			if(!editMenuSelectedPage) { // Vertical values
				if(!editMenuSelectedColumn) { // Strength values
					userData[vAntiRecoilStart + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStart + menuProfile + (editMenuSelectedRow * 3)], cycleValueUp, 1, 100);
				} else {
					userData[vAntiRecoilStartTime + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStartTime + menuProfile + (editMenuSelectedRow * 3)], cycleValueUp, 1, 200);
				}
			} else {
				if(!editMenuSelectedColumn) { // Strength values
					userData[vAntiRecoilStartH + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStartH + menuProfile + (editMenuSelectedRow * 3)], cycleValueUp, 1, 30);
					set_val(TRACE_1, vAntiRecoilStartH);
					set_val(TRACE_2, menuProfile);
					set_val(TRACE_3, editMenuSelectedRow * 3);
					set_val(TRACE_4, vAntiRecoilStartH + menuProfile + (editMenuSelectedRow * 3));
				} else { // Time values
					userData[vAntiRecoilStartTimeH + menuProfile + (editMenuSelectedRow * 3)] = cycleEditValue(userData[vAntiRecoilStartTimeH + menuProfile + (editMenuSelectedRow * 3)], cycleValueUp, 1, 200);
				}
			}
			break;
		} default {
			menuActionFailed();
		}
	}
}

function dispatchAntiDriftCalibrate(direction) {
	if(direction == XB1_LB || direction == XB1_RB) {
		antiDriftCalibrationStick = !antiDriftCalibrationStick;
	} else {
		switch(direction) {
			case XB1_VIEW {
				if(!antiDriftCalibrationState) {
					if(antiDriftCalibrationStick == antiDriftLeftStick) {
						userData[vAntiDriftLeft + antiDriftCalibrationDirection] = 0;
					} else {
						userData[vAntiDriftRight + antiDriftCalibrationDirection] = 0;
					}
					antiDriftCalibrationCanSet = 3;
					combo_run(cboCalibrationComplete); // Alert user of status
					antiDriftCalibrationState = !antiDriftCalibrationState; // Keep process disabled as combo will flop this value positive
				}
				break;
			} case XB1_A {
				if(antiDriftCalibrationState) {
					// Only set if range was met
					if(antiDriftCalibrationCanSet) {
						determineAntidriftValue(); // Determine the value to set
					}
					combo_run(cboCalibrationComplete); // Alert user of status
				} else {
					antiDriftCalibrationState = !antiDriftCalibrationState; // Enter calibration process
				}
				break;
			} default {
				dispatchMenuAction(direction);
			}
		}
	}
}

function dispatchAdsAntiDriftCalibrate(direction) {
	switch(direction) {
		case XB1_UP {
			if(antiDriftCalibrationDirection != antiDriftUp) {
				antiDriftCalibrationDirection = antiDriftUp;
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_DOWN {
			if(antiDriftCalibrationDirection != antiDriftDown) {
				antiDriftCalibrationDirection = antiDriftDown;
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_LEFT {
			if(antiDriftCalibrationDirection != antiDriftLeft) {
				antiDriftCalibrationDirection = antiDriftLeft;
			} else {
				menuActionFailed();
			}
			break;
		} case XB1_RIGHT {
			if(antiDriftCalibrationDirection != antiDriftRight) {
				antiDriftCalibrationDirection = antiDriftRight;
			} else {
				menuActionFailed();
			}
			break;
		} default {
			menuActionFailed()
		}
	}
}

function dispatchAdsAntiRecoilWeapon(direction) {
	switch(direction) {
		case XB1_UP {
			userData[vAntiRecoilCategory + menuProfile] = cycleListOption(userData[vAntiRecoilCategory + menuProfile], cycleValueDown, antiRecoilCategoryAR, antiRecoilCategoryLMG);
			userData[vAntiRecoilWeapon + menuProfile] = weaponSelectCategoryMenu[userData[vAntiRecoilCategory + menuProfile]][0];
			break;
		} case XB1_DOWN {
			userData[vAntiRecoilCategory + menuProfile] = cycleListOption(userData[vAntiRecoilCategory + menuProfile], cycleValueUp, antiRecoilCategoryLMG, antiRecoilCategoryAR);
			userData[vAntiRecoilWeapon + menuProfile] = weaponSelectCategoryMenu[userData[vAntiRecoilCategory + menuProfile]][0];
			break;
		} case XB1_LEFT {
			userData[vAntiRecoilWeapon + menuProfile] = cycleListOption(userData[vAntiRecoilWeapon + menuProfile], cycleValueDown, weaponSelectCategoryMenu[userData[vAntiRecoilCategory + menuProfile]][0], weaponSelectCategoryMenu[userData[vAntiRecoilCategory + menuProfile]][1]);
			break;
		} case XB1_RIGHT {
			userData[vAntiRecoilWeapon + menuProfile] = cycleListOption(userData[vAntiRecoilWeapon + menuProfile], cycleValueUp, weaponSelectCategoryMenu[userData[vAntiRecoilCategory + menuProfile]][1], weaponSelectCategoryMenu[userData[vAntiRecoilCategory + menuProfile]][0]);
			break;
		} default {
			dispatchMenuAction(direction);
		}
	}
}

// Handler function for Anti-recoil Weapon Select intensity values
function dispatchWeaponSelectionEdit(direction) {
	switch(direction) {
		case XB1_UP {
			if(editMenuSelectedRow == 0) {
				userData[vAntiRecoilCorrectionV + userData[vAntiRecoilWeapon + menuProfile]] = cycleEditValue(userData[vAntiRecoilCorrectionV + userData[vAntiRecoilWeapon + menuProfile]], cycleValueUp, 10, 512);
			} else {
				userData[vAntiRecoilCorrectionH + userData[vAntiRecoilWeapon + menuProfile]] = cycleEditValue(userData[vAntiRecoilCorrectionH + userData[vAntiRecoilWeapon + menuProfile]], cycleValueUp, 10, 512);
			}
			break;
		} case XB1_DOWN {
			if(editMenuSelectedRow == 0) {
				userData[vAntiRecoilCorrectionV + userData[vAntiRecoilWeapon + menuProfile]] = cycleEditValue(userData[vAntiRecoilCorrectionV + userData[vAntiRecoilWeapon + menuProfile]], cycleValueDown, 10, -512);
			} else {
				userData[vAntiRecoilCorrectionH + userData[vAntiRecoilWeapon + menuProfile]] = cycleEditValue(userData[vAntiRecoilCorrectionH + userData[vAntiRecoilWeapon + menuProfile]], cycleValueDown, 10, -512);
			}
			break;
		} case XB1_LEFT {
			if(editMenuSelectedRow == 0) {
				userData[vAntiRecoilCorrectionV + userData[vAntiRecoilWeapon + menuProfile]] = cycleEditValue(userData[vAntiRecoilCorrectionV + userData[vAntiRecoilWeapon + menuProfile]], cycleValueDown, 1, -512);
			} else {
				userData[vAntiRecoilCorrectionH + userData[vAntiRecoilWeapon + menuProfile]] = cycleEditValue(userData[vAntiRecoilCorrectionH + userData[vAntiRecoilWeapon + menuProfile]], cycleValueDown, 1, -512);
			}
			break;
		} case XB1_RIGHT {
			if(editMenuSelectedRow == 0) {
				userData[vAntiRecoilCorrectionV + userData[vAntiRecoilWeapon + menuProfile]] = cycleEditValue(userData[vAntiRecoilCorrectionV + userData[vAntiRecoilWeapon + menuProfile]], cycleValueUp, 1, 512);
			} else {
				userData[vAntiRecoilCorrectionH + userData[vAntiRecoilWeapon + menuProfile]] = cycleEditValue(userData[vAntiRecoilCorrectionH + userData[vAntiRecoilWeapon + menuProfile]], cycleValueUp, 1, 512);
			}
			break;		
		} default {
			menuActionFailed();
		}
	}
}

// Cycles the edit menu
function cycleEditMenu(direction) {
	// Enable display update
	displayUpdate = TRUE;
	
	//menuType, menuAdsType, menuVariable1, menuVariable2, menuMinValue, menuMaxValue, menuAdsMinValue, menuAdsMaxValue
	editMenuHoldingADS = get_ival(button[ads]);
	editMenuType = menuData[editMenuIndex][menuType];
	editMenuAdsType = menuData[editMenuIndex][menuAdsType];
	editMenuVariable1 = menuData[editMenuIndex][menuVariable1];
	editMenuVariable2 = menuData[editMenuIndex][menuVariable2];
	editMenuParent = menuData[editMenuIndex][menuParent];
	editMenuMinValue = menuData[editMenuIndex][menuMinValue];
	editMenuMaxValue = menuData[editMenuIndex][menuMaxValue];
	editMenuAdsMinValue = menuData[editMenuIndex][menuAdsMinValue];
	editMenuAdsMaxValue = menuData[editMenuIndex][menuAdsMaxValue];
	
	if(!editMenuHoldingADS) {
		switch(editMenuType) {
			case menuAntiDriftCalibrate {
				dispatchAntiDriftCalibrate(direction);
				break;
			} case menuAntiRecoilExpert {
				dispatchAntiRecoilExpert(direction);
				break;
			} case menuAssistDualSelection {
				dispatchAssistDualSelection(direction);
				break;
			} case menuAssistRowSelection {
				dispatchAssistRowSelection(direction);
				break;
			} case menuCycleListOption {
				dispatchCycleListOption(direction, iif(isGlobalOption() || !editMenuItems[modMenuIndex][editMenuShowProfile], 0, menuProfile));
				break;
			} case menuMultiSelection {
				dispatchMenuMultiSelection(direction);
				break;
			} case menuNone {
				dispatchMenuNone(direction);
				break;
			} case menuToggle {
				dispatchMenuToggle(direction);
				break;
			} case menuToggleOnOff {
				dispatchMenuToggleOnOff(direction, iif(isGlobalOption() || !editMenuItems[modMenuIndex][editMenuShowProfile], 0, menuProfile));
				break;
			} default {
				dispatchMenuAction(direction);
			}
		}
	} else {
		switch(editMenuAdsType) {
			case menuAdsAntiDriftCalibrate {
				dispatchAdsAntiDriftCalibrate(direction);
				break;
			} case menuAdsAntiRecoilExpert {
				dispatchAdsAntiRecoilExpert(direction);
				break;
			} case menuAdsAntiRecoilWeapon {
				dispatchAdsAntiRecoilWeapon(direction);
				break;
			} case menuAdsAssistDualSelection {
				dispatchAdsAssistDualSelection(direction);
				break;
			} case menuAdsDualSelectionEdit {
				dispatchAdsDualSelectionEdit(direction);
				break;
			} case menuAdsCycleEditValue {
				dispatchAdsCycleEditValue(direction, iif(isGlobalOption() || !editMenuItems[modMenuIndex][editMenuShowProfile], 0, menuProfile), editMenuVariable2, editMenuAdsMinValue, editMenuAdsMaxValue);
				break;
			} case menuAdsCycleListOption {
				dispatchAdsCycleListOption(direction);
				break;
			} case menuAdsMultiSelection {
				dispatchAdsMultiSelection(direction);
				break;
			} case menuAdsNone {
				menuActionFailed();
				break;
			} case menuAdsToggle {
				dispatchAdsToggle(direction, iif(isGlobalOption() || !editMenuItems[modMenuIndex][editMenuShowProfile], 0, menuProfile));
				break;
			} case menuWeaponSelectionEdit {
				dispatchWeaponSelectionEdit(direction);
				break;
			}
		}
	}
	
	return;
}

// Cycle an edit menu value by step amount with change limited to a threshold
function cycleEditValue(value, direction, step, threshold) {
	
	// See what direction we are cycling the values
	if(direction == cycleValueUp) {
		if((value + step) <= threshold) {
			return (value + step);
		} else if(value == threshold) {
			menuActionFailed();
		} else {
			return threshold;
		}
	} else {
		if((value - step) >= threshold) {
			return (value - step);
		} else if(value == threshold) {
			menuActionFailed();
		} else {
			return threshold;
		}
	}
	
	return value;
}

// Cycle a menu value
function cycleListOption(value, direction, threshold, reset_value) {
	
	// See what direction we are cycling the values
	if(direction == cycleValueUp) {
		if((value + 1) <= threshold) {
			return value + 1;
		}
	} else {
		if((value - 1) >= threshold) {
			return value - 1;
		}
	}
	
	return reset_value;
}

// Cycle mod menu value
function cycleModMenu(direction) {
	
	displayUpdate = TRUE; // Enable display update
	
	switch(direction) {
		case modMenuEnter {
			displayDepth++; // Advance to Edit Menu
			editMenuIndex = editMenuItems[modMenuIndex][editMenuMin]; // Set new edit menu index
			break;
		} case modMenuExit {
			displayDepth--; // Exit to Home Screen
			combo_run(cboSaveSettings); // Save settings upon exiting mod menu
			break;
		} case modMenuDown {
			modMenuIndex++; // Cycle to next menu
			if(modMenuIndex > modMenuToggles) { // Check boundaries
				modMenuIndex = modMenuAimAssist; // Out of bounds, set to minimum
			}
			menuActionSuccess(); // Alert for successful action
			break;
		} case modMenuUp {
			modMenuIndex--; // Cycle to previous menu
			if(modMenuIndex < modMenuAimAssist) { // Check boundaries
				modMenuIndex = modMenuToggles; // Out of bounds, set to maximum
			}
			menuActionSuccess(); // Alert for successful action
			break;
		}
	}
}

// Determines what to set the anti-drift value to, if a new value was found
function determineAntidriftValue() {
	if(antiDriftCalibrationStick == antiDriftLeftStick) {
		switch(antiDriftCalibrationDirection) {
			case antiDriftUp {
				antiDriftCalibrationValue = get_ival(POLAR_LY);
				if((antiDriftCalibrationValue < userData[vAntiDriftLeft + antiDriftUp]) || (userData[vAntiDriftLeft + antiDriftUp] == 0)) {
					userData[vAntiDriftLeft + antiDriftUp] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftDown {
				antiDriftCalibrationValue = get_ival(POLAR_LY);
				if((antiDriftCalibrationValue > userData[vAntiDriftLeft + antiDriftDown]) || (userData[vAntiDriftLeft + antiDriftDown] == 0)) {
					userData[vAntiDriftLeft + antiDriftDown] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftLeft {
				antiDriftCalibrationValue = get_ival(POLAR_LX);
				if((antiDriftCalibrationValue < userData[vAntiDriftLeft + antiDriftLeft]) || (userData[vAntiDriftLeft + antiDriftLeft] == 0)) {
					userData[vAntiDriftLeft + antiDriftLeft] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftRight {
				antiDriftCalibrationValue = get_ival(POLAR_LX);
				if((antiDriftCalibrationValue > userData[vAntiDriftLeft + antiDriftRight]) || (userData[vAntiDriftLeft + antiDriftRight] == 0)) {
					userData[vAntiDriftLeft + antiDriftRight] = antiDriftCalibrationValue;
				}
				break;
			}
		}
	} else {
		switch(antiDriftCalibrationDirection) {
			case antiDriftUp {
				antiDriftCalibrationValue = get_ival(POLAR_RY);
				if((antiDriftCalibrationValue < userData[vAntiDriftRight + antiDriftUp]) || (userData[vAntiDriftRight + antiDriftUp] == 0)) {
					userData[vAntiDriftRight + antiDriftUp] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftDown {
				antiDriftCalibrationValue = get_ival(POLAR_RY);
				if((antiDriftCalibrationValue > userData[vAntiDriftRight + antiDriftDown]) || (userData[vAntiDriftRight + antiDriftDown] == 0)) {
					userData[vAntiDriftRight + antiDriftDown] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftLeft {
				antiDriftCalibrationValue = get_ival(POLAR_RX);
				if((antiDriftCalibrationValue < userData[vAntiDriftRight + antiDriftLeft]) || (userData[vAntiDriftRight + antiDriftLeft] == 0)) {
					userData[vAntiDriftRight + antiDriftLeft] = antiDriftCalibrationValue;
				}
				break;
			} case antiDriftRight {
				antiDriftCalibrationValue = get_ival(POLAR_RX);
				if((antiDriftCalibrationValue > userData[vAntiDriftRight + antiDriftRight]) || (userData[vAntiDriftRight + antiDriftRight] == 0)) {
					userData[vAntiDriftRight + antiDriftRight] = antiDriftCalibrationValue;
				}
				break;
			}
		}
	}
}

// Handles a pressed toggle combination sequence
function dispatchToggle(id) {
	// Determine which toggle is triggered and handle it accordingly
	switch(id) {
		case toggleProfile {
			if(currentProfile != 2) {
				switchProfile(!currentProfile); // Switch profiles
			}
			break;	
		} case toggleUniversal {
			switchProfile(iif(currentProfile == 2, 0, 2));
			break;
		} case toggleAkimbo {
			userData[vOptionAkimbo + currentProfile] = !userData[vOptionAkimbo + currentProfile];
			combo_restart(cboToggleAkimbo);
			break;
		} case toggleAutoADS {
			userData[vOptionAutoAdsFire + currentProfile] = !userData[vOptionAutoAdsFire + currentProfile];
			combo_restart(cboToggleAutoADS);
			break;
		} case toggleAutoFocus {
			userData[vOptionAutoFocus + currentProfile] = !userData[vOptionAutoFocus + currentProfile];
			combo_restart(cboToggleAutoFocus); // Update with Auto Focus alert
			break;
		} case toggleAutoPing {
			userData[vOptionAutoPing + currentProfile] = !userData[vOptionAutoPing + currentProfile];
			combo_restart(cboToggleAutoPing); // Update with Auto Ping alert
			break;
		} case toggleBackpackSwap {
			combo_run(cboOptionBackpackSwap);
			break;
		} case toggleDropShot {
			userData[vOptionDropShot + currentProfile] = !userData[vOptionDropShot + currentProfile];
			combo_restart(cboToggleDropShot);
			break;
		} case toggleFastMelee {
			userData[vOptionFastMelee + currentProfile] = cycleListOption(userData[vOptionFastMelee + currentProfile], cycleValueUp, 2, 0);
			combo_restart(cboToggleFastMelee); // Update with Fast Melee alert
			break;
		} case toggleRapidFire {
			userData[vOptionRapidFire + currentProfile] = !userData[vOptionRapidFire + currentProfile];
			combo_restart(cboToggleRapidFire); // Update with Rapid Fire alert
			break;
		} case toggleTacticalSprint {
			userData[vOptionTacticalSprint] = !userData[vOptionTacticalSprint];
			combo_restart(cboToggleTacticalSprint);
			break;
		} case toggleQuickScope {
			userData[vOptionQuickScope + currentProfile] = !userData[vOptionQuickScope + currentProfile];
			combo_restart(cboToggleQuickScope);
			break;
		}
	}
}


// Displays stick values for the Anti-drift Test menu
function displayAntidriftTest(x, y, line) {
	// Build display
	insertCharacter(iif(x == POLAR_LX, ASCII_UPPER_L, ASCII_UPPER_R));
	insertCharacter(ASCII_COLON);
	insertCharacter(ASCII_SPACE);
	insertNumber(get_val(x));
	insertCharacter(ASCII_COMMA);
	insertNumber(get_val(y));
	flushBuffer(alignLeft, line, OLED_FONT_SMALL, OLED_WHITE);
}

// Displays the current anti-drift X/Y values for both sticks
function displayAntidriftValues() {
	// Draw a separator line down middle of OLED
	line_oled(OLED_WIDTH >> 1, lineNumber[0] - 4, OLED_WIDTH >> 1, OLED_HEIGHT - 2, 1, OLED_WHITE);
	// Draw each value
	for(j = 0; j < 4; j++) {
		// Left stick
		insertString(antiDriftValues[j]);
		insertNumber(userData[vAntiDriftLeft + j]);
		flushBuffer(alignLeft - 2, 21 + (j * 10), OLED_FONT_SMALL, OLED_WHITE);
		// Right stick
		insertString(antiDriftValues[j]);
		insertNumber(userData[vAntiDriftRight + j]);
		flushBuffer((OLED_WIDTH >> 1) + 3, 21 + (j * 10), OLED_FONT_SMALL, OLED_WHITE);
	}
}

// Draws the 'Anti-recoil Expoert' selection menu
function displayAntiRecoilSelection() {
	rect_oled(alignLeft - 2, lineNumber[editMenuSelectedRow] - 2, (OLED_WIDTH >> 1) +( OLED_FONT_SMALL_WIDTH << 1) - 4, OLED_FONT_SMALL_HEIGHT + 3, 0, iif(editMenuSelectedColumn, OLED_BLACK, OLED_WHITE));
	rect_oled(OLED_WIDTH - (OLED_WIDTH >> 1) + (OLED_FONT_SMALL_WIDTH << 1) + 2, lineNumber[editMenuSelectedRow] - 2, (OLED_WIDTH >> 1) - 5 - (OLED_FONT_SMALL_WIDTH << 1), OLED_FONT_SMALL_HEIGHT + 3, 0, iif(editMenuSelectedColumn, OLED_WHITE, OLED_BLACK));
	
	// Loop through each anti-recoil variable and display the strength/timer
	for(j = 0; j < 3; j++) {
	
		// Print header
		insertString(iif(editMenuSelectedPage, antiRecoilExpertMenu[j + 3], antiRecoilExpertMenu[j]));
		// Determine which value to display
		if(j == 0 ) {
			insertNumber(iif(editMenuSelectedPage, userData[vAntiRecoilStartH + menuProfile], userData[vAntiRecoilStart + menuProfile]));
		} else if(j == 1) {
			insertNumber(iif(editMenuSelectedPage, userData[vAntiRecoilMidH + menuProfile], userData[vAntiRecoilMid + menuProfile]));
			set_val(TRACE_5, vAntiRecoilMidH);
			set_val(TRACE_6, userData[vAntiRecoilMidH + menuProfile]);
		} else if(j == 2) {
			insertNumber(iif(editMenuSelectedPage, userData[vAntiRecoilEndH + menuProfile], userData[vAntiRecoilEnd + menuProfile]));
		}
		// Flush buffer
		flushBuffer(alignLeft, lineNumber[j], OLED_FONT_SMALL, OLED_WHITE);
		
		// Print time values
		if(j == 0) {
			insertNumber(iif(editMenuSelectedPage, userData[vAntiRecoilStartTimeH + menuProfile], userData[vAntiRecoilStartTime + menuProfile]) * (10 + vmSpeedValue[userData[vVMSpeed]]));
		} else if(j == 1) {
			insertNumber(iif(editMenuSelectedPage, userData[vAntiRecoilMidTimeH + menuProfile], userData[vAntiRecoilMidTime + menuProfile]) * (10 + vmSpeedValue[userData[vVMSpeed]]));
		}
				
		// Append "ms" to times
		if(j != 2) {
			insertCharacter(ASCII_LOWER_M);
			insertCharacter(ASCII_LOWER_S);
		}
		
		// Flush buffer for time values
		flushBuffer(OLED_WIDTH - (OLED_WIDTH >> 1) + (OLED_FONT_SMALL_WIDTH << 1) + 4, lineNumber[j], OLED_FONT_SMALL, OLED_WHITE);
	}
}

// Draws a list of two items and highlights the selected item
function displayDualSelection(type, message1, message2, value1, value2) {
	// Draw selected item background
	rect_oled(alignLeft, lineNumber[editMenuSelectedRow] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
	// Generate first item
	buildSelectedItemBuffer(type, message1, value1);
	flushSelectedItemBuffer(0, lineNumber[0]);
	// Generate second item
	buildSelectedItemBuffer(type, message2, value2);
	flushSelectedItemBuffer(1, lineNumber[1]);
}

function isGlobalOption() {
	if(editMenuIndex == editMenuBackpackSwap
		|| editMenuIndex == editMenuBunnyHop
		|| editMenuIndex == editMenuDolphinCancel
		|| editMenuIndex == editMenuGWalk
		|| editMenuIndex == editMenuHairTriggers
		|| editMenuIndex == editMenuSlideCancel
		|| editMenuIndex == editMenuTacticalSprint) {
		return TRUE;
	}
	
	return FALSE;
}

// Display edit menu
function displayEditMenu() {
	// Clears the screen and draw a border to prep edit menu display
 	drawBorder();
 	
 	// Alert for success unless IgnoreAlert is enabled
 	if(!antiDriftCalibrationState && (editMenuIndex != editMenuAntidriftTest)) {
  		menuActionSuccess();
	}
	
	// Display edit menu title and draw a line beneath it for formatting
	printText(alignCenter, alignTop, editMenuNames[editMenuIndex], OLED_FONT_SMALL, OLED_WHITE);
	line_oled(1, OLED_FONT_SMALL_HEIGHT + 7, 127, OLED_FONT_SMALL_HEIGHT + 7, 1, OLED_WHITE);
	
	// See if we should draw a line and display profile name
	if(editMenuItems[modMenuIndex][editMenuShowProfile] && editMenuIndex != editMenuAntiRecoilExpert) {
		line_oled(1, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 127, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 1, OLED_WHITE); // Draw bottom line
		// Determine footer to print
		if(editMenuIndex == editMenuAntiRecoilWeaponCorrectionValue) {
			printText(alignCenter, alignBottom, weaponName[userData[vAntiRecoilWeapon + menuProfile]], OLED_FONT_SMALL, OLED_WHITE); // Display weapon name
		} else if(isGlobalOption()) {
			printText(alignCenter, alignBottom, profileName[3], OLED_FONT_SMALL, OLED_WHITE); // Display "All Profiles"
		} else {
			printText(alignCenter, alignBottom, profileName[menuProfile], OLED_FONT_SMALL, OLED_WHITE); // Display profile name
		}
	} else if(modMenuIndex == modMenuToggles || editMenuIndex == editMenuProfileSwitch || editMenuIndex == editMenuUniversalSwitch) {
		line_oled(1, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 127, OLED_HEIGHT - OLED_FONT_SMALL_HEIGHT - 7, 1, OLED_WHITE); // Draw bottom line
		printText(alignCenter, alignBottom, toggleReset[iif(get_controller() == PIO_XB1, 1, 0)], OLED_FONT_SMALL, OLED_WHITE); // Display profile name
	}
	
	// See what setting we must display
	switch (editMenuIndex) {
		case editMenuAimAssist { // (Aim Assist)
			printText(alignCenter, alignCenter, assistStatus[userData[vAimAssist + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAimAssistBoost { // (Aim Assist) Type
			printText(alignCenter, alignCenter, aimAssistTypeName[userData[vAimAssistType + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAimAssistRadius { // (Aim Assist) Radius
			if(userData[vAimAssist + menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vAimAssistAdsRadius + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vAimAssist + menuProfile] == assistAdsOrFire || userData[vAimAssist + menuProfile] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vAimAssistAdsRadius + menuProfile], userData[vAimAssistFireRadius + menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vAimAssistFireRadius + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuAimAssistShape { // (Aim Assist) Shape
			if(userData[vAimAssist + menuProfile] == assistAdsOnly) {
				printText(alignCenter, alignCenter, aimAssistShapeName[userData[vAimAssistAdsShape + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			} else if(userData[vAimAssist + menuProfile] == assistAdsOrFire || userData[vAimAssist + menuProfile] == assistAdsAndFireOrAds) {
				displayDualSelection(displayString, aimAssistTypeMsg[0], aimAssistTypeMsg[1], aimAssistShapeName[userData[vAimAssistAdsShape + menuProfile]], aimAssistShapeName[userData[vAimAssistFireShape + menuProfile]]);
			} else {
				printText(alignCenter, alignCenter, aimAssistShapeName[userData[vAimAssistFireShape + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuAimAssistSpeed { // (Aim Assist) Speed
			if(userData[vAimAssist + menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vAimAssistAdsSpeed + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vAimAssist + menuProfile] == assistAdsOrFire || userData[vAimAssist + menuProfile] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vAimAssistAdsSpeed + menuProfile], userData[vAimAssistFireSpeed + menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vAimAssistFireSpeed + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuRotationAssist { // (Aim Assist) Rotation Assist
			printText(alignCenter, alignCenter, assistStatus[userData[vRotationAssist + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuRotationShape { // (Aim Assist) Rotation Assist Shape
			if(userData[vRotationAssist + menuProfile] == assistAdsOnly) {
				printText(alignCenter, alignCenter, aimAssistRotationShape[userData[vRotationAdsShape + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			} else if(userData[vRotationAssist + menuProfile] == assistAdsOrFire || userData[vRotationAssist + menuProfile] == assistAdsAndFireOrAds) {
				displayDualSelection(displayString, aimAssistTypeMsg[0], aimAssistTypeMsg[1], aimAssistRotationShape[userData[vRotationAdsShape + menuProfile]], aimAssistRotationShape[userData[vRotationFireShape + menuProfile]]);
			} else {
				printText(alignCenter, alignCenter, aimAssistRotationShape[userData[vRotationFireShape + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuRotationRadius { // (Aim Assist) Rotation Assist Radius
			if(userData[vRotationAssist + menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vRotationAdsRadius + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vRotationAssist + menuProfile] == assistAdsOrFire || userData[vRotationAssist + menuProfile] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vRotationAdsRadius + menuProfile], userData[vRotationFireRadius + menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vRotationFireRadius + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuRotationSpeed { // (Aim Assist) Rotation Assist Speed
			if(userData[vRotationAssist + menuProfile] == assistAdsOnly) {
				if(userData[vRotationAdsShape + menuProfile] <= rasCeorin) {
					insertNumber(userData[vRotationAdsSpeed + menuProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]));
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
					flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
				} else {
					printNumber(alignCenter, alignCenter, userData[vRotationAdsSpeed + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
				}
			} else if(userData[vRotationAssist + menuProfile] == assistAdsOrFire || userData[vRotationAssist + menuProfile] == assistAdsAndFireOrAds) {
				// Build ADS display
				insertString(aimAssistTypeMsg[0]);
				
				if(userData[vRotationAdsShape + menuProfile] <= rasCeorin) {
					insertNumber(userData[vRotationAdsSpeed + menuProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]));
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
				} else {
					insertNumber(userData[vRotationAdsSpeed + menuProfile]);
				}
				
				// Determine if first item is selected
				if(editMenuSelectedRow == 0) {
					rect_oled(alignLeft, lineNumber[0] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
					flushBuffer(alignLeft, lineNumber[0], OLED_FONT_SMALL, OLED_BLACK);
				} else {
					flushBuffer(alignLeft, lineNumber[0], OLED_FONT_SMALL, OLED_WHITE);
				}
				
				// Build fire display
				insertString(aimAssistTypeMsg[1]);
				
				if(userData[vRotationFireShape + menuProfile] <= rasCeorin) {
					insertNumber(userData[vRotationFireSpeed + menuProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]));
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
				} else {
					insertNumber(userData[vRotationFireSpeed + menuProfile]);
				}
				
				// Determine if second item is selected
				if(editMenuSelectedRow == 1) {
					rect_oled(alignLeft, lineNumber[1] - 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
					flushBuffer(alignLeft, lineNumber[1], OLED_FONT_SMALL, OLED_BLACK);
				} else {
					flushBuffer(alignLeft, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
				}
			} else {
				if(userData[vRotationFireShape + menuProfile] <= rasCeorin) {
					insertNumber(userData[vRotationFireSpeed + menuProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]));
					insertCharacter(ASCII_LOWER_M);
					insertCharacter(ASCII_LOWER_S);
				} else {
					insertNumber(userData[vRotationFireSpeed + menuProfile]);
				}
				flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuInverseAssist { // (Aim Assist) Inverse Assist
			if(userData[vInverseAssist + menuProfile] == assistOff) {
				printText(alignCenter, alignCenter, assistStatus[userData[vInverseAssist + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			} else {
				printText(alignCenter, lineNumber[0], assistStatus[userData[vInverseAssist + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
				insertString(aimAssistRotationThreshold[0]);
				if(!userData[vInverseAssistThreshold + menuProfile]) {
					insertString(aimAssistRotationThreshold[1]);
				} else {
					insertNumber(userData[vInverseAssistThreshold + menuProfile]);
					insertCharacter(ASCII_PERCENT);
				}
				flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuIdleTargetAssist { // (Aim Assist) Idle Target Assist
			printText(alignCenter, alignCenter, assistStatus[userData[vIdleTargetAssist + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuIdleTargetTime { // (Aim Assist) Idle Target Assist Time
			if(!userData[vIdleTargetTime + menuProfile]) {
				insertString(aimAssistIdleTarget[0]);
			} else {
				insertNumber(userData[vIdleTargetTime + menuProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]));
				insertCharacter(ASCII_LOWER_M);
				insertCharacter(ASCII_LOWER_S);
			}
			flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuIdleTargetRadius {// (Aim Assist) Idle Target Assist Radius
			printNumber(alignCenter, alignCenter, userData[vIdleTargetRadius + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuIdleTargetShape {// (Aim Assist) Idle Target Assist Shape
			printText(alignCenter, alignCenter, aimAssistShapeName[userData[vIdleTargetShape + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuIdleTargetSpeed { // (Aim Assist) Idle Target Assist Speed
			printNumber(alignCenter, alignCenter, userData[vIdleTargetSpeed + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuMotionAssist { // (Aim Assist) Shape Motion
			printText(alignCenter, alignCenter, assistStatus[userData[vMotionAssist + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuMotionShape { // (Aim Assist) Motion Type
			if(userData[vMotionAssist + menuProfile] == assistAdsOnly) {
				printText(alignCenter, alignCenter, aimAssistShapeName[userData[vMotionAdsShape + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			} else if(userData[vMotionAssist + menuProfile] == assistAdsOrFire || userData[vMotionAssist + menuProfile] == assistAdsAndFireOrAds) {
				displayDualSelection(displayString, aimAssistTypeMsg[0], aimAssistTypeMsg[1], aimAssistShapeName[userData[vMotionAdsShape + menuProfile]], aimAssistShapeName[userData[vMotionFireShape + menuProfile]]);
			} else {
				printText(alignCenter, alignCenter, aimAssistShapeName[userData[vMotionFireShape + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuMotionRadius { // (Aim Assist) Motion Radius
			if(userData[vMotionAssist + menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vMotionAdsRadius + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vMotionAssist + menuProfile] == assistAdsOrFire || userData[vMotionAssist + menuProfile] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vMotionAdsRadius + menuProfile], userData[vMotionFireRadius + menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vMotionFireRadius + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuMotionSpeed { // (Aim Assist) Motion Speed
			if(userData[vMotionAssist + menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vMotionAdsSpeed + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vMotionAssist + menuProfile] == assistAdsOrFire || userData[vMotionAssist + menuProfile] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vMotionAdsSpeed + menuProfile], userData[vMotionFireSpeed + menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vMotionFireSpeed + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuShapePulse { // (Aim Assist) Shape Pulse
			printText(alignCenter, alignCenter, assistStatus[userData[vShapePulse + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuShapePulseRadius { // (Aim Assist) Shape Pulse Radius
			if(userData[vShapePulse + menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vShapePulseAdsRadius + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vShapePulse + menuProfile] == assistAdsOrFire || userData[vShapePulse + menuProfile] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vShapePulseAdsRadius + menuProfile], userData[vShapePulseFireRadius + menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vShapePulseFireRadius + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuShapeSpin { // (Aim Assist) Shape Spin
			printText(alignCenter, alignCenter, assistStatus[userData[vShapeSpin + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuShapeSpinType { // (Aim Assist) Shape Spin Type
			if(userData[vShapeSpin + menuProfile] == assistAdsOnly) {
				printText(alignCenter, alignCenter, aimAssistSpinType[userData[vShapeSpinAdsType + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			} else if(userData[vShapeSpin + menuProfile] == assistAdsOrFire || userData[vShapeSpin + menuProfile] == assistAdsAndFireOrAds) {
				displayDualSelection(displayString, aimAssistTypeMsg[0], aimAssistTypeMsg[1], aimAssistSpinType[userData[vShapeSpinAdsType + menuProfile]], aimAssistSpinType[userData[vShapeSpinFireType + menuProfile]]);
			} else {
				printText(alignCenter, alignCenter, aimAssistSpinType[userData[vShapeSpinFireType + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuShapeSpinAngle { // (Aim Assist) Shape Spin Angle
			if(userData[vShapeSpin + menuProfile] == assistAdsOnly) {
				printNumber(alignCenter, alignCenter, userData[vShapeSpinAdsAngle + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			} else if(userData[vShapeSpin + menuProfile] == assistAdsOrFire || userData[vShapeSpin + menuProfile] == assistAdsAndFireOrAds) {
				displayDualSelection(displayNumber, aimAssistTypeMsg[0], aimAssistTypeMsg[1], userData[vShapeSpinAdsAngle + menuProfile], userData[vShapeSpinFireAngle + menuProfile]);
			} else {
				printNumber(alignCenter, alignCenter, userData[vShapeSpinFireAngle + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			}
			break;
		} case editMenuAntidrift { // (Anti-drift) Toggle On/Off
			printText(alignCenter, alignCenter, toggleOffOn[userData[vAntiDrift]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAntidriftCalibration { // (Anti-drift) Calibration
			if(antiDriftCalibrationState) {
				// Calibration mode running
				printText(alignCenter, alignCenter, antiDriftCalibrationStateMsg[antiDriftCalibrationState], OLED_FONT_SMALL, OLED_WHITE);
			} else {
				// Calibration mode not running
				printText(alignCenter, lineNumber[0], antiDriftCalibrationStickPrompt[antiDriftCalibrationStick], OLED_FONT_SMALL, OLED_WHITE);
				printText(alignCenter, lineNumber[1], antiDriftCalibrationDirectionPrompt[antiDriftCalibrationDirection], OLED_FONT_SMALL, OLED_WHITE);
				rect_oled(alignLeft - 2, lineNumber[2], OLED_WIDTH - 6, OLED_FONT_SMALL_HEIGHT + 4, 1, OLED_WHITE);
				printText(alignCenter, lineNumber[2] + 3, antiDriftCalibrationStateMsg[antiDriftCalibrationState], OLED_FONT_SMALL, OLED_BLACK);
			}
			break;
		} case editMenuAntidriftTest { // (Anti-drift) Drift Test
			displayAntidriftTest(POLAR_LX, POLAR_LY, lineNumber[0]);
			displayAntidriftTest(POLAR_RX, POLAR_RY, lineNumber[1]);
			break;
		} case editMenuAntidriftValues { // (Anti-drift) Drift Values
			displayAntidriftValues();
			break;
		} case editMenuAntiRecoil { // (Anti-recoil)
			printText(alignCenter, alignCenter, antiRecoilStatus[userData[vAntiRecoil + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAntiRecoilStrength { // (Anti-recoil) Strength
			printNumber(alignCenter, alignCenter, userData[vAntiRecoilStrength + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuAntiRecoilKickStrength { // (Anti-recoil) Kick value [advanced]
			printNumber(alignCenter, alignCenter, userData[vAntiRecoilKickStrength + menuProfile], OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuAntiRecoilKickCounter { // (Anti-recoil) Kick duration [advanced]
			insertNumber(userData[vAntiRecoilKickDuration + menuProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]));
			insertCharacter(ASCII_LOWER_M);
			insertCharacter(ASCII_LOWER_S);
			flushBuffer(alignCenter, alignCenter, OLED_FONT_MEDIUM, OLED_WHITE);
			break;
		} case editMenuAntiRecoilExpert { // (Anti-recoil) Expert
			displayAntiRecoilSelection();
			break;
		} case editMenuAntiRecoilWeapon { // (Anti-recoil) Weapon
			printText(alignCenter, lineNumber[0], weaponCategory[userData[vAntiRecoilCategory + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			printText(alignCenter, lineNumber[1], weaponName[userData[vAntiRecoilWeapon + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAntiRecoilWeaponCorrectionValue { // (Anti-recoil) Weapon Select Correction
			displayDualSelection(displayNumber, weaponSelectCorrection[0], weaponSelectCorrection[1], userData[vAntiRecoilCorrectionV + userData[vAntiRecoilWeapon + menuProfile]], userData[vAntiRecoilCorrectionH + userData[vAntiRecoilWeapon + menuProfile]]);
			break;
		} case editMenuControllerButtonLayout { // (Controller) Button Layout
			printText(alignCenter, alignCenter, buttonLayoutName[userData[vControllerButtonLayout]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerBumperPing { // (Controller) Bumper Ping Swap
			printText(alignCenter, alignCenter, swappedStatus[userData[vControllerBumperPing]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerBumperTriggers { // (Controller) Bumper Triggers Flipped
			printText(alignCenter, alignCenter, flippedBumperTriggers[userData[vControllerBumperTriggers]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerStickLayout { // (Controller) Stick Layout
			printText(alignCenter, alignCenter, stickLayoutName[userData[vControllerStickLayout]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerAdsStickSwap { // (Controller) ADS Stick Swap
			printText(alignCenter, alignCenter, swappedStatus[userData[vControllerAdsStickSwap]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuControllerSlideDiveBehavior { // (Controller) Invert slide/dive behavior
			printText(alignCenter, alignCenter, invertSlideDive[userData[vControllerSlideDive]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAkimbo { // (Options) Akimbo)
			// If enabled, display status & values
			printText(alignCenter, lineNumber[0], toggleOffOn[userData[vOptionAkimbo + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			if(userData[vOptionAkimboSpeed + menuProfile]) {
				insertString(fireSpeed[0]);
				insertNumber(userData[vOptionAkimboSpeed + menuProfile]);
			} else {
				insertString(akimboAuto[0]);
			}
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAutoADS { // (Options) Auto ADS/Fire
			printText(alignCenter, alignCenter, autoADSFireType[userData[vOptionAutoAdsFire + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAutoFocus { // (Options) Auto Focus
			printText(alignCenter, lineNumber[0], toggleOffOn[userData[vOptionAutoFocus + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			if(!userData[vOptionAutoFocusInterval + menuProfile]) {
				insertString(autoFocus[1]);
			} else {
				insertString(autoFocus[0]);
				insertNumber((userData[vOptionAutoFocusInterval + menuProfile] + 1) * 120);
				insertCharacter(ASCII_LOWER_M);
				insertCharacter(ASCII_LOWER_S);
			}
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuAutoPing {
			printText(alignCenter, lineNumber[0], toggleOffOn[userData[vOptionAutoPing + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			if(!userData[vOptionAutoPingInterval + menuProfile]) {
				insertString(autoPing[1]);
			} else {
				insertString(autoPing[0]);
				insertNumber((userData[vOptionAutoPingInterval + menuProfile] + 1) * 120);
				insertCharacter(ASCII_LOWER_M);
				insertCharacter(ASCII_LOWER_S);
			}
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuBackpackSwap { // (Options) Backpack Swap
			printText(alignCenter, lineNumber[0], toggleOffOn[userData[vOptionBackpackSwap]], OLED_FONT_SMALL, OLED_WHITE);
			printText(alignCenter, lineNumber[1], backpackSwap[userData[vOptionBackpackSwapType]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuBunnyHop { // (Options) Bunny Hop
			printText(alignCenter, alignCenter, toggleOffOn[userData[vOptionBunnyHop]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuDolphinCancel { // (Options) Dolphin Cancel
			printText(alignCenter, alignCenter, toggleOffOn[userData[vOptionDolphinCancel]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuDropShot { // (Options) Drop Shot
			printText(alignCenter, lineNumber[0], toggleOffOn[userData[vOptionDropShot + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			insertString(dropShotAimAdjust[0]);
			insertNumber(userData[vOptionDropShotAimAdjust + menuProfile]);
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuFastMelee { // (Options) Fast Melee
			printText(alignCenter, alignCenter, fastMeleeType[userData[vOptionFastMelee + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuGWalk { // (Options) G-Walk
			if(!userData[vOptionGWalk]) {
				printText(alignCenter, alignCenter, gWalkType[userData[vOptionGWalk]], OLED_FONT_SMALL, OLED_WHITE);
			} else if(userData[vOptionGWalk] == gWalkReplace) {
				printText(alignCenter, alignCenter, gWalkType[iif(userData[vControllerSlideDive] == slideDiveStandard, userData[vOptionGWalk], userData[vOptionGWalk] + 1)], OLED_FONT_SMALL, OLED_WHITE);
			} else {
				printText(alignCenter, alignCenter, gWalkType[userData[vOptionGWalk]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuHairTriggers { // (Options) Hair Triggers
			printText(alignCenter, alignCenter, toggleOffOn[userData[vOptionHairTriggers]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuRapidFire { // (Options) Rapid Fire
			printText(alignCenter, lineNumber[0], toggleOffOn[userData[vOptionRapidFire + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			insertString(fireSpeed[0]);
			insertNumber(userData[vOptionRapidFireSpeed + menuProfile]);
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuRapidFirePistols { // (Options) Rapid Fire Pistols
			printText(alignCenter, lineNumber[0], toggleOffOn[userData[vOptionRapidFirePistols + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			insertString(fireSpeed[0]);
			insertNumber(userData[vOptionRapidFirePistolsSpeed + menuProfile]);
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuSlideCancel { // (Options) Slide Cancel
			if(userData[vOptionSlideCancel] == slideCancelMW) {
				printText(alignCenter, lineNumber[0], slideCancel[userData[vOptionSlideCancel]], OLED_FONT_SMALL, OLED_WHITE);
				insertString(slideDelay[0]);
				insertNumber(userData[vOptionSlideCancelDelay] * (10 + vmSpeedValue[userData[vVMSpeed]]));
				insertCharacter(ASCII_LOWER_M);
				insertCharacter(ASCII_LOWER_S);
				flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			} else {
				printText(alignCenter, alignCenter, slideCancel[userData[vOptionSlideCancel]], OLED_FONT_SMALL, OLED_WHITE);
			}
			break;
		} case editMenuTacticalSprint { // (Options) Tactical Sprint
			printText(alignCenter, alignCenter, toggleOffOn[userData[vOptionTacticalSprint]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuQuickScope { // (Options) Quick Scope
			printText(alignCenter, lineNumber[0], toggleOffOn[userData[vOptionQuickScope + menuProfile]], OLED_FONT_SMALL, OLED_WHITE);
			insertString(quickScopeDelay[0]);
			insertNumber(userData[vOptionQuickScopeDelay + menuProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]));
			insertCharacter(ASCII_LOWER_M);
			insertCharacter(ASCII_LOWER_S);
			flushBuffer(alignCenter, lineNumber[1], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuProfileSwitch { // (Profiles) Profile Switch
			displayDualSelection(displayString, profileToggleMsg[0], profileToggleMsg[1], iif(get_controller() == PIO_XB1, controllerButtonsXBOX[userData[vToggleButton + toggleProfile]], controllerButtonsPS4[userData[vToggleButton + toggleProfile]]), iif(get_controller() == PIO_XB1, controllerButtonsXBOX[userData[vToggleButton + toggleProfile + 1]], controllerButtonsPS4[userData[vToggleButton + toggleProfile + 1]])); 
			break;
		} case editMenuUniversalSwitch { // (Profiles) Universal Switch
			displayToggle(toggleUniversal);
			break;
		} case editMenuProfileColors { // (Profiles) Profile colors
			displayProfileColorSelection();
			break;
		//} case editMenuAimAcceleration { // (Settings) Aim Acceleration
		//	displayDualSelection(displayNumber, aimAcceleration[0], aimAcceleration[1], userData[vAimAccelerationReduction], userData[vAimAccelerationThreshold]);
		//	break;
		} case editMenuBlockRumble { // (Settings) Block Rumble
			printText(alignCenter, alignCenter, toggleOffOn[userData[vBlockRumble]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuDeadzone { // (Settings) Deadzone
			displayDualSelection(displayNumber, stickName[deadzoneLeft], stickName[deadzoneRight], userData[vDeadzone + deadzoneLeft], userData[vDeadzone + deadzoneRight]);
			break;
		} case editMenuInverted { // (Settings) Inverted
			printText(alignCenter, alignCenter, toggleOffOn[userData[vInverted]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuScreenSaver { // (Settings) Screen saver
			printText(alignCenter, alignCenter, screenSaver[userData[vScreenSaver]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuSmoothing { // (Settings) Smoothing
			printText(alignCenter, alignCenter, toggleOffOn[userData[vSmoothing]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuVMSpeed { // (Settings) VM speed
			printText(alignCenter, alignCenter, vmSpeed[userData[vVMSpeed]], OLED_FONT_SMALL, OLED_WHITE);
			break;
		} case editMenuToggleAkimbo { // (Toggles) Akimbo
			displayToggle(toggleAkimbo);
			break;
		} case editMenuToggleAutoADS { // (Toggles) Auto ADS/Fire
			displayToggle(toggleAutoADS);
			break;
		} case editMenuToggleAutoFocus { // (Toggles) Auto Focus
			displayToggle(toggleAutoFocus);
			break;
		} case editMenuToggleAutoPing { // (Toggles) Auto Ping
			displayToggle(toggleAutoPing);
			break;
		} case editMenuToggleBackpackSwap { // (Toggles) Backpack Swap
			displayToggle(toggleBackpackSwap);
			break;
		} case editMenuToggleDropShot { // (Toggles) Drop Shot
			displayToggle(toggleDropShot);
			break;
		} case editMenuToggleFastMelee { // (Toggles) Fast Melee
			displayToggle(toggleFastMelee);
			break;
		} case editMenuToggleRapidFire { // (Toggles) Rapid Fire
			displayToggle(toggleRapidFire);
			break;
		} case editMenuToggleTacticalSprint { // (Toggles) Tactical Sprint
			displayToggle(toggleTacticalSprint);
			break;
		} case editMenuToggleQuickScope { // (Toggles) Quick Scope
			displayToggle(toggleQuickScope);
			break;
		}
	}
	
	// Disable display update
	displayUpdate = FALSE;
 }

// Display home screen
function displayHomeScreen() {

 	drawBorder(); // Clears the screen and draws a border
 	
	// Show home screen
	printText(alignCenter, 10, script[0], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, 26, version[0], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, 42, author[0], OLED_FONT_SMALL, OLED_WHITE);
 }
 
 // Display mod menu
 function displayModMenu() {
 	
 	drawBorder(); // Clears the screen and draws a border
  	menuActionSuccess(); // Alert for successful action
	
 	// Display the mod menu
	printText(alignCenter, alignTop, modMenuNames[modMenuItems[modMenuIndex][modMenuPrevious]], OLED_FONT_SMALL, OLED_WHITE);
	printText(alignCenter, alignCenter, modMenuNames[modMenuItems[modMenuIndex][modMenuCurrent]], OLED_FONT_MEDIUM, OLED_WHITE);
	printText(alignCenter, alignBottom, modMenuNames[modMenuItems[modMenuIndex][modMenuNext]], OLED_FONT_SMALL, OLED_WHITE);
	
 	// Disable update
 	displayUpdate = FALSE;
 }

// Draws the 'Profile Colors' selection menu
function displayProfileColorSelection() {
	// Draw selected item background
	rect_oled(alignLeft, lineNumber[editMenuSelectedRow] + 1, OLED_WIDTH - 9, OLED_FONT_SMALL_HEIGHT + 1, 1, OLED_WHITE);
	// Loop through each profile and display the name/color respectively
	for(i = 0; i < 3; i++) {
		insertString(profileToggleMsg[4 + i]);
		insertString(colorName[userData[vProfileColor + i]]);
		flushBuffer(alignLeft, lineNumber[i] + 2, OLED_FONT_SMALL, iif(editMenuSelectedRow == i, OLED_BLACK, OLED_WHITE));
	}
}

// Display screen saver
function displayScreenSaver() {
	// TODO: is this really necessary will there ever be more screensavers?
	switch(userData[vScreenSaver]) {	
		case screenSaverUptime {
			cls_oled(OLED_BLACK); // Clear screen
			printUptime();
			break;
		}
	}
}

// Displays 'Button 1 & 2' messages and the proper controller buttons when editing toggles
function displayToggle(id) {
	displayDualSelection(displayString, profileToggleMsg[2], profileToggleMsg[3], iif(get_controller() == PIO_PS4, controllerButtonsPS4[userData[vToggleButton + id]], controllerButtonsXBOX[userData[vToggleButton + id]]), iif(get_controller() == PIO_PS4, controllerButtonsPS4[userData[vToggleButton + id + 1]], controllerButtonsXBOX[userData[vToggleButton + id + 1]]));
}

// Clears the screen and draws a border around the OLED
function drawBorder() {
	cls_oled(OLED_BLACK); // Clear screen
	rect_oled(0, 0, 128, 63, 0, OLED_WHITE); // Draw border around OLED
}

// Calculates the "shape pulse" radius
function calculatePulseRadius() {
	if(userData[vShapePulse + currentProfile]) {
		if(!pulseDirection) {
			if(iif(!holdingFire, userData[vAimAssistAdsRadius + currentProfile], userData[vAimAssistFireRadius + currentProfile]) < iif(!holdingFire, userData[vShapePulseAdsRadius + currentProfile], userData[vShapePulseFireRadius + currentProfile])) {
				if(aimAssistRadius == iif(!holdingFire, userData[vShapePulseAdsRadius + currentProfile], userData[vShapePulseFireRadius + currentProfile])) {
					pulseDirection = 1; // go backwards
				} else if(aimAssistRadius + 1 <= iif(!holdingFire, userData[vShapePulseAdsRadius + currentProfile], userData[vShapePulseFireRadius + currentProfile])) {
					pulseRadius++;
				}
			} else {
				if(aimAssistRadius == iif(!holdingFire, userData[vShapePulseAdsRadius + currentProfile], userData[vShapePulseFireRadius + currentProfile])) {
					pulseDirection = 1; // go backwards
				} else if(aimAssistRadius + 1 >= iif(!holdingFire, userData[vShapePulseAdsRadius + currentProfile], userData[vShapePulseFireRadius + currentProfile])) {
					pulseRadius--;
				}
			}
		} else {
			if(iif(!holdingFire, userData[vAimAssistAdsRadius + currentProfile], userData[vAimAssistFireRadius + currentProfile]) < iif(!holdingFire, userData[vShapePulseAdsRadius + currentProfile], userData[vShapePulseFireRadius + currentProfile])) {
				if(aimAssistRadius == iif(!holdingFire, userData[vAimAssistAdsRadius + currentProfile], userData[vAimAssistFireRadius + currentProfile])) {
					pulseDirection = 0; // go upwards
				} else if(aimAssistRadius >= iif(!holdingFire, userData[vAimAssistAdsRadius + currentProfile], userData[vAimAssistFireRadius + currentProfile])) {
					pulseRadius--;
				}
			} else {
				if(aimAssistRadius == iif(!holdingFire, userData[vAimAssistAdsRadius + currentProfile], userData[vAimAssistFireRadius + currentProfile])) {
					pulseDirection = 0; // go upwards
				} else if(aimAssistRadius <= iif(!holdingFire, userData[vAimAssistAdsRadius + currentProfile], userData[vAimAssistFireRadius + currentProfile])) {
					pulseRadius++;
				}
			}
		}
	}
}

// Executes main Aim Assist, Idle Target assist, and radius adjustment
function executeAimAssist() {
	// If not firing (ADS only)
	if(!holdingFire) {
		checkShapeChange(userData[vAimAssistAdsShape + currentProfile]); // Check if shape has changed
		// Retrieve ADS values
		aimAssistShape = userData[vAimAssistAdsShape + currentProfile];
		aimAssistRadius = userData[vAimAssistAdsRadius + currentProfile];
		aimAssistSpeed = userData[vAimAssistAdsSpeed + currentProfile];
		spinType = userData[vShapeSpinAdsType + currentProfile];
		spinSpeed = userData[vShapeSpinAdsAngle + currentProfile];
		idleTargetTimer = 0; // Reset Idle Target Timer
	} else {
		// If IdleTarget engaged, no need to check for a shape change
		if(!idleTargetEngaged) {
			checkShapeChange(userData[vAimAssistFireShape + currentProfile]); // Check if shape has changed
		}
		// Retrieve Fire values
		aimAssistShape = userData[vAimAssistFireShape + currentProfile];
		aimAssistRadius = userData[vAimAssistFireRadius + currentProfile];
		aimAssistSpeed = userData[vAimAssistFireSpeed + currentProfile];
		spinType = userData[vShapeSpinFireType + currentProfile];
		spinSpeed = userData[vShapeSpinFireAngle + currentProfile];
		
		// Determine Idle Target Assist and any radius/speed adjustments
		getPolarStickValues(); // Get stick values
		executeIdleTargetAssist(); // Execute Idle Target Assist
		executeAimAssistAdjustment(); // Execute aim assist radius adjustment (aim assist type)
	}
	
	// Determine if "shape pulse" is enabled
	if(checkActivation(userData[vShapePulse + currentProfile])) {
		aimAssistRadius += pulseRadius;
	}
	
	if(aimAssistShape == aasEcstasy) {
		if((aimAssistAngle + aimAssistSpeed >= 360) || !aimAssistRandomShape) {
			aimAssistShape = random(aimAssistShapeMin, aimAssistShapeMax - 1);
			aimAssistRandomShape = aimAssistShape;
		} else {
			aimAssistShape = aimAssistRandomShape;
		}
	}
	
	// Determine which shape to draw
	switch(aimAssistShape) {
		case aasCircle {
			// Calculate the coordinates using the mathematical equations for a circle
			aimAssistX = aimAssistRadius * cos[aimAssistAngle];
			aimAssistY = aimAssistRadius * sin[aimAssistAngle];
			break;
		} case aasOval {
			// Calculate the coordinates using the mathematical equations for a ov
			aimAssistX = (aimAssistRadius >> 1) * cos[aimAssistAngle];
			aimAssistY = aimAssistRadius * sin[aimAssistAngle];
			break;
		} case aasEllipse {
			// Calculate the coordinates using the mathematical equations for an ellipse
			aimAssistX = aimAssistRadius * cos[aimAssistAngle];
			aimAssistY = (aimAssistRadius >> 1) * sin[aimAssistAngle];
			break;
		} case aasLemniscate {
			// Calculate the coordinates using the mathematical equations for a lemniscate
			aimAssistX = aimAssistRadius * lemniscateX[aimAssistAngle];
			aimAssistY = aimAssistRadius * lemniscateY[aimAssistAngle];
			break;
		} case aasDiamond {
			// Calculate the coordinates for a diamond shape
			aimAssistX = aimAssistRadius * diamondX[aimAssistAngle];
			aimAssistY = aimAssistRadius * diamondY[aimAssistAngle];
			break;
		} case aasHorizon {
			aimAssistX = aimAssistRadius * horizonX[aimAssistAngle];
			aimAssistY = 0;
			break;
		} case aasRose {
			// Calculate the coordinates using the mathematical equations for a Rose (5 pedal Rose Curve)
			aimAssistX = aimAssistRadius * roseX[aimAssistAngle];
			aimAssistY = aimAssistRadius * roseY[aimAssistAngle];
			break;
		} case aasHeart {
			// Calculate the coordinates using the mathematical equations for a Heart Curve
			aimAssistX = aimAssistRadius * heartX[aimAssistAngle];
			aimAssistY = aimAssistRadius * heartY[aimAssistAngle];
			break;
		} case aasFlower {
			// Calculate the coordinates using the mathematical equations for a flower shape
			aimAssistX = aimAssistRadius * flowerX[aimAssistAngle];
			aimAssistY = aimAssistRadius * flowerY[aimAssistAngle];
			break;
		} case aasOrbit {
			// Calculate the coordinates for a "Orbit" shape
			aimAssistX = aimAssistRadius * orbitX[aimAssistAngle];
			aimAssistY = aimAssistRadius * orbitY[aimAssistAngle];
			break;
		} case aasSpiral {
			// Calculate the coordinates using the mathematical equations for an Archimedes' spiral
			aimAssistX = (aimAssistRadius * aimAssistAngle * cos[aimAssistAngle]) / 328;
			aimAssistY = (aimAssistRadius * aimAssistAngle * sin[aimAssistAngle]) / 328;
			break;
		}
	}
	
	if(checkActivation(userData[vMotionAssist + currentProfile])) {
		if(!holdingFire) {
			// Retrieve ADS motion values
			motionShape = userData[vMotionAdsShape + currentProfile];
			motionRadius = userData[vMotionAdsRadius + currentProfile];
			motionSpeed = userData[vMotionAdsSpeed + currentProfile];
		} else {
			// Retrieve Fire motion values
			motionShape = userData[vMotionFireShape + currentProfile];
			motionRadius = userData[vMotionFireRadius + currentProfile];
			motionSpeed = userData[vMotionFireSpeed + currentProfile];
		}
		
		switch(motionShape) {
			case aasCircle {
				// Calculate the coordinates using the mathematical equations for a circle
				motionX = motionRadius * cos[motionAngle];
				motionY = motionRadius * sin[motionAngle];
				break;		
			} case aasOval {
				// Calculate the coordinates using the mathematical equations for a ov
				motionX = (motionRadius >> 1) * cos[motionAngle];
				motionY = motionRadius * sin[motionAngle];
				break;
			} case aasEllipse {
				// Calculate the coordinates using the mathematical equations for an ellipse
				motionX = motionRadius * cos[motionAngle];
				motionY = (motionRadius >> 1) * sin[motionAngle];
				break;
			} case aasLemniscate {
				// Calculate the coordinates using the mathematical equations for a lemniscate
				motionX = motionRadius * lemniscateX[motionAngle];
				motionY = motionRadius * lemniscateY[motionAngle];
				break;
			} case aasDiamond {
				// Calculate the coordinates for a diamond shape
				motionX = motionRadius * diamondX[motionAngle];
				motionY = motionRadius * diamondY[motionAngle];
				break;
			} case aasHorizon {
				motionX = motionRadius * horizonX[motionAngle];
				motionY = 0;
				break;
			}
		}
		// Output
		set_val(stick[aimX], clamp(get_val(stick[aimX]) + motionX, -32768, 32767));
		set_val(stick[aimY], clamp(get_val(stick[aimY]) + motionY, -32768, 32767));
	}
	
	aimAssistAngle += aimAssistSpeed + random(0, 5); // Step to next angle
	
	if(checkActivation(userData[vShapeSpin + currentProfile])) {
		// Offset
		// Spinning
		if(spinType == spinOffset) {
			spinAngle = spinSpeed;
		}
	  	spinX = ((aimAssistX * cos[spinAngle]) / 328) - ((aimAssistY * sin[spinAngle]) / 328);
	  	spinY = ((aimAssistX * sin[spinAngle]) / 328) + ((aimAssistY * cos[spinAngle]) / 328); 
	  	
	  	// Prepare to output
	  	aimAssistX = spinX;
	  	aimAssistY = spinY;
  	}

	motionAngle += motionSpeed; // Step to next motion angle
	
	// Check if angle must be corrected
	if(motionAngle >= 360) {
		motionAngle -= 360; // Correct angle
	}
		
	// Check if angle must be corrected
	if(aimAssistAngle >= 360) {
		aimAssistAngle -= 360; // Correct angle
		
		/*motionAngle += motionSpeed; // Step to next motion angle
		
		// Check if angle must be corrected
		if(motionAngle >= 360) {
			motionAngle -= 360; // Correct angle
		}*/
		
		// Check for Shape Pulse
		if(checkActivation(userData[vShapePulse + currentProfile])) {
			calculatePulseRadius(); // Calculate pulse radius
		}
		
		// See if screen saver needs to be cleared
		clearVisualizer(); 
		
		if(checkActivation(userData[vShapeSpin + currentProfile])) {
			if(spinType == spinSpinning) {
			  	spinAngle += spinSpeed;
			  	
			  	if(spinAngle >= 360) {
			  		spinAngle -= 360;
			  	}
			}
		}
	}
  	
	// Determine how values should be output to stick
	if(holdingADS && !holdingFire) {
		// If only aiming and not firing, gradually reduce output as it approaches 100
		output(stick[aimX], aimAssistX);
		output(stick[aimY], aimAssistY);
	} else {
		// Otherwise, output values as they are
		set_val(stick[aimX], clamp(get_val(stick[aimX]) + aimAssistX, -32768, 32767));
		set_val(stick[aimY], clamp(get_val(stick[aimY]) + aimAssistY, -32768, 32767));
	}
	
	// Check for visualizer screen saver
	if(screenSaverEnabled && (userData[vScreenSaver] == screenSaverVisualizer)) {
		// Draw aim assist shape to OLED
		pixel_oled(64 + (((aimAssistX / aimAssistRadius) * 30) / 327), 32 + (((aimAssistY / aimAssistRadius) * 30) / 327), OLED_WHITE);
	}
}

// Adjusts the radius based on % of stick movement
// - adjustment ranges from -10 (reducing) to +10 (expanding)
function executeAimAssistAdjustment() {
	// Check for adjustment type
	if(userData[vAimAssistType + currentProfile] != aatSteady) {
		// Check for aim assist radius boost
		switch(userData[vAimAssistType + currentProfile]) {
			case aat_mRadius { // Subtract Radius
				// Decrements radius per 10% of aim stick move, limited to 50% of radius value
				if((aimAssistRadius >> 1) <= polarValue) {
					aimAssistRadius = aimAssistRadius >> 1;
				} else {
					aimAssistRadius -= polarValue;
				}
				break;
			} case aat_mSpeed { // Subtract Speed
				// Decrements radius per 10% of aim stick move, limited to 50% of radius value
				if((aimAssistSpeed >> 1) <= polarValue) {
					aimAssistSpeed = aimAssistSpeed >> 1;
				} else {
					aimAssistSpeed -= polarValue;
				}
				break;
			} case aat_mRadius_mSpeed { // Minus Radius & Minus Speed
				// Subtract Speed
				if((aimAssistSpeed >> 1) <= polarValue) {
					aimAssistSpeed = aimAssistSpeed >> 1;
				} else {
					aimAssistSpeed -= polarValue;
				}
				// Subtract Radius
				if((aimAssistRadius >> 1) <= polarValue) {
					aimAssistRadius = aimAssistRadius >> 1;
				} else {
					aimAssistRadius -= polarValue;
				}
				break;
			} case aat_mRadius_pSpeed { // Minus Radius & Plus Speed
				// Subtract Radius
				if((aimAssistRadius >> 1) <= polarValue) {
					aimAssistRadius = aimAssistRadius >> 1;
				} else {
					aimAssistRadius -= polarValue;
				}
				// Add Speed
				aimAssistSpeed += polarValue;
				break;
			} case aat_pRadius_mSpeed { // Plus Radius & Minus Speed
				// Add Radius
				aimAssistRadius += polarValue;
				// Subtract Speed
				if((aimAssistSpeed >> 1) <= polarValue) {
					aimAssistSpeed = aimAssistSpeed >> 1;
				} else {
					aimAssistSpeed -= polarValue;
				}
				break;
			} case aat_pRadius_pSpeed { // Plus Radius & Plus Speed
				aimAssistSpeed += polarValue; // Add Speed
				aimAssistRadius += polarValue; // Add Radius
				break;
			} case aat_pSpeed { // Add Speed
				aimAssistSpeed += polarValue;
				break;
			} case aat_pRadius { // Add Radius
				aimAssistRadius += polarValue; // Increment radius per 10% aim stick move
				break;
			}
		}
	}
}

// Executes anti-recoil
function executeAntiRecoil() {
		
	// See which type of anti-recoil is being used
	switch(userData[vAntiRecoil + currentProfile]) {
		case antiRecoilBasic {
			antiRecoilY = userData[vAntiRecoilStrength + currentProfile]; // Get polar value
			break;
		} case antiRecoilAdvanced {
			if(get_rumble(RUMBLE_A) || get_rumble(RUMBLE_B)) { // TODO: re-evaluate if we should wait for signal to begin kick compensation
				antiRecoilY = iif(antiRecoilCounterY <= (userData[vAntiRecoilKickDuration + currentProfile] * (10 + vmSpeedValue[userData[vVMSpeed]])), userData[vAntiRecoilKickStrength + currentProfile], userData[vAntiRecoilStrength + currentProfile]);
			} else {
				antiRecoilCounterY = 0; // No longer firing / never fired
				antiRecoilY = userData[vAntiRecoilKickStrength + currentProfile]; // Just apply basic until weapon is aimAssistFiring
			}
			break;
		} case antiRecoilExpert {
			// Check vertical values
			if(!antiRecoilStateY) {
				if(antiRecoilCounterY <= (userData[vAntiRecoilStartTime + currentProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]))) {
					antiRecoilY = userData[vAntiRecoilStart + currentProfile]; 
				} else {
					antiRecoilCounterY = 0; // Reset counter
					antiRecoilStateY++; // Advance to next stage
				}
			} else if(antiRecoilStateY == 1) {
				if(antiRecoilCounterY <= (userData[vAntiRecoilMidTime + currentProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]))) {
					antiRecoilY = userData[vAntiRecoilMid + currentProfile]; 
				} else {
					antiRecoilCounterY = 0; // Reset counter
					antiRecoilStateY++; // Advance to next stage
					antiRecoilY = userData[vAntiRecoilEnd + currentProfile]; 
				}
			} else {
				antiRecoilY = userData[vAntiRecoilEnd + currentProfile]; 
			}
			
			// Check horizontal values
			if(!antiRecoilStateX) {
				if(antiRecoilCounterX <= (userData[vAntiRecoilStartTimeH + currentProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]))) {
					antiRecoilX = iif(userData[vAntiRecoilStartH + currentProfile] >= 0, polarValues[userData[vAntiRecoilStartH + currentProfile]], inv(polarValues[abs(userData[vAntiRecoilStartH + currentProfile])])); 
				} else {
					antiRecoilCounterX = 0; // Reset counter
					antiRecoilStateX++; // Advance to next stage
				}
			} else if(antiRecoilStateX == 1) {
				if(antiRecoilCounterX <= (userData[vAntiRecoilMidTimeH + currentProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]))) {
					antiRecoilX = iif(userData[vAntiRecoilMidH + currentProfile] >= 0, polarValues[userData[vAntiRecoilMidH + currentProfile]], inv(polarValues[abs(userData[vAntiRecoilMidH + currentProfile])]));
				} else {
					antiRecoilCounterX = 0; // Reset counter
					antiRecoilStateX++; // Advance to next stage
				}
			} else {
				antiRecoilX = iif(userData[vAntiRecoilEndH + currentProfile] >= 0, polarValues[userData[vAntiRecoilEndH + currentProfile]], inv(polarValues[abs(userData[vAntiRecoilEndH + currentProfile])]));
			}
			break;
		} case antiRecoilWeapon {
			// Get maximum step values (if not already Retrieved)
			if(!antiRecoilMaxX && !antiRecoilMaxY) {
				antiRecoilMaxX = weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]]][0];
				antiRecoilMaxY = weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]]][1];
			}
			
			// Deteremine horizontal values from lookup table
			if(antiRecoilCounterX <= weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepX + 1][1]) {
				// If less than 0, this is for movement to the left
				if(weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepX + 1][0] < 0) {
					antiRecoilX = inv(polarValues[abs(weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepX + 1][0])]);
				} else if (weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepX + 1][0] < 0) {
					antiRecoilX = 0;
				} else {
					antiRecoilX = polarValues[weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepX + 1][0]];
				}
			} else {
				antiRecoilCounterX = antiRecoilCounterX - weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepX + 1][1];
				// Make sure we can move to the next step
				if(antiRecoilStepX + 1 < antiRecoilMaxX) {
					antiRecoilStepX++;
				}
				// If less than 0, this is for movement to the left
				if(weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepX + 1][0] < 0) {
					antiRecoilX = inv(polarValues[abs(weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepX + 1][0])]);
				} else if(weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepX + 1][0] == 0) {
					antiRecoilX = 0;
				} else {
					antiRecoilX = polarValues[weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepX + 1][0]];
				}
			}
			
			if(antiRecoilCounterY <= weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepY + antiRecoilMaxX + 1][1]) {
				antiRecoilY = polarValues[weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepY + antiRecoilMaxX + 1][0]];
			} else {
				antiRecoilCounterY = antiRecoilCounterY - weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepY + antiRecoilMaxX + 1][1];
				// Make sure we can move to the next step
				if(antiRecoilStepY + 1 < antiRecoilMaxY) {
					antiRecoilStepY++;
				}
				antiRecoilY = polarValues[weaponData[weaponIndex[userData[vAntiRecoilWeapon + currentProfile]] + antiRecoilStepY + antiRecoilMaxX + 1][0]];
			}
			break;
		}
	}
	
	// Increase vertical duration counter
	antiRecoilCounterY += get_rtime();
	
	// Check for Expert or Weapon Select mode
	if(userData[vAntiRecoil + currentProfile] >= antiRecoilExpert ) {
		// Output horizontal value
		if(userData[vAntiRecoil + currentProfile] == antiRecoilWeapon) {
			if(antiRecoilX > 0) {
				// If right side pull...decrease strength towards max
				antiRecoilX = clamp(antiRecoilX + (userData[vAntiRecoilCorrectionH + userData[vAntiRecoilWeapon + currentProfile]] * 64), 0, 32767);
			} else if(antiRecoilX < 0) {
				// If left side pull...decrease strength towards max
				antiRecoilX = clamp(antiRecoilX - (userData[vAntiRecoilCorrectionH + userData[vAntiRecoilWeapon + currentProfile]] * 64), -32768, 0);
			}
		}
		output(stick[aimX], antiRecoilX);
		// Increase horizontal duration counter
		antiRecoilCounterX += get_rtime(); 
	}
	
	// Output vertical value
	if(userData[vAntiRecoil + currentProfile] != antiRecoilWeapon) {
		output(stick[aimY], polarValues[antiRecoilY] * iif(userData[vInverted], -1, 1));
	} else {
		output(stick[aimY], (antiRecoilY + (userData[vAntiRecoilCorrectionV + userData[vAntiRecoilWeapon + currentProfile]] * 64)) * iif(userData[vInverted], -1, 1));
	}
}

// Executes idle target assist
// - if stick movement is less than 10.24% and timer met,
// 	 set new aim assist values until the stick is moved
function executeIdleTargetAssist() {
	// Check if idle target assist is enabled
	if(userData[vIdleTargetAssist + currentProfile] == assistOn) {
		if(polarValue < 1) { // If stick is not moving
			if(idleTargetTimer >= (userData[vIdleTargetTime + currentProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]))) { // See if we have met the timer
				// If this is first time Idle Target Assist is engaged, reset the angle
				if(!idleTargetEngaged) {
					aimAssistAngle = 0; // Reset angle for new shape
				}
				aimAssistShape = userData[vIdleTargetShape + currentProfile]; // Set aim assist shape to idle target shape
				aimAssistRadius = userData[vIdleTargetRadius + currentProfile]; // Set aim assist radius to idle target radius
				aimAssistSpeed = userData[vIdleTargetSpeed + currentProfile]; // Set aim assist speed to idle target speed
				idleTargetEngaged = TRUE;
			} else {
				idleTargetTimer += get_rtime(); // Add time elapsed to counter
				idleTargetEngaged = FALSE;
			}
		} else { // Stick has moved
			idleTargetTimer = 0; // Reset idle target timer if there is movement
			if(idleTargetEngaged) { // If idle target assist was engaged, reset aim assist
				aimAssistAngle = 0;
				idleTargetEngaged = FALSE;
			}
		}
	}
}

// Executes the inverse aimer movement rotational aim assist
function executeInverseAssist() {
	if((abs(get_val(stick[aimX])) >= polarValues[userData[vInverseAssistThreshold + currentProfile]])) {
		output(stick[moveX], calculateRotationThresholdAdjustment(get_val(stick[aimX])));
	}
}

// Executes the rotational aim assist (left stick "strafe" or shape)
function executeRotationAssist() {
	
	// Get rotational shape
	rotationType  = iif(holdingFire, userData[vRotationFireShape + currentProfile], userData[vRotationAdsShape + currentProfile]);
	
	if(rotationType <= rasCeorin) {
		rotationRadius = iif(holdingFire, polarValues[userData[vRotationFireRadius + currentProfile]], polarValues[userData[vRotationAdsRadius + currentProfile]]);
		rotationSpeed = iif(holdingFire, userData[vRotationFireSpeed + currentProfile], userData[vRotationAdsSpeed + currentProfile]) * (10 + vmSpeedValue[userData[vVMSpeed]]);
		
		// If counter is greater or equal to delay...change direction
		if(rotationCounter >= rotationSpeed) {
			rotationCounter = 0; // Set counter to any remainder
			if(rotationType == rasStrafe) {
				rotationDirection = !rotationDirection; // Change direction
			} else {
				rotationDirection = cycleListOption(rotationDirection, cycleValueUp, 4, 1);
			}
		} else {
			rotationCounter += get_rtime() + random(0, 20); // Add # milliseconds since last loop
		}
		
		// Determine which direction to move stick
		if(rotationType == rasStrafe) {
			output(stick[moveX], iif(rotationDirection, inv(rotationRadius), rotationRadius));
		} else {
			switch(rotationDirection) {
				case 1 {
					aimAssistX = rotationRadius;
					aimAssistY = inv(rotationRadius);
					break;		
				} case 2 {
					aimAssistX = inv(rotationRadius);
					aimAssistY = rotationRadius;
					break;	
				} case 3 {
					aimAssistX = rotationRadius;
					aimAssistY = rotationRadius;
					break;	
				} case 4 {
					aimAssistX = inv(rotationRadius);
					aimAssistY = inv(rotationRadius);
					break;
				}
			}
			output(stick[moveX], aimAssistX);
			output(stick[moveY], aimAssistY);
		}
	} else { 
		rotationRadius = iif(holdingFire, userData[vRotationFireRadius + currentProfile], userData[vRotationAdsRadius + currentProfile]);
		rotationSpeed = iif(holdingFire, userData[vRotationFireSpeed + currentProfile], userData[vRotationAdsSpeed + currentProfile]);
		
		if(rotationType == rasRandom) {
			if((rotationAngle + rotationSpeed >= 360) || !rotationRandomShape) {
				rotationType = random(rasCircle, rasRandom - 1);
				rotationRandomShape = rotationType;
			} else {
				rotationType = rotationRandomShape;
			}
		}
		
		// Determine which shape to draw
		switch(rotationType) {
			case rasCircle {
				// Calculate the coordinates using the mathematical equations for a circle
				aimAssistX = rotationRadius * cos[rotationAngle];
				aimAssistY = rotationRadius * sin[rotationAngle];
				break;		
			} case rasOval {
				// Calculate the coordinates using the mathematical equations for a ov
				aimAssistX = (rotationRadius >> 1) * cos[rotationAngle];
				aimAssistY = rotationRadius * sin[rotationAngle];
				break;
			} case rasEllipse {
				// Calculate the coordinates using the mathematical equations for an ellipse
				aimAssistX = rotationRadius * cos[rotationAngle];
				aimAssistY = (rotationRadius >> 1) * sin[rotationAngle];
				break;
			} case rasLemniscate {
				// Calculate the coordinates using the mathematical equations for a lemniscate
				aimAssistX = rotationRadius * lemniscateX[rotationAngle];
				aimAssistY = rotationRadius * lemniscateY[rotationAngle];
				break;
			}case rasDiamond {
				// Calculate the coordinates for a diamond shape
				aimAssistX = rotationRadius * diamondX[rotationAngle];
				aimAssistY = rotationRadius * diamondY[rotationAngle];
				break;
			}
		}
		
		// Step to next angle
		rotationAngle += rotationSpeed + random(0, 5);
		
		// Check if angle must be corrected
		if(rotationAngle >= 360) {
			rotationAngle -= 360;
		}
		
		output(stick[moveX], aimAssistX);
		output(stick[moveY], aimAssistY);
	}
}

// Displays the initial greeting
function executeGreeting() {
	// Must be a minimum of 2
	aimAssistRadius = 3;
	
	// Get coordinates
	aimAssistX = (aimAssistRadius >> 1) * cos[aimAssistAngle];
	aimAssistY = aimAssistRadius * sin[aimAssistAngle];
	//aimAssistX = aimAssistRadius * cos[aimAssistAngle];
	//aimAssistY = aimAssistRadius * sin[aimAssistAngle];
	
	// Calculate offset
  	spinX = ((aimAssistX * cos[spinAngle]) / 328) - ((aimAssistY * sin[spinAngle]) / 328);
  	spinY = ((aimAssistX * sin[spinAngle]) / 328) + ((aimAssistY * cos[spinAngle]) / 328); 
  	
  	// Prepare to output
  	aimAssistX = spinX;
  	aimAssistY = spinY;
  	
  	// Step ahead 
	aimAssistAngle += 1;
	spinAngle += 40;
	
	if(aimAssistAngle >= 360) {
		aimAssistAngle %= 360;
	}
	
	if(spinAngle >= 360) {
		spinAngle %= 360;
	}
	
	// Print to OLED
	pixel_oled(64 + (((aimAssistX / aimAssistRadius) * 30) / 328), 32 + (((aimAssistY / aimAssistRadius) * 30) / 328), OLED_WHITE);
}

// Applies Exponential Smoothing to smoothen out rapid stick movement
function exponentialSmoothing(current_value, previous_forecast) {
  return (((current_value << 1) + 8 * previous_forecast) + 5) / 10;
}

// Flushes the display buffer
function flushBuffer(x, y, size, color) {
	// Decrement display buffer value for proper arithmetic
	displayBuffer--; 
	
	// Check horizontal alignment
	switch(x) { 
		case alignRight {
			x = OLED_WIDTH - (displayBuffer * fontWidth[size]) - 4; // Additional 4 for padding from border
			break;	
		} case alignCenter {
			x = (OLED_WIDTH >> 1) - ((displayBuffer * fontWidth[size]) >> 1);
			break;
		}
		// No alignLeft case is needed because alignLeft is set to the proper left alignment already
	}
	
	// Check vertical alignment
	switch(y) { 
		case alignCenter {
			y = (OLED_HEIGHT >> 1) - (fontHeight[size] >> 1);
			break;
		} case alignBottom {
			y = OLED_HEIGHT - fontHeight[size] - 4; // Additional 4 for padding from border
			break;	
		}
		// No alignTop case is needed because alignTop is set to the proper top alignment already
	}
	
	puts_oled(x, y, size, displayBuffer, color); // Output display buffer
	displayBuffer = 1; // Reset display buffer
}

// Flushes the display buffer for a multiple item menu
function flushSelectedItemBuffer(item, line) {
	flushBuffer(alignLeft, line, OLED_FONT_SMALL, iif(editMenuSelectedRow == item, OLED_BLACK, OLED_WHITE));
}

// Format and append the display buffer for displaying the script uptime
function generateUptime(value, character) {
	insertNumber(value);
	insertCharacter(character);
}

// Get stick polar radius based on the aiming stick that is used
// Basically gets "the stick to use" for calculating difference/addition
// for Aim Assist Type setting (increasing/decreasing)
function getPolarStickValues() {
	// Determine which stick radius to use for calculating aim assist radius boost/idle target assist
	switch(userData[vControllerStickLayout]) {
		case slDefault {
			polarStick = POLAR_RS;
			break;
		} case slSouthpaw {
			polarStick = POLAR_LS;
			break;
		} case slSouthpawNoClickSwap {
			polarStick = POLAR_LS;
			break;
		} case slLegacy {
			if(abs(get_val(POLAR_RY)) > abs(get_val(POLAR_LX))) {
				polarStick = POLAR_RS;
			} else {
				polarStick = POLAR_LS;	
			}
			break;
		} case slLegacySouthpaw {
			if(abs(get_val(POLAR_LY)) > abs(get_val(POLAR_RX))) {
				polarStick = POLAR_LS;
			} else {
				polarStick = POLAR_RS;	
			}
			break;
		} case slLegacySouthpawNoClickSwap {
			if(abs(get_val(POLAR_LY)) > abs(get_val(POLAR_RX))) {
				polarStick = POLAR_LS;
			} else {
				polarStick = POLAR_RS;	
			}
			break;
		}
	}
	
	// Set value to % the stick is moved (sets of 10)
	polarValue = (get_polar(polarStick, POLAR_RADIUS) / 1000);
}

// Alternative for the ternary operator
function iif(expression, truepart, falsepart) {
	// evaluate if expression is true
	if(expression) {
		return truepart; // Return truepart
	}
	
	// Else, return falsepart
	return falsepart;
}

// Inserts a character into the display buffer
function insertCharacter(int value) {
	putc_oled(displayBuffer, value);
	displayBuffer++;
}

// Inserts a number into the display buffer
function insertNumber(int value) {
	// Check if value is negative
	if(value < 0) {
		insertCharacter(ASCII_MINUS); // Insert '-' into the display buffer
		value = abs(value); // Convert value to positive
	}
	
	displayBufferInsertCopyValue = value; // Create a copy of value to perform work on
	displayBufferInsertNumberOfDigits = 0; // Reset number of digits to 0
	
    // Determine the number of digits in the number by
    // dividing it by 10 repeatedly until it becomes 0
    // while not ignoring a value of 0
    do {
        displayBufferInsertCopyValue /= 10;
        displayBufferInsertNumberOfDigits++;
    } while(displayBufferInsertCopyValue)
    
    // Extract each digit of the number and store it in an array
    for(i = 0; i < displayBufferInsertNumberOfDigits; i++) {
        displayBufferInsertDigits[i] = (value % 10) + 48;
        value /= 10;
    }
    
    // Insert the digits in the order that they appear in the number
    for(i = displayBufferInsertNumberOfDigits - 1; i >= 0; i--) {
        insertCharacter(displayBufferInsertDigits[i]);
    }
}

// Inserts a string into the display buffer
function insertString(s) {
	// Loop through each character of the string
    do {
    	insertCharacter(dint8(s)); // Insert character into display buffer
    	s++; // Move to next character of the string
    } while(dint8(s)) // Check if a next character exists
}

// Menu action allowed
function menuActionSuccess() {
	// Make sure it is not running, if so, terminate it
	if(combo_running(cboActionSuccess)) { 
		combo_stop(cboActionSuccess);
	}
	
	combo_run(cboActionSuccess); // Execute alert
}

// Edit menu action not allowed
function menuActionFailed() {
	// Make sure it is not running, if so, terminate it
	if(combo_running(cboActionFailed)) { 
		combo_stop(cboActionFailed);
	}
	
	displayUpdate = FALSE;
	combo_run(cboActionFailed); // Execute alert
}

// Output value to stick and gradually reduce it as it approaches maximum movement
function output(stick, value) {
	//if(value) {
		set_val(stick, clamp(value * (32767 - abs(get_val(stick))) / 32767 + get_val(stick), -32768, 32767));
	//} else {
	//	set_val(stick, clamp(value * (-32768 + abs(get_val(stick))) / -32768 + get_val(stick), -32768, 32767));
	//}
}

// Prints a number to the screen
function printNumber(x, y, number, size, color) {
	insertNumber(number);
	flushBuffer(x, y, size, color);
}

 // Prints text to the screen
 function printText(x, y, text, size, color) {
	insertString(text);
	flushBuffer(x, y, size, color);
}

// Print the uptime to the OLED display
function printUptime() {
	// Check days
	if(uptimeDays) {
		generateUptime(uptimeDays, ASCII_LOWER_D);
	}
	// Check hours
	if(uptimeHours) {
		generateUptime(uptimeHours, ASCII_LOWER_H);
	}
	// Check minutes
	if(uptimeMinutes) {
		generateUptime(uptimeMinutes, ASCII_LOWER_M);
	}
	// Check seconds
	if(uptimeSeconds) {
		generateUptime(uptimeSeconds, ASCII_LOWER_S);
	}
	
	// Print centered to OLED the script uptime
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE); 
}

// Removes any "movement" inside calibrated drift area and applies a deadzone
function removeDriftAndApplyDeadzone() {
	// If anti-drift is not enabled, we use 0 for low/high values.  Deadzone doesn't matter
	if(userData[vAntiDrift]) {
		correctStickInput(userData[vAntiDriftLeft + antiDriftLeft], userData[vAntiDriftLeft + antiDriftRight], userData[vDeadzone + deadzoneLeft], stick[moveX]);
		correctStickInput(userData[vAntiDriftLeft + antiDriftUp], userData[vAntiDriftLeft + antiDriftDown], userData[vDeadzone + deadzoneLeft], stick[moveY]);
		correctStickInput(userData[vAntiDriftRight + antiDriftLeft], userData[vAntiDriftRight + antiDriftRight], userData[vDeadzone + deadzoneRight], stick[aimX]);
		correctStickInput(userData[vAntiDriftRight + antiDriftUp], userData[vAntiDriftRight + antiDriftDown], userData[vDeadzone + deadzoneRight], stick[aimY]);
	} else {
		// This is done because it's possible user has values saved
		// but for whatever reason wants anti-drift off
		// Deadzone doesn't matter, if user doesn't want to use script deadzone
		// they can leave it at 0
		correctStickInput(0, 0, userData[vDeadzone + deadzoneLeft], stick[moveX]);
		correctStickInput(0, 0, userData[vDeadzone + deadzoneLeft], stick[moveY]);
		correctStickInput(0, 0, userData[vDeadzone + deadzoneRight], stick[aimX]);
		correctStickInput(0, 0, userData[vDeadzone + deadzoneRight], stick[aimY]);
	}
}

// Resets aim assist-related values
function resetAimAssist() {
	spinAngle = 0; // Reset spin angle
	pulseDirection = 0; // Reset pulse diretion
	pulseRadius = 0; // Reset pulse count
	motionAngle = 0; // Reset motion shape angle
	aimAssistAngle = 0; // Reset aim assist shape angle
	idleTargetTimer = 0; // Reset idle target timer
	clearVisualizer(); // Check if Visualizer is running and if so, clear the screen since Aim Assist is disengaged
}

// Swaps tactical button with ping button
function setBumperPing() {
	// Only swap Tactical and Ping if enabled
	if(userData[vControllerBumperPing] == cbpSwapped) {
		button[tactical] = button[tactical] ^ button[ping];
		button[ping] = button[ping] ^ button[tactical];
		button[tactical] = button[tactical] ^ button[ping];
	}
}

// Swaps the bumpers and triggers based on the Button Layout used
function setBumperTriggers() {
	if(userData[vControllerBumperTriggers]) {
		switch(userData[vControllerButtonLayout]) {
			case cblDefault {
				button[tactical] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblTactical {
				button[tactical] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblLefty {
				button[lethal] = XB1_LT;
				button[fire] = XB1_LB;
				button[tactical] = XB1_RT;
				button[ads] = XB1_RB;
				break;
			} case cblNomadCharlie {
				button[tactical] = XB1_LT;
				button[lethal] = XB1_LB;
				button[ads] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblNomadCharlieTactical {
				button[tactical] = XB1_LT;
				button[lethal] = XB1_LB;
				button[ads] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblNomadCharlieLefty {
				button[ads] = XB1_LT;
				button[fire] = XB1_LB;
				button[tactical] = XB1_RT;
				button[lethal] = XB1_RB;
				break;
			} case cblBumperJumper {
				button[jump] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBumperJumperTactical {
				button[jump] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblOneHandGunslinger {
				button[fire] = XB1_LT;
				button[ads] = XB1_LB;
				button[tactical] = XB1_RT;
				button[lethal] = XB1_RB;
				break;
			} case cblStickAndMove {
				button[tactical] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBrawler {
				button[tactical] = XB1_LT;
				button[ads] = XB1_LB;
				button[melee] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBeast {
				button[jump] = XB1_LT;
				button[ads] = XB1_LB;
				button[melee] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBumperPing {
				button[ping] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			} case cblBumperPingTactical {
				button[ping] = XB1_LT;
				button[ads] = XB1_LB;
				button[lethal] = XB1_RT;
				button[fire] = XB1_RB;
				break;
			}
		}
	}
}

// Sets button variables based on in-game settings
function setButtonLayout() {
	button[ads] = buttonLayoutMap[userData[vControllerButtonLayout]][ads];
	button[tactical] = buttonLayoutMap[userData[vControllerButtonLayout]][tactical];
	button[ping] = buttonLayoutMap[userData[vControllerButtonLayout]][ping];
	button[focus] = buttonLayoutMap[userData[vControllerButtonLayout]][focus];
	button[fire] = buttonLayoutMap[userData[vControllerButtonLayout]][fire];
	button[lethal] = buttonLayoutMap[userData[vControllerButtonLayout]][lethal];
	button[weapon] = buttonLayoutMap[userData[vControllerButtonLayout]][weapon];
	button[action] = buttonLayoutMap[userData[vControllerButtonLayout]][action];
	button[jump] = buttonLayoutMap[userData[vControllerButtonLayout]][jump];
	button[melee] = buttonLayoutMap[userData[vControllerButtonLayout]][melee];
}

// Set controller configuration
function setControllerConfig() {
	setButtonLayout();
	setBumperTriggers();
	setBumperPing();
	setStickLayout();
	getPolarStickValues(); // Determine proper Sprint stick
}

// Sets the LED to the color provided as the parameter
function setLedColor(color) {
	set_hsb(colorValues[color][hue], colorValues[color][saturation], colorValues[color][brightness]);
}

// Sets the LED to a color based on the profile being used
function setProfileLedColor(profile) {
	if(!checkCombos()) { // Do not overlap with running combos that use the LEDs
		set_hsb(colorValues[userData[vProfileColor + profile]][hue], colorValues[userData[vProfileColor + profile]][saturation], colorValues[userData[vProfileColor + profile]][brightness]);
	}
}

// Sets joystick variables based on in-game settings
function setStickLayout() {
	// Determine movement and aiming sticks
	stick[aimX] = stickLayoutMap[userData[vControllerStickLayout]][aimX];
	stick[aimY] = stickLayoutMap[userData[vControllerStickLayout]][aimY];
	stick[moveX] = stickLayoutMap[userData[vControllerStickLayout]][moveX];
	stick[moveY] = stickLayoutMap[userData[vControllerStickLayout]][moveY];
	
	// For Southpaw, Left and Right joystick clicks must be swapped
	if((userData[vControllerStickLayout] == slSouthpaw) || (userData[vControllerStickLayout] == slLegacySouthpaw)) {
		switch(userData[vControllerButtonLayout]) {
			case cblDefault {
				button[melee] = XB1_RS;
				button[focus] = XB1_LS;
				break;
			} case cblTactical {
				button[action] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblLefty {
				button[focus] = XB1_LS;
				button[melee] = XB1_RS;
				break;
			} case cblNomadCharlie {
				button[melee] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblNomadCharlieTactical {
				button[action] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblNomadCharlieLefty {
				button[focus] = XB1_LS;
				button[melee] = XB1_RS;
				break;
			} case cblBumperJumper {
				button[melee] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBumperJumperTactical {
				button[action] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblOneHandGunslinger {
				button[melee] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblStickAndMove {
				button[jump] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBrawler {
				button[lethal] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBeast {
				button[lethal] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBumperPing {
				button[melee] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			} case cblBumperPingTactical {
				button[action] = XB1_LS;
				button[focus] = XB1_RS;
				break;
			}
		}
	}
}

// Attempts to bind button_to_set to a toggle combination
function setToggleButton(button_to_use, button_to_set, button_to_compare) {
	// Holding 'View' button will undo a previously set toggle combination button
	if(button_to_set == XB1_VIEW) {
		// Check if a buttin is set
		if(button_to_use) {
			button_to_use = 0; // Reset value
			displayUpdate = TRUE; // Enable display update
		} else {
			combo_run(cboActionFailed); // Cannot map same buttons
		}
	} else if(button_to_set != button_to_use) { // Check if value to set is different than current stored value for toggle
		if(button_to_set == button_to_compare) { // Make sure toggle combination [hold] button #1 does not equal [press] button #2
			combo_run(cboActionFailed); // Cannot map same buttons
		} else {
			button_to_use = button_to_set; // Set toggle button
		}
	}
	
	return button_to_use;
}

// Fix PS4 controller issue (from TD21)
function swapPS4() {
    if(get_console() == PIO_PS4) {
        if(get_controller() != PIO_PS4) {
            if(get_ival(PS4_SHARE)) {
                if(get_ival(PS4_R3)) {
                    set_val(PS4_SHARE, 100);
                    set_val(PS4_TOUCH, 0);
                    set_val(PS4_R3, 0);
                } else {
                    set_val(PS4_TOUCH, 100);
                    set_val(PS4_SHARE, 0);
                }
            }
        }
    } else if(get_console() == PIO_XB360) {
        if(get_controller() == PIO_PS4) {
            swap(PS4_TOUCH, PS4_SHARE);
        }
    }
}

// Switches profiles
function switchProfile(profile) {
	
	currentProfile = profile; // Set current profile
	combo_stop_all(); // Stop any combos that may disrupt the notification
	reset_rumble(); // Stop and reset any rumbles
	
	if(!displayDepth) {
		combo_run(cboSwitchProfile); // Display notification only if not in a menu
	}
}

// Verifies that a toggle combination is not already set
function verifyToggleCombo(verify_button, index) {
	// Loop through each set of toggle buttons
	for(j = 0; j < 24; j += 2) {
		if(userData[vToggleButton + j] && userData[vToggleButton + j + 1]) { // Make sure the buttons are accepted (0 = rejected from prior function)
			if(j != index) { // Do not compare against self, is already done in prior function
				if(userData[vToggleButton + j] == userData[vToggleButton + index] && userData[vToggleButton + j + 1] == userData[vToggleButton + index + 1]) {
					combo_run(cboActionFailed);
					return 0;
				}
			}
		}
	}
	
	// Make sure we are not resetting
	if(verify_button != XB1_VIEW) {
		displayUpdate = TRUE; // Enable display update
		combo_run(cboActionSuccess); // Notify user of success setting toggle button
	}
	
	return verify_button; // Return button
}

/**************************************************************/
// User-defined settings
/**************************************************************/
// Load user-defined configuration settings

int spvar_current_bit, spvar_current_slot, spvar_current_value, spvar_tmp, spvar_bits;

function reset_spvar() {

	 // Change this to say where it's safe to Roset storing data
	spvar_current_slot = SPVAR_1; 
	
	// Should always be 0, unless you're using part of the first SPVAR 
	// in which case you should also change the next line to include the 
	// value you are storing in the bits you are using
	
	spvar_current_bit = 0; 
	spvar_current_value = 0;
}

// Function used to count the number of bits used by the given value
function get_bit_count(v) {
	
	// We need to Roset at 0, we use spvar_tmp here as we need to track
	// the bits during our loop below
	spvar_tmp = 0; 
	
	// Loop while v is anything but 0
	while (v) { 
		// Increment the bit count by 1
		spvar_tmp++; 
		
		// Shift the value down 1 bit, once we have no more bits set this
		// will r in 0, unless the value is negative - in which case
		// this will be endless, we do abs here to make it always
		v = abs(v >> 1);
	}
	return spvar_tmp;
}

// Function used to count the number of bits used by 2 given values
function get_bit_count2(v1, v2) {

	// Get the highest bit count required for either min or max
	spvar_tmp = max(get_bit_count(v1), get_bit_count(v2));
	
	// Check if we need to know if the value is negative or not
	if (is_signed2(v1, v2)) {
		// If we need to track if the saved value is negative, we need 1 bit
		// for that specifically - the others are used to store the actual value
		spvar_tmp++;
	}
	return spvar_tmp;
}

// Function used to determine if either of 2 given values is negative
function is_signed2(v1, v2) {
	return (v1 < 0) || (v2 < 0);
}

// Function used to generate a bitmask for the sign bit, this will always be
// the highest bit in the range we're requesting it for, to do that - we need
// to Roset with the lowest bit set and move it up the number of steps there
// is between 1 and the bits we need, this needs to be a maximum of 31 but can
// never be negative
function make_sign(bits) { 
	return 1 << clamp(bits - 1, 0, 31);
}

// Function used to generate a full bitmask (essentially all bits set up to
// and including the number of bits given)
function make_full_mask(bits) {	

	// If we're wanting a bitmask for all bits, we can simply return -1
	// (which is all bits set to 1)
	if (bits == 32) { 
		return -1;
	}
	
	// What we do here is basically take a value with all bits except the highest
	// set and shift them down as many times as we need to get a mask that fits
	// the bit count we're looking for
	return 0x7FFFFFFF >> (31 - bits);
}

// Function used to generate a bitmask for just the bits required for the value
// part of a signed range, this means all the bits below the sign bit
function make_sign_mask(bits) {
	return make_full_mask(bits - 1);
}

// Function used to pack a value that has potential for being negative in a way
// that we use the least number of bits we really need to represent the value
function pack_i(v, bits) {

	// Check if we have a negative value, if so - handle it accordingly
	if (v < 0) { 
		// Get the positive version of the value and keep the bits that are within
		// range of what we're doing and add the sign bit since we have a negative
		// value and return the r
		return (abs(v) & make_sign_mask(bits)) | make_sign(bits);
	}
	
	// Get the bits that are within our range
	return v & make_sign_mask(bits); 
}

// Function used to unpack (restore) a value that has potential for being negative,
// essentially reversing what pack_i does above
function unpack_i(v, bits) {

	// Check if the stored value is supposed to be negative
	if (v & make_sign(bits)) {
		// Retrieve the stored positive value and subtract it from 0 (ring in
		// the same value except negative), return the r
		return 0 - (v & make_sign_mask(bits));
	}
	
	// Retrieve the stored positive value and return it
	return v & make_sign_mask(bits);
}

// Function used to read the value of a SPVAR without any limits
function read_spvar_slot(slot) {
	return get_pvar(slot, 0x80000000, 0x7FFFFFFF, 0);
}

// Function used to save your value in the SPVARs, this is the function you'll be
// calling when saving a value. You need to provide the value to save aswell as
// the range (minimum and maximum value, this is how we determine how many bits
// to use when saving this value)
function save_spvar(v, min, max) {

	// Set spvar_bits to the number of bits we need for this range
	spvar_bits = get_bit_count2(min, max); 
	
	// Make sure the value is within our defined range to begin with
	v = clamp(v, min, max); 
	
	// If either min or max is negative, we need to pack this value as a
	// possibly negative value
	if (is_signed2(min, max)) { 
		// Pack as signed value (possibly negative)
		v = pack_i(v, spvar_bits);
	}
	
	// Pack as unsigned value (always positive), this essentially just makes the
	// ring value not have any extra bits set - it's safe to use after the
	// signed packing since we're not using any bits outside of the unsigned range anyways
	v = v & make_full_mask(spvar_bits); 
	
	// Check if there is not enough bits remaining to save this value as-is. if
	// there aren't enough bits, we save what we can here and store the remaining
	// bits in the next spvar, if this means we're hitting the end, we can make
	// this smaller by handling the case where we use all bits here aswell
	if (spvar_bits >= 32 - spvar_current_bit) { 
		// Add what we can to the current value where there is bits available to use
		spvar_current_value = spvar_current_value | (v << spvar_current_bit); 
		// Save the current SPVAR before advancing to the next one
		set_pvar(spvar_current_slot, spvar_current_value); 
		// Move to the next slot
		spvar_current_slot++; 
		// Update the required bits according to our needs for the next slot, 
		// if we don't do this here, we'll screw up the saved value by moving
		// it too far out of range
		spvar_bits -= (32 - spvar_current_bit);
		// Move the remaining bits down, discarding the bits we've already saved
		v = v >> (32 - spvar_current_bit); 
		// Reset the current bit counter since we're Roseting with a new SPVAR
		spvar_current_bit = 0; 
		// Reset our value so we Roset clean, we aren't currently using any bits anyways
		spvar_current_value = 0; 
	}
	
	// Merge the current SPVAR value with our currently value where there is space to keep our value
	spvar_current_value = spvar_current_value | (v << spvar_current_bit); 
	// Move up the counter of next available bit to where we are currently saving data at
	spvar_current_bit += spvar_bits; 
	
	if (!spvar_current_bit) {
		// Reset our value so we Roset clean, we aren't currently using any bits anyways
		spvar_current_value = 0; 
	}
	
	// Save the SPVAR with the current value, this won't write anything to flash unless
	//the value changed - so we can do this for each variable saved to no risk missing anything
	set_pvar(spvar_current_slot, spvar_current_value); 
}

// Function used to read your value from the SPVARs, this is the function you'll be
// calling when reading a value. You need to provide the range (minimum and maximum
// value, this is how we determine how many bits to use when reading the value) aswell
// as a default value if what we read is out of range
function read_spvar(min, max) {

	// Set spvar_bits to the number of bits we need for this range
	spvar_bits = get_bit_count2(min, max); 
	
	// Read the current SPVAR value from flash and shift them into position,
	// we'll handle split values next
	spvar_current_value = (read_spvar_slot(spvar_current_slot) >> spvar_current_bit) & make_full_mask(spvar_bits);
	
	// Check if we are dealing with a split SPVAR value, essentially if the current
	// position means we're using more than 32 bits in the SPVAR, we need to retrieve
	// the missing bits from the next SPVAR and put them back to our current value,
	// we use the same space saving trick here as in the save function
	if (spvar_bits >= 32 - spvar_current_bit) {
		spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | ((read_spvar_slot(spvar_current_slot + 1) & make_full_mask(spvar_bits - (32 - spvar_current_bit))) << (32 - spvar_current_bit));
		//Below is a breakdown of the line above, with each step done one at a time instead of all at once - this however increases codesize - the below code is to explain how it all works tho
		//spvar_tmp = read_spvar_slot(spvar_current_slot + 1); // Read the SPVAR slot coming after the initial one we used to spvar_tmp from flash, we need to maintain the data we've read thus far, but also add on what we have in flash for the next SPVAR
		//spvar_tmp = spvar_tmp & make_full_mask(spvar_bits - (32 - spvar_current_bit)); // Extract the bits we need need (the ones that didn't fit in the previous SPVAR)
		//spvar_tmp = spvar_tmp << (32 - spvar_current_bit); // Move the bits into their original position, they were stored at the beginning of the new SPVAR but belong at the top of the currently read value
		//spvar_current_value = (spvar_current_value & make_full_mask(32 - spvar_current_bit)) | spvar_tmp; // put all bits together again with the part read from the first SPVAR cleaned up to only include the bits from this variable/value and not all bits set in the upper range like they normally are
	}
	
	// Move up the counter of next available bit to where we are will be reading data from next
	spvar_current_bit += spvar_bits;
	// Extract all bits included for this value and discard any other bits
	spvar_current_value = spvar_current_value & make_full_mask(spvar_bits); 
	
	if (spvar_current_bit >= 32) {
		// Move to the next SPVAR slot
		spvar_current_slot++;
		// Remove 32 from the spvar_current_bit tracker since we've gone beyond what we can do here
		spvar_current_bit -= 32;
	}
	
	// Check if the value can be negative and handle it accordingly
	if (is_signed2(min, max)) { 
		// Restore the signed, possibly negative value
		spvar_current_value = unpack_i(spvar_current_value, spvar_bits); 
	}
	
	// Check if the value is below our specified min or above our specified max,
	// if so - return the default value instead
	if (spvar_current_value < min || spvar_current_value > max) { 
		// This can be changed to min instead as a reasonable default with the
		// default parameter being removed if you don't need to have a override
		// value for the default when out of range, that will save a bit of code size
		return 0; // edited
	}
	
	// Return the retrieved value to the user since it's within the expected range
	return spvar_current_value;
}


function loadSettings() {

	reset_spvar();
	
	// Read and check the first bit, if it is set, we know something should have been saved, otherwise we fall back on our default setting
	if(read_spvar(0, 1)) {
		for(i = 0; i < 3; i++) {
			userData[vAimAssist + i]						= read_spvar(assistOff, assistAdsAndFireOrAds);
			userData[vAimAssistType + i]					= read_spvar(aat_mRadius, aat_pRadius);
			userData[vAimAssistAdsShape + i]				= read_spvar(aimAssistShapeMin, aimAssistShapeMax);
			userData[vAimAssistAdsRadius + i]				= read_spvar(1, 100);
			userData[vAimAssistAdsSpeed + i]				= read_spvar(1, 100);
			userData[vAimAssistFireShape + i]				= read_spvar(aimAssistShapeMin, aimAssistShapeMax);
			userData[vAimAssistFireRadius + i]				= read_spvar(1, 100);
			userData[vAimAssistFireSpeed + i]				= read_spvar(1, 100);
			userData[vRotationAssist + i]					= read_spvar(assistOff, assistAdsAndFireOrAds);
			userData[vRotationAdsShape + i]					= read_spvar(rasStrafe, rasRandom);
			userData[vRotationFireShape + i]				= read_spvar(rasStrafe, rasRandom);
			userData[vRotationAdsRadius + i]				= read_spvar(1, 100);
			userData[vRotationAdsSpeed + i]					= read_spvar(1, 120);
			userData[vRotationFireRadius + i]				= read_spvar(1, 100);
			userData[vRotationFireSpeed + i]				= read_spvar(1, 120)
			userData[vInverseAssist + i]					= read_spvar(assistOff, assistAdsAndFireOrAds);
			userData[vInverseAssistThreshold + i]			= read_spvar(0, 100);
			userData[vIdleTargetAssist + i]					= read_spvar(assistOff, assistOn);
			userData[vIdleTargetShape + i]					= read_spvar(aimAssistShapeMin, aimAssistShapeMax);
			userData[vIdleTargetTime + i]					= read_spvar(0, 100);
			userData[vIdleTargetRadius + i]					= read_spvar(1, 100);
			userData[vIdleTargetSpeed + i]					= read_spvar(1, 100);
			userData[vMotionAssist + i]						= read_spvar(assistOff, assistOn);
			userData[vMotionAdsShape + i]					= read_spvar(aimAssistShapeMin, aasHorizon);
			userData[vMotionAdsRadius + i]					= read_spvar(1, 100);
			userData[vMotionAdsSpeed + i]					= read_spvar(1, 100);
			userData[vMotionFireShape + i]					= read_spvar(aimAssistShapeMin, aasHorizon);
			userData[vMotionFireRadius + i]					= read_spvar(1, 100);
			userData[vMotionFireSpeed + i]					= read_spvar(1, 100);
			userData[vShapePulse + i]						= read_spvar(assistOff, assistOn);
			userData[vShapePulseAdsRadius + i]				= read_spvar(1, 100);
			userData[vShapePulseFireRadius + i]				= read_spvar(1, 100);
			userData[vShapeSpin + i]						= read_spvar(assistOff, assistAdsAndFireOrAds);
			userData[vShapeSpinAdsType + i]					= read_spvar(0, 1);
			userData[vShapeSpinFireType + i]				= read_spvar(0, 1);
			userData[vShapeSpinAdsAngle + i]				= read_spvar(1, 180);
			userData[vShapeSpinFireAngle + i]				= read_spvar(1, 180);
			userData[vAntiRecoil + i]						= read_spvar(antiRecoilOff, antiRecoilWeapon);
			userData[vAntiRecoilStrength + i]				= read_spvar(0, 100);
			userData[vAntiRecoilKickStrength + i]			= read_spvar(0, 100);
			userData[vAntiRecoilKickDuration + i]			= read_spvar(0, 200);
			userData[vAntiRecoilStart + i]					= read_spvar(0, 100);
			userData[vAntiRecoilMid + i]					= read_spvar(0, 100);
			userData[vAntiRecoilEnd + i]					= read_spvar(0, 100);
			userData[vAntiRecoilStartH + i]					= read_spvar(-30, 30);
			userData[vAntiRecoilMidH + i]					= read_spvar(-30, 30);
			userData[vAntiRecoilEndH + i]					= read_spvar(-30, 30);
			userData[vAntiRecoilStartTime + i]				= read_spvar(0, 200);
			userData[vAntiRecoilMidTime + i]				= read_spvar(0, 200);
			userData[vAntiRecoilStartTimeH + i]				= read_spvar(0, 200);
			userData[vAntiRecoilMidTimeH + i]				= read_spvar(0, 200);
			userData[vAntiRecoilCategory + i]				= read_spvar(antiRecoilCategoryAR, antiRecoilCategoryLMG);
			userData[vAntiRecoilWeapon + i]					= read_spvar(M4, RAPP_H);
			userData[vOptionAkimbo + i]						= read_spvar(0, 1);
			userData[vOptionAkimboSpeed + i]				= read_spvar(0, 60);
			userData[vOptionAutoAdsFire + i]				= read_spvar(autoADSFireOff, autoADSFireAutoFire);
			userData[vOptionAutoFocus + i]					= read_spvar(0, 1);
			userData[vOptionAutoFocusInterval + i]			= read_spvar(0, 8);
			userData[vOptionAutoPing + i]					= read_spvar(0, 1);
			userData[vOptionAutoPingInterval + i]			= read_spvar(0, 8);
			userData[vOptionDropShot + i]					= read_spvar(0, 1);
			userData[vOptionDropShotAimAdjust + i]			= read_spvar(0, 50);
			userData[vOptionFastMelee + i]					= read_spvar(fastMeleeOff, fastMeleeToggle);
			userData[vOptionRapidFire + i]					= read_spvar(0, 1);
			userData[vOptionRapidFireSpeed + i]				= read_spvar(1, 60);
			userData[vOptionRapidFirePistols + i]			= read_spvar(0, 1);
			userData[vOptionRapidFirePistolsSpeed + i]		= read_spvar(1, 60);
			userData[vOptionQuickScope + i]					= read_spvar(0, 1);
			userData[vOptionQuickScopeDelay + i]			= read_spvar(1, 50);
		}
		for(i = 0; i < 28; i++) {
			userData[vAntiRecoilCorrectionV + i] = read_spvar(-512, 512);
			userData[vAntiRecoilCorrectionH + i] = read_spvar(-512, 512);
		}
		userData[vOptionBackpackSwap]					= read_spvar(0, 1);
		userData[vOptionBackpackSwapType]				= read_spvar(0, 1);
		userData[vOptionBunnyHop]						= read_spvar(0, 1);
		userData[vOptionDolphinCancel]					= read_spvar(0, 1);
		userData[vOptionGWalk]							= read_spvar(gWalkOff, gWalkReplace);
		userData[vOptionHairTriggers]					= read_spvar(0, 1);
		userData[vOptionSlideCancel]					= read_spvar(slideCancelOff, slideCancelMW2);
		userData[vOptionSlideCancelDelay]				= read_spvar(1, 30);
		userData[vOptionTacticalSprint]					= read_spvar(0, 1);
		userData[vAntiDrift]							= read_spvar(0, 1);
		userData[vAntiDriftLeft + antiDriftUp]			= read_spvar(-8191, 8191);
		userData[vAntiDriftLeft + antiDriftDown]		= read_spvar(-8191, 8191);
		userData[vAntiDriftLeft + antiDriftLeft]		= read_spvar(-8191, 8191);
		userData[vAntiDriftLeft + antiDriftRight]		= read_spvar(-8191, 8191);
		userData[vAntiDriftRight + antiDriftUp]			= read_spvar(-8191, 8191);
		userData[vAntiDriftRight + antiDriftDown]		= read_spvar(-8191, 8191);
		userData[vAntiDriftRight + antiDriftLeft]		= read_spvar(-8191, 8191);
		userData[vAntiDriftRight + antiDriftRight]		= read_spvar(-8191, 8191);
		userData[vControllerButtonLayout] 				= read_spvar(cblDefault, cblBumperPingTactical);
		userData[vControllerBumperPing]					= read_spvar(cbpDefault, cbpSwapped);
		userData[vControllerBumperTriggers]				= read_spvar(cbtDefault, cbtFlipped);
		userData[vControllerStickLayout] 				= read_spvar(slDefault, slLegacySouthpawNoClickSwap);
		userData[vControllerAdsStickSwap]				= read_spvar(cbpDefault, cbpSwapped);
		userData[vControllerSlideDive]					= read_spvar(slideDiveStandard, slideDiveInverted);
		
		for(i = 0; i < 24; i++) {
			userData[vToggleButton + i] = read_spvar(0, XB1_X);
		}
		
		userData[vProfileColor + 0]						= read_spvar(red, pink);
		userData[vProfileColor + 1]						= read_spvar(red, pink);
		userData[vProfileColor + 2]						= read_spvar(red, pink);
		userData[vBlockRumble] 							= read_spvar(0, 1);
		userData[vDeadzone + deadzoneLeft]				= read_spvar(0, 15);
		userData[vDeadzone + deadzoneRight]				= read_spvar(0, 15);
		userData[vInverted] 							= read_spvar(0, 1);
		userData[vScreenSaver] 							= read_spvar(screenSaverOff, screenSaverVisualizer);
		userData[vSmoothing] 							= read_spvar(0, 1);
		userData[vVMSpeed]								= read_spvar(vmSpeed4, vmSpeed10);
	} else {
		// Set default settings
		for(i = 0; i < 3; i++) {
			userData[vAimAssist + i]					= assistOff;
			userData[vAimAssistType + i]				= aat_pRadius;
			userData[vAimAssistAdsShape + i] 			= aasCircle;
			userData[vAimAssistAdsRadius + i]			= 9;
			userData[vAimAssistAdsSpeed + i]			= 18;
			userData[vAimAssistFireShape + i] 			= aasRose;
			userData[vAimAssistFireRadius + i]			= 12;
			userData[vAimAssistFireSpeed + i]			= 9;
			userData[vRotationAssist + i]				= assistOff;
			userData[vRotationAdsShape + i]				= rasCircle;
			userData[vRotationFireShape + i]			= rasStrafe;
			userData[vRotationAdsRadius + i]			= 35;
			userData[vRotationAdsSpeed + i]				= 45;
			userData[vRotationFireRadius + i]			= 30;
			userData[vRotationFireSpeed + i]			= 10; // 80ms on -2 VM
			userData[vInverseAssist + i]				= assistOff;
			userData[vInverseAssistThreshold + i]		= 0;
			userData[vIdleTargetAssist + i]				= assistOff;
			userData[vIdleTargetShape + i]				= aasHorizon;
			userData[vIdleTargetTime + i]				= 35; // 280ms on -2 VM
			userData[vIdleTargetRadius + i]				= 12;
			userData[vIdleTargetSpeed + i]				= 26;
			userData[vMotionAssist + i]					= assistOff;
			userData[vMotionAdsShape + i]				= aasCircle;
			userData[vMotionAdsRadius + i]				= 5;
			userData[vMotionAdsSpeed + i]				= 15;
			userData[vMotionFireShape + i]				= aasLemniscate;
			userData[vMotionFireRadius + i]				= 9;
			userData[vMotionFireSpeed + i]				= 45;
			userData[vShapePulse + i]					= assistOff;
			userData[vShapePulseAdsRadius + i]			= userData[vAimAssistAdsRadius + i] + 2;
			userData[vShapePulseFireRadius + i]			= userData[vAimAssistFireRadius + i] + 2;
			userData[vShapeSpin + i]					= assistOff;
			userData[vShapeSpinAdsType + i]				= 1;
			userData[vShapeSpinFireType + i]			= 1;
			userData[vShapeSpinAdsAngle + i]			= 45;
			userData[vShapeSpinFireAngle + i]			= 90;
			userData[vAntiRecoil + i]					= antiRecoilOff;
			userData[vAntiRecoilStrength + i]			= 0;
			userData[vAntiRecoilKickStrength + i]		= 0;
			userData[vAntiRecoilKickDuration + i]		= 10;
			userData[vAntiRecoilStart + i]				= 0;
			userData[vAntiRecoilMid + i]				= 0;
			userData[vAntiRecoilEnd + i]				= 0;
			userData[vAntiRecoilStartH + i]				= 0;
			userData[vAntiRecoilMidH + i]				= 0;
			userData[vAntiRecoilEndH + i]				= 0;
			userData[vAntiRecoilStartTime + i]			= 0;
			userData[vAntiRecoilMidTime + i]			= 0;
			userData[vAntiRecoilStartTimeH + i]			= 0;
			userData[vAntiRecoilMidTimeH + i]			= 0;
			userData[vAntiRecoilCategory + i]			= antiRecoilCategoryAR;
			userData[vAntiRecoilWeapon + i]				= M4;
			userData[vOptionAkimbo + i]					= 0;
			userData[vOptionAkimboSpeed + i]			= 0;
			userData[vOptionAutoAdsFire + i]			= autoADSFireOff;
			userData[vOptionAutoFocus + i]				= 0;
			userData[vOptionAutoFocusInterval + i]		= 0;
			userData[vOptionAutoPing + i]				= 0;
			userData[vOptionAutoPingInterval + i]		= 0;
			userData[vOptionDropShot + i]				= 0;
			userData[vOptionDropShotAimAdjust + i]		= 0;
			userData[vOptionFastMelee + i]				= fastMeleeOff;
			userData[vOptionRapidFire + i]				= 0;
			userData[vOptionRapidFireSpeed + i]			= 12;
			userData[vOptionRapidFirePistols + i]		= 0;
			userData[vOptionRapidFirePistolsSpeed + i]	= 12;
			userData[vOptionQuickScope + i]				= 0;
			userData[vOptionQuickScopeDelay + i]			= 1;
		}
		for(i = 0; i < 28; i++) {
			userData[vAntiRecoilCorrectionV + i]	= 0;
			userData[vAntiRecoilCorrectionH + i] = 0;
		}
		userData[vOptionBackpackSwap]					= 0;
		userData[vOptionBackpackSwapType] 				= 0;
		userData[vOptionBunnyHop]						= 0;
		userData[vOptionDolphinCancel]					= 0;
		userData[vOptionGWalk]							= gWalkOff;
		userData[vOptionHairTriggers]					= 0;
		userData[vOptionSlideCancel]					= 0;
		userData[vOptionSlideCancelDelay]				= 10;
		userData[vOptionTacticalSprint]					= 0;
		userData[vAntiDrift]							= 0;
		userData[vAntiDriftLeft + antiDriftUp]			= 0;
		userData[vAntiDriftLeft + antiDriftDown]		= 0;
		userData[vAntiDriftLeft + antiDriftLeft]		= 0;
		userData[vAntiDriftLeft + antiDriftRight]		= 0;
		userData[vAntiDriftRight + antiDriftUp]			= 0;
		userData[vAntiDriftRight + antiDriftDown]		= 0;
		userData[vAntiDriftRight + antiDriftLeft]		= 0;
		userData[vAntiDriftRight + antiDriftRight]		= 0;
		userData[vControllerButtonLayout] 				= cblDefault;
		userData[vControllerBumperPing]					= cbpDefault;
		userData[vControllerBumperTriggers]				= cbtDefault;
		userData[vControllerStickLayout] 				= slDefault;
		userData[vControllerAdsStickSwap]				= cbpDefault;
		userData[vControllerSlideDive]					= slideDiveStandard;
		for(i = 0; i < 24; i++) {
			userData[vToggleButton + i] = 0;
		}
		userData[vProfileColor + 0]						= blue;
		userData[vProfileColor + 1]						= purple;
		userData[vProfileColor + 2]						= gold;
		
		userData[vBlockRumble] 							= 0;
		userData[vDeadzone + deadzoneLeft] 				= 0;
		userData[vDeadzone + deadzoneRight] 			= 0;
		userData[vInverted]								= 0;
		
		// Developer settings
		/*
		userData[vAntiDrift]							= 1;
		userData[vAntiDriftLeft + antiDriftUp]			= -2666;
		userData[vAntiDriftLeft + antiDriftDown]		= 763;
		userData[vAntiDriftLeft + antiDriftLeft]		= 683;
		userData[vAntiDriftLeft + antiDriftRight]		= 3160;
		userData[vAntiDriftRight + antiDriftUp]			= -4078;
		userData[vAntiDriftRight + antiDriftDown]		= -2735;
		userData[vAntiDriftRight + antiDriftLeft]		= 2528;
		userData[vAntiDriftRight + antiDriftRight]		= 4523;
		userData[vBlockRumble] 							= 1;
		userData[vDeadzone + deadzoneLeft] 				= 5;
		userData[vDeadzone + deadzoneRight] 			= 5;
		userData[vInverted]								= 1;
		*/
		
		userData[vScreenSaver] 							= screenSaverBlank;
		userData[vSmoothing] 							= 0;
		userData[vVMSpeed]								= vmSpeed10;
	}
	
	setControllerConfig(); // Set controller configuration
}

function initReadWrite() {
	spvar_index = SPVAR_1;
	bit_position = unpacked_bits = spvar_data = 0;
}

// Save user-defined configuration settings
function saveSettings() {

	reset_spvar();
	
	// Save a constant 1 to denote previously saved data, this range uses 1 bit
	save_spvar(1, 0, 1);
	for(i = 0; i < 3; i++) {
		save_spvar(userData[vAimAssist + i], assistOff, assistAdsAndFireOrAds);
		save_spvar(userData[vAimAssistType + i], aat_mRadius, aat_pRadius);
		save_spvar(userData[vAimAssistAdsShape + i], aimAssistShapeMin, aimAssistShapeMax);
		save_spvar(userData[vAimAssistAdsRadius + i], 1, 100);
		save_spvar(userData[vAimAssistAdsSpeed + i], 1, 100);
		save_spvar(userData[vAimAssistFireShape + i], aimAssistShapeMin, aimAssistShapeMax);
		save_spvar(userData[vAimAssistFireRadius + i], 1, 100);
		save_spvar(userData[vAimAssistFireSpeed + i], 1, 100);
		save_spvar(userData[vRotationAssist + i], assistOff, assistAdsAndFireOrAds);
		save_spvar(userData[vRotationAdsShape + i], rasStrafe, rasRandom);
		save_spvar(userData[vRotationFireShape + i], rasStrafe, rasRandom);
		save_spvar(userData[vRotationAdsRadius + i], 1, 100);
		save_spvar(userData[vRotationAdsSpeed + i], 1, 120);
		save_spvar(userData[vRotationFireRadius + i], 1, 100);
		save_spvar(userData[vRotationFireSpeed + i], 1, 120);
		save_spvar(userData[vInverseAssist + i], assistOff, assistAdsAndFireOrAds);
		save_spvar(userData[vInverseAssistThreshold + i], 0, 100);
		save_spvar(userData[vIdleTargetAssist + i], assistOff, assistOn);
		save_spvar(userData[vIdleTargetShape + i], aimAssistShapeMin, aimAssistShapeMax);
		save_spvar(userData[vIdleTargetTime + i], 0, 100);
		save_spvar(userData[vIdleTargetRadius + i], 1, 100);
		save_spvar(userData[vIdleTargetSpeed + i], 1, 100);
		save_spvar(userData[vMotionAssist + i], assistOff, assistAdsAndFireOrAds);
		save_spvar(userData[vMotionAdsShape + i], aimAssistShapeMin, aasHorizon);
		save_spvar(userData[vMotionAdsRadius + i], 1, 100);
		save_spvar(userData[vMotionAdsSpeed + i], 1, 100);
		save_spvar(userData[vMotionFireShape + i], assistOff, assistAdsAndFireOrAds);
		save_spvar(userData[vMotionFireRadius + i], 1, 100);
		save_spvar(userData[vMotionFireSpeed + i], 1, 100);
		save_spvar(userData[vShapePulse + i], assistOff, assistAdsAndFireOrAds);
		save_spvar(userData[vShapePulseAdsRadius + i], 1, 100);
		save_spvar(userData[vShapePulseFireRadius + i], 1, 100);
		save_spvar(userData[vShapeSpin + i], assistOff, assistAdsAndFireOrAds);
		save_spvar(userData[vShapeSpinAdsType + i], 0, 1);
		save_spvar(userData[vShapeSpinFireType + i], 0, 1);
		save_spvar(userData[vShapeSpinAdsAngle + i], 1, 180);
		save_spvar(userData[vShapeSpinFireAngle + i], 1, 180);
		save_spvar(userData[vAntiRecoil + i], antiRecoilOff, antiRecoilWeapon);
		save_spvar(userData[vAntiRecoilStrength + i], 0, 100);
		save_spvar(userData[vAntiRecoilKickStrength + i], 0, 100);
		save_spvar(userData[vAntiRecoilKickDuration + i], 0, 200);
		save_spvar(userData[vAntiRecoilStart + i], 0, 100);
		save_spvar(userData[vAntiRecoilMid + i], 0, 100);
		save_spvar(userData[vAntiRecoilEnd + i], 0, 100);
		save_spvar(userData[vAntiRecoilStartH + i], -30, 30);
		save_spvar(userData[vAntiRecoilMidH + i], -30, 30);
		save_spvar(userData[vAntiRecoilEndH + i], -30, 30);
		save_spvar(userData[vAntiRecoilStartTime + i], 0, 200);
		save_spvar(userData[vAntiRecoilMidTime + i], 0, 200);
		save_spvar(userData[vAntiRecoilStartTimeH + i], 0, 200);
		save_spvar(userData[vAntiRecoilMidTimeH + i], 0, 200);
		save_spvar(userData[vAntiRecoilCategory + i], antiRecoilCategoryAR, antiRecoilCategoryLMG);
		save_spvar(userData[vAntiRecoilWeapon + i], M4, RAPP_H);
		save_spvar(userData[vOptionAkimbo + i], 0, 1);
		save_spvar(userData[vOptionAkimboSpeed + i], 0, 60);
		save_spvar(userData[vOptionAutoAdsFire + i], autoADSFireOff, autoADSFireAutoFire);
		save_spvar(userData[vOptionAutoFocus + i], 0, 1);
		save_spvar(userData[vOptionAutoFocusInterval + i], 0, 8);
		save_spvar(userData[vOptionAutoPing + i], 0, 1);
		save_spvar(userData[vOptionAutoPingInterval + i], 0, 8);
		save_spvar(userData[vOptionDropShot + i], 0, 1);
		save_spvar(userData[vOptionDropShotAimAdjust + i], 0, 50);
		save_spvar(userData[vOptionFastMelee + i], fastMeleeOff, fastMeleeToggle);
		save_spvar(userData[vOptionRapidFire + i], 0, 1);
		save_spvar(userData[vOptionRapidFireSpeed + i], 1, 60);
		save_spvar(userData[vOptionRapidFirePistols + i], 0, 1);
		save_spvar(userData[vOptionRapidFirePistolsSpeed + i], 1, 60);
		save_spvar(userData[vOptionQuickScope + i], 0, 1);
		save_spvar(userData[vOptionQuickScopeDelay + i], 1, 50);
	}
	// Save Weapon Select correction values
	for(i = 0; i < 28; i++) {
		save_spvar(userData[vAntiRecoilCorrectionV + i], -512, 512);
		save_spvar(userData[vAntiRecoilCorrectionH + i], -512, 512);
	}
	save_spvar(userData[vOptionBackpackSwap], 0, 1);
	save_spvar(userData[vOptionBackpackSwapType], 0, 1);
	save_spvar(userData[vOptionBunnyHop], 0, 1);
	save_spvar(userData[vOptionDolphinCancel], 0, 1);
	save_spvar(userData[vOptionGWalk], gWalkOff, gWalkReplace);
	save_spvar(userData[vOptionHairTriggers], 0, 1);
	save_spvar(userData[vOptionSlideCancel], slideCancelOff, slideCancelMW2);
	save_spvar(userData[vOptionSlideCancelDelay], 1, 30);
	save_spvar(userData[vOptionTacticalSprint], 0, 1);
	save_spvar(userData[vAntiDrift], 0, 1);
	save_spvar(userData[vAntiDriftLeft + antiDriftUp], -8191, 8191);
	save_spvar(userData[vAntiDriftLeft + antiDriftDown], -8191, 8191);
	save_spvar(userData[vAntiDriftLeft + antiDriftLeft], -8191, 8191);
	save_spvar(userData[vAntiDriftLeft + antiDriftRight], -8191, 8191);
	save_spvar(userData[vAntiDriftRight + antiDriftUp], -8191, 8191);
	save_spvar(userData[vAntiDriftRight + antiDriftDown], -8191, 8191);
	save_spvar(userData[vAntiDriftRight + antiDriftLeft], -8191, 8191);
	save_spvar(userData[vAntiDriftRight + antiDriftRight], -8191, 8191);
	save_spvar(userData[vControllerButtonLayout], cblDefault, cblBumperPingTactical);
	save_spvar(userData[vControllerBumperPing], cbpDefault, cbpSwapped);
	save_spvar(userData[vControllerBumperTriggers], cbtDefault, cbtFlipped);
	save_spvar(userData[vControllerStickLayout], slDefault, slLegacySouthpawNoClickSwap);
	save_spvar(userData[vControllerAdsStickSwap], cbpDefault, cbpSwapped);
	save_spvar(userData[vControllerSlideDive], slideDiveStandard, slideDiveInverted);
	
	for(i = 0; i < 24; i++) {
		save_spvar(userData[vToggleButton + i], 0, XB1_X);
	}
	save_spvar(userData[vProfileColor + 0], red, pink);
	save_spvar(userData[vProfileColor + 1], red, pink);
	save_spvar(userData[vProfileColor + 2], red, pink);
	//save_spvar(userData[vAimAccelerationReduction], 1, 100);
	//save_spvar(userData[vAimAccelerationThreshold], 1, 100);
	save_spvar(userData[vBlockRumble], 0, 1);
	save_spvar(userData[vDeadzone + deadzoneLeft], 0, 15);
	save_spvar(userData[vDeadzone + deadzoneRight], 0, 15);
	save_spvar(userData[vInverted], 0, 1);
	save_spvar(userData[vScreenSaver], screenSaverOff, screenSaverVisualizer);
	save_spvar(userData[vSmoothing], 0, 1);
	save_spvar(userData[vVMSpeed], vmSpeed4, vmSpeed10);
	setControllerConfig();

	// Debug purposes (make sure we have enough memory)
	set_val(TRACE_1, spvar_current_slot);
}

/**************************************************************/
// Combos
/**************************************************************/
combo cboActionSuccess {
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	set_rumble(RUMBLE_B, 80);
	wait(240);
	reset_rumble();
}

combo cboActionFailed {
	set_hsb(colorValues[red][hue], colorValues[red][saturation], colorValues[red][brightness]);
	set_rumble(RUMBLE_A, 80);
	wait(240);
	reset_rumble();
}

combo cboAlertRapidFire {
	setProfileLedColor(currentProfile);
	wait(240);
	set_hsb(0, 0, 0); // Off
	wait(240);
}

combo cboAlertvehicleMode {
	set_rgb(255, 30, 0);
	wait(120);
	set_rgb(0, 0, 0);
	wait(120);
}

combo cboCalibrationComplete {
	// Notify user of status
	cls_oled(OLED_BLACK);
	set_rumble(RUMBLE_B, 100);
	setLedColor(iif(antiDriftCalibrationCanSet == 2, yellow, iif(antiDriftCalibrationCanSet, green, red)));
	printText(alignCenter, alignCenter, antiDriftCalibrationResult[antiDriftCalibrationCanSet], OLED_FONT_SMALL, OLED_WHITE);
	wait(1440);
	reset_rumble();
	// Clear calibration state
	antiDriftCalibrationState = !antiDriftCalibrationState; 
	// Enable display update
	displayUpdate = TRUE; 
	// Reset calibration variables
	antiDriftCalibrationCanSet = FALSE;
	antiDriftCalibrationInRange = FALSE;
}

combo cboClearScreen {
	cls_oled(OLED_BLACK);
}

combo cboGreeting {
	call(cboClearScreen);
	executeGreeting();
	wait(2400);
	call(cboGreetingText);
}

combo cboGreetingText {
	wait(360);
	printText(alignCenter, alignCenter, zeitgeist[0], OLED_FONT_MEDIUM, OLED_WHITE);
	set_rumble(RUMBLE_A, 50);
	wait(720);
	set_rumble(RUMBLE_A, 50);
	set_rumble(RUMBLE_B, 100);
	wait(720);
	reset_rumble();
	wait(1560);
	
}

combo cboOptionAkimbo {
	set_val(button[ads], 0);
	set_val(button[fire], 0);
	wait((120 / userData[vOptionAkimboSpeed + currentProfile]) + random(0, 30));
	set_val(button[ads], 100);
	set_val(button[fire], 100);
	wait((880 / userData[vOptionAkimboSpeed + currentProfile]) + random(0, 30));	
}


combo cboOptionAutoFocus {
	wait(120 + random(0, 20));
	set_val(button[focus], 100);
	wait(3000);
	set_val(button[focus], 0);
	wait(600);
}

combo cboOptionAutoFocusDelay {
	wait(userData[vOptionAutoFocusInterval + currentProfile] * 120);
	call(cboOptionAutoFocus);
}

combo cboOptionAutoPing {
	call(cboOptionAutoPingOnce);
	set_val(button[ping], 0);
	wait(userData[vOptionAutoPingInterval + currentProfile] * 120);
}

combo cboOptionAutoPingOnce {
	set_val(button[ping], 100);
	wait(120 + random(0, 20));
}

combo cboOptionBackpackSwap {
	set_val(XB1_DOWN, 100);
	wait(120 + random(0, 20));
	set_val(XB1_DOWN, 0);
	wait(120 + random(0, 20));
	set_val(XB1_X, 100);
	set_val(XB1_B, 100);
	wait(120 + random(0, 20));
}

combo cboOptionBunnyHop {
	set_val(button[jump], 0);
	wait(20 + random(0, 20));
	wait(20 + random(0, 20));
}

combo cboOptionDolphinCancel {
	wait(840 + random(0, 20));
	set_val(iif(polarStick == POLAR_RS, XB1_LS, XB1_RS), 100);
	wait(50 + random(0, 20));
	wait(80 + random(0, 20));
	set_val(iif(polarStick == POLAR_RS, XB1_LS, XB1_RS), 100);
	wait(50 + random(0, 20));
	set_val(stick[moveY], 100);
	wait(30 + random(0, 20));
	combo_run(cboOptionTacticalSprint);
}

combo cboOptionDropShot {
	set_val(button[action], 100);
	wait(110 + random(0, 20));
	set_val(button[action], 100);
	output(stick[aimY], polarValues[userData[vOptionDropShotAimAdjust + currentProfile]] * iif(userData[vInverted], 1, -1));
	wait(230 + random(0, 20));
	output(stick[aimY], polarValues[userData[vOptionDropShotAimAdjust + currentProfile]] * iif(userData[vInverted], 1, -1));
	wait(470 + random(0, 20));
}

combo cboOptionFastMelee {
	set_val(button[melee], 100);
	wait(110 + random(0, 20));
	set_val(button[melee], 0);
	wait(110 + random(0, 20));
}

combo cboOptionGWalk {
	set_val(button[action], 0);
	set_val(stick[moveY], 0);
	set_val(iif(polarStick == POLAR_RS, XB1_LS, XB1_RS), 0);
	wait(40 + random(0, 20));
	set_val(button[action], 100);
	wait(440 + random(0, 20));
	set_val(stick[moveY], inv(polarValues[100]));
	set_val(iif(polarStick == POLAR_RS, XB1_LS, XB1_RS), 100);
	wait(40 + random(0, 20));
	set_val(stick[moveY], inv(polarValues[100]));
	wait(40 + random(0, 20));
	set_val(stick[moveY], inv(polarValues[100]));
	set_val(iif(polarStick == POLAR_RS, XB1_LS, XB1_RS), 100);
	wait(40 + random(0, 20));
	if(holdingADS || holdingFire) {
		set_val(button[jump], 100);
	}
	wait(((holdingADS || holdingFire) * 40) + random(0, 20));
	wait(((holdingADS || holdingFire) * 40) + random(0, 20));
	if(holdingADS || holdingFire) {
		set_val(button[jump], 100);
	}
	wait(((holdingADS || holdingFire) * 40) + random(0, 20));
}

combo cboOptionRapidFire {
	// Low value (LCM of possible VM speeds) for immediate fire
	wait((120 / userData[vOptionRapidFireSpeed + currentProfile]) + random(0, 30));
	set_val(button[fire], 0);
	wait((880 / userData[vOptionRapidFireSpeed + currentProfile]) + random(0, 30));
}

combo cboOptionRapidFirePistols {
	// Low value (LCM of possible VM speeds) for immediate fire
	wait((120 / userData[vOptionRapidFirePistolsSpeed + currentProfile]) + random(0, 30));
	set_val(button[fire], 0);
	wait((880 / userData[vOptionRapidFirePistolsSpeed + currentProfile]) + random(0, 30));
}

combo cboOptionSlideCancelMW {
	wait(userData[vOptionSlideCancelDelay] * (10 + vmSpeedValue[userData[vVMSpeed]]));
	set_val(button[action], 100);
	wait(40 + random(0, 30));
	set_val(button[jump], 100);
	wait(40 + random(0, 30));
}

combo cboOptionSlideCancelMW2 {
	/*wait(480);
	set_val(button[ads], 100);
	wait(60);
	wait(60);
	set_val(button[ads], 100);
	wait(60);
	wait(360);
	set_val(button[jump], 100);
	wait(20);
	set_val(stick[moveY], 100);
	wait(120);
	combo_run(cboOptionTacticalSprint);*/
	wait(470 + random(10, 20));
	set_val(button[ads], 100);
	wait(50 + random(10, 20));
	wait(50 + random(10, 20));
	set_val(button[ads], 100);
	wait(50 + random(10, 20));
	wait(350 + random(10, 20));
	set_val(button[jump], 100);
	wait(10 + random(10, 20));
	set_val(stick[moveY], 100);
	wait(120);
	combo_run(cboOptionTacticalSprint);
}

combo cboOptionTacticalSprint {
	set_val(button[focus], 100);
	wait(100 + random(20, 40));
	set_val(button[focus], 0);
	wait(100 + random(20, 40));
	set_val(button[focus], 100);
	wait(960);
}

combo cboOptionQuickScope {
	wait(userData[vOptionQuickScopeDelay + currentProfile] * (10 + vmSpeedValue[userData[vVMSpeed]]));
	set_val(button[fire], 100);
	wait(120 + random(0, 30));
	set_val(button[ads], 0);
}

combo cboSaveSettings {
	cls_oled(OLED_BLACK);
	printText(alignCenter, alignCenter, settingsSaved[0], OLED_FONT_SMALL, OLED_WHITE);
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	set_rumble(RUMBLE_B, 100);
	wait(480);
	reset_rumble(); // Reset rumble state
	saveSettings(); // Save settings
	displayUpdate = TRUE; // Enable display update
}

combo cboSwitchProfile {
	cls_oled(OLED_BLACK);
	insertString(profileName[currentProfile]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(1080);
	cls_oled(OLED_BLACK);
	displayUpdate = TRUE;
}

combo cboToggleScope {
	set_val(button[focus], 0);
	wait(80);
	set_val(button[focus], 100);
	wait(120);
}

combo cboToggleAkimbo {
	if(userData[vOptionAkimbo + currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[0]);
	insertString(toggleOffOn[userData[vOptionAkimbo + currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleAutoADS {
	if(userData[vOptionAutoAdsFire + currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[1]);
	insertString(toggleOffOn[userData[vOptionAutoAdsFire + currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleAutoFocus {
	if(userData[vOptionAutoFocus + currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[2]);
	insertString(toggleOffOn[userData[vOptionAutoFocus + currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleAutoPing {
	if(userData[vOptionAutoPing + currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[3]);
	insertString(toggleOffOn[userData[vOptionAutoPing + currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleDropShot {
	if(userData[vOptionDropShot + currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[4]);
	insertString(toggleOffOn[userData[vOptionDropShot + currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleFastMelee {
	if(userData[vOptionFastMelee + currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[5]);
	insertString(fastMeleeType[userData[vOptionFastMelee + currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleRapidFire {
	if(userData[vOptionRapidFire + currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[6]);
	insertString(toggleOffOn[userData[vOptionRapidFire + currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleTacticalSprint {
	if(userData[vOptionTacticalSprint]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[7]);
	insertString(toggleOffOn[userData[vOptionTacticalSprint]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleQuickScope {
	if(userData[vOptionQuickScope + currentProfile]) {
		combo_run(cboToggleOn);
	} else {
		combo_run(cboToggleOff);
	}
	cls_oled(OLED_BLACK);
	insertString(toggleMessages[8]);
	insertString(toggleOffOn[userData[vOptionQuickScope + currentProfile]]);
	flushBuffer(alignCenter, alignCenter, OLED_FONT_SMALL, OLED_WHITE);
	wait(960);
	cls_oled(OLED_BLACK);
}

combo cboToggleOff {
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	set_hsb(colorValues[red][hue], colorValues[red][saturation], colorValues[red][brightness]);
	wait(240);
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	reset_rumble();
}

combo cboToggleOn {
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_B, 75);
	wait(120);
	set_hsb(colorValues[green][hue], colorValues[green][saturation], colorValues[green][brightness]);
	wait(240);
	set_hsb(colorValues[yellow][hue], colorValues[yellow][saturation], colorValues[yellow][brightness]);
	set_rumble(RUMBLE_A, 75);
	wait(120);
	reset_rumble();
}

/**************************************************************/
// Tables
/**************************************************************/
//
// Polar stick values (0 - 100)
const int16 polarValues[] = {
    0,
	328, 655, 983, 1311, 1638, 1966, 2294, 2621, 2949, 3277,
    3604, 3932, 4260, 4587, 4915, 5243, 5570, 5898, 6226, 6553,
    6881, 7209, 7536, 7864, 8192, 8519, 8847, 9175, 9502, 9830,
    10158, 10485, 10813, 11141, 11468, 11796, 12124, 12451, 12779, 13107,
    13434, 13762, 14090, 14417, 14745, 15073, 15400, 15728, 16056, 16384,
    16711, 17039, 17367, 17694, 18022, 18350, 18677, 19005, 19333, 19660,
    19988, 20316, 20643, 20971, 21299, 21626, 21954, 22282, 22609, 22937,
    23265, 23592, 23920, 24248, 24575, 24903, 25231, 25558, 25886, 26214,
    26541, 26869, 27197, 27524, 27852, 28180, 28507, 28835, 29163, 29490,
    29818, 30146, 30473, 30801, 31129, 31456, 31784, 32112, 32439, 32767
}

const int16 orbitX2[] = {
    0, -17, -34, -51, -68, -85, -101, -117, -133, -149, -164, -178, -193, -206, -219, -232, -244, -255,
    -265, -275, -284, -292, -299, -306, -312, -317, -321, -324, -326, -327, -328, -327, -326, -324, -321, -317,
    -312, -306, -299, -292, -284, -275, -265, -255, -244, -232, -219, -206, -193, -178, -164, -149, -133, -117,
    -101, -85, -68, -51, -34, -17, 0, 17, 34, 51, 68, 85, 101, 117, 133, 149, 164, 178,
    193, 206, 219, 232, 244, 255, 265, 275, 284, 292, 299, 306, 312, 317, 321, 324, 326, 327,
    328, 327, 326, 324, 321, 317, 312, 306, 299, 292, 284, 275, 265, 255, 244, 232, 219, 206,
    193, 178, 164, 149, 133, 117, 101, 85, 68, 51, 34, 17, 0, -17, -34, -51, -68, -85,
    -101, -117, -133, -149, -164, -178, -193, -206, -219, -232, -244, -255, -265, -275, -284, -292, -299, -306,
    -312, -317, -321, -324, -326, -327, -328, -327, -326, -324, -321, -317, -312, -306, -299, -292, -284, -275,
    -265, -255, -244, -232, -219, -206, -193, -178, -164, -149, -133, -117, -101, -85, -68, -51, -34, -17,
    0, 17, 34, 51, 68, 85, 101, 117, 133, 149, 164, 178, 193, 206, 219, 232, 244, 255,
    265, 275, 284, 292, 299, 306, 312, 317, 321, 324, 326, 327, 328, 327, 326, 324, 321, 317,
    312, 306, 299, 292, 284, 275, 265, 255, 244, 232, 219, 206, 193, 178, 164, 149, 133, 117,
    101, 85, 68, 51, 34, 17, 0, -17, -34, -51, -68, -85, -101, -117, -133, -149, -164, -178,
    -193, -206, -219, -232, -244, -255, -265, -275, -284, -292, -299, -306, -312, -317, -321, -324, -326, -327,
    -328, -327, -326, -324, -321, -317, -312, -306, -299, -292, -284, -275, -265, -255, -244, -232, -219, -206,
    -193, -178, -164, -149, -133, -117, -101, -85, -68, -51, -34, -17, 0, 17, 34, 51, 68, 85,
    101, 117, 133, 149, 164, 178, 193, 206, 219, 232, 244, 255, 265, 275, 284, 292, 299, 306,
    312, 317, 321, 324, 326, 327, 328, 327, 326, 324, 321, 317, 312, 306, 299, 292, 284, 275,
    265, 255, 244, 232, 219, 206, 193, 178, 164, 149, 133, 117, 101, 85, 68, 51, 34, 17
}

const int16 orbitX[] = {
	0, 29, 57, 85, 112, 138, 163, 187, 209, 229, 247, 263, 278, 289, 299, 306, 310, 312,
	312, 309, 303, 295, 285, 273, 259, 243, 226, 206, 186, 164, 142, 119, 95, 71, 47, 23,
	0, -23, -45, -66, -86, -105, -122, -137, -152, -164, -174, -183, -190, -195, -198, -199, -199, -196,
	-193, -187, -180, -172, -163, -153, -142, -130, -118, -105, -92, -79, -67, -54, -42, -30, -19, -9,
	-0, 8, 16, 22, 27, 31, 34, 36, 37, 36, 35, 33, 30, 26, 21, 17, 11, 6,
	0, -6, -11, -17, -21, -26, -30, -33, -35, -36, -37, -36, -34, -31, -27, -22, -16, -8,
	-0, 9, 19, 30, 42, 54, 67, 79, 92, 105, 118, 130, 142, 153, 163, 172, 180, 187,
	193, 196, 199, 199, 198, 195, 190, 183, 174, 164, 152, 137, 122, 105, 86, 66, 45, 23,
	0, -23, -47, -71, -95, -119, -142, -164, -186, -206, -226, -243, -259, -273, -285, -295, -303, -309,
	-312, -312, -310, -306, -299, -289, -278, -263, -247, -229, -209, -187, -163, -138, -112, -85, -57, -29,
	-0, 29, 57, 85, 112, 138, 163, 187, 209, 229, 247, 263, 278, 289, 299, 306, 310, 312,
	312, 309, 303, 295, 285, 273, 259, 243, 226, 206, 186, 164, 142, 119, 95, 71, 47, 23,
	0, -23, -45, -66, -86, -105, -122, -137, -152, -164, -174, -183, -190, -195, -198, -199, -199, -196,
	-193, -187, -180, -172, -163, -153, -142, -130, -118, -105, -92, -79, -67, -54, -42, -30, -19, -9,
	-0, 8, 16, 22, 27, 31, 34, 36, 37, 36, 35, 33, 30, 26, 21, 17, 11, 6,
	0, -6, -11, -17, -21, -26, -30, -33, -35, -36, -37, -36, -34, -31, -27, -22, -16, -8,
	-0, 9, 19, 30, 42, 54, 67, 79, 92, 105, 118, 130, 142, 153, 163, 172, 180, 187,
	193, 196, 199, 199, 198, 195, 190, 183, 174, 164, 152, 137, 122, 105, 86, 66, 45, 23,
	0, -23, -47, -71, -95, -119, -142, -164, -186, -206, -226, -243, -259, -273, -285, -295, -303, -309,
	-312, -312, -310, -306, -299, -289, -278, -263, -247, -229, -209, -187, -163, -138, -112, -85, -57, -29
}

const int16 orbitY[] = {
	0, 6, 11, 17, 21, 26, 30, 33, 35, 36, 37, 36, 34, 31, 27, 22, 16, 8,
	0, -9, -19, -30, -42, -54, -67, -79, -92, -105, -118, -130, -142, -153, -163, -172, -180, -187,
	-193, -196, -199, -199, -198, -195, -190, -183, -174, -164, -152, -137, -122, -105, -86, -66, -45, -23,
	-0, 23, 47, 71, 95, 119, 142, 164, 186, 206, 226, 243, 259, 273, 285, 295, 303, 309,
	312, 312, 310, 306, 299, 289, 278, 263, 247, 229, 209, 187, 163, 138, 112, 85, 57, 29,
	0, -29, -57, -85, -112, -138, -163, -187, -209, -229, -247, -263, -278, -289, -299, -306, -310, -312,
	-312, -309, -303, -295, -285, -273, -259, -243, -226, -206, -186, -164, -142, -119, -95, -71, -47, -23,
	-0, 23, 45, 66, 86, 105, 122, 137, 152, 164, 174, 183, 190, 195, 198, 199, 199, 196,
	193, 187, 180, 172, 163, 153, 142, 130, 118, 105, 92, 79, 67, 54, 42, 30, 19, 9,
	0, -8, -16, -22, -27, -31, -34, -36, -37, -36, -35, -33, -30, -26, -21, -17, -11, -6,
	-0, 6, 11, 17, 21, 26, 30, 33, 35, 36, 37, 36, 34, 31, 27, 22, 16, 8,
	0, -9, -19, -30, -42, -54, -67, -79, -92, -105, -118, -130, -142, -153, -163, -172, -180, -187,
	-193, -196, -199, -199, -198, -195, -190, -183, -174, -164, -152, -137, -122, -105, -86, -66, -45, -23,
	-0, 23, 47, 71, 95, 119, 142, 164, 186, 206, 226, 243, 259, 273, 285, 295, 303, 309,
	312, 312, 310, 306, 299, 289, 278, 263, 247, 229, 209, 187, 163, 138, 112, 85, 57, 29,
	0, -29, -57, -85, -112, -138, -163, -187, -209, -229, -247, -263, -278, -289, -299, -306, -310, -312,
	-312, -309, -303, -295, -285, -273, -259, -243, -226, -206, -186, -164, -142, -119, -95, -71, -47, -23,
	-0, 23, 45, 66, 86, 105, 122, 137, 152, 164, 174, 183, 190, 195, 198, 199, 199, 196,
	193, 187, 180, 172, 163, 153, 142, 130, 118, 105, 92, 79, 67, 54, 42, 30, 19, 9,
	0, -8, -16, -22, -27, -31, -34, -36, -37, -36, -35, -33, -30, -26, -21, -17, -11, -6
}

const int16 orbitY2[] = {
    0, -11, -23, -34, -46, -57, -68, -79, -90, -101, -112, -123, -133, -144, -154, -164, -174, -183,
    -193, -202, -211, -219, -228, -236, -244, -251, -258, -265, -272, -278, -284, -289, -295, -299, -304, -308,
    -312, -315, -318, -321, -323, -324, -326, -327, -327, -328, -327, -327, -326, -324, -323, -321, -318, -315,
    -312, -308, -304, -299, -295, -289, -284, -278, -272, -265, -258, -251, -244, -236, -228, -219, -211, -202,
    -193, -183, -174, -164, -154, -144, -133, -123, -112, -101, -90, -79, -68, -57, -46, -34, -23, -11,
    0, 11, 23, 34, 46, 57, 68, 79, 90, 101, 112, 123, 133, 144, 154, 164, 174, 183,
    193, 202, 211, 219, 228, 236, 244, 251, 258, 265, 272, 278, 284, 289, 295, 299, 304, 308,
    312, 315, 318, 321, 323, 324, 326, 327, 327, 328, 327, 327, 326, 324, 323, 321, 318, 315,
    312, 308, 304, 299, 295, 289, 284, 278, 272, 265, 258, 251, 244, 236, 228, 219, 211, 202,
    193, 183, 174, 164, 154, 144, 133, 123, 112, 101, 90, 79, 68, 57, 46, 34, 23, 11,
    0, -11, -23, -34, -46, -57, -68, -79, -90, -101, -112, -123, -133, -144, -154, -164, -174, -183,
    -193, -202, -211, -219, -228, -236, -244, -251, -258, -265, -272, -278, -284, -289, -295, -299, -304, -308,
    -312, -315, -318, -321, -323, -324, -326, -327, -327, -328, -327, -327, -326, -324, -323, -321, -318, -315,
    -312, -308, -304, -299, -295, -289, -284, -278, -272, -265, -258, -251, -244, -236, -228, -219, -211, -202,
    -193, -183, -174, -164, -154, -144, -133, -123, -112, -101, -90, -79, -68, -57, -46, -34, -23, -11,
    0, 11, 23, 34, 46, 57, 68, 79, 90, 101, 112, 123, 133, 144, 154, 164, 174, 183,
    193, 202, 211, 219, 228, 236, 244, 251, 258, 265, 272, 278, 284, 289, 295, 299, 304, 308,
    312, 315, 318, 321, 323, 324, 326, 327, 327, 328, 327, 327, 326, 324, 323, 321, 318, 315,
    312, 308, 304, 299, 295, 289, 284, 278, 272, 265, 258, 251, 244, 236, 228, 219, 211, 202,
    193, 183, 174, 164, 154, 144, 133, 123, 112, 101, 90, 79, 68, 57, 46, 34, 23, 11
}

const int16 heartX[] = {
    0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 3, 4, 5, 6, 7, 8,
    10, 11, 13, 15, 17, 20, 22, 25, 28, 31, 34, 37, 41, 45, 49, 53, 57, 62,
    67, 71, 76, 82, 87, 93, 98, 104, 110, 116, 122, 128, 134, 141, 147, 154, 160, 167,
    173, 180, 187, 193, 200, 206, 213, 219, 226, 232, 238, 244, 250, 256, 261, 267, 272, 277,
    282, 287, 291, 295, 299, 303, 307, 310, 313, 316, 318, 320, 322, 324, 325, 326, 327, 328,
    328, 328, 327, 326, 325, 324, 322, 320, 318, 316, 313, 310, 307, 303, 299, 295, 291, 287,
    282, 277, 272, 267, 261, 256, 250, 244, 238, 232, 226, 219, 213, 206, 200, 193, 187, 180,
    173, 167, 160, 154, 147, 141, 134, 128, 122, 116, 110, 104, 98, 93, 87, 82, 76, 71,
    67, 62, 57, 53, 49, 45, 41, 37, 34, 31, 28, 25, 22, 20, 17, 15, 13, 11,
    10, 8, 7, 6, 5, 4, 3, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0,
    0, -0, -0, -0, -0, -0, -0, -1, -1, -1, -2, -2, -3, -4, -5, -6, -7, -8,
    -10, -11, -13, -15, -17, -20, -22, -25, -28, -31, -34, -37, -41, -45, -49, -53, -57, -62,
    -67, -71, -76, -82, -87, -93, -98, -104, -110, -116, -122, -128, -134, -141, -147, -154, -160, -167,
    -173, -180, -187, -193, -200, -206, -213, -219, -226, -232, -238, -244, -250, -256, -261, -267, -272, -277,
    -282, -287, -291, -295, -299, -303, -307, -310, -313, -316, -318, -320, -322, -324, -325, -326, -327, -328,
    -328, -328, -327, -326, -325, -324, -322, -320, -318, -316, -313, -310, -307, -303, -299, -295, -291, -287,
    -282, -277, -272, -267, -261, -256, -250, -244, -238, -232, -226, -219, -213, -206, -200, -193, -187, -180,
    -173, -167, -160, -154, -147, -141, -134, -128, -122, -116, -110, -104, -98, -93, -87, -82, -76, -71,
    -67, -62, -57, -53, -49, -45, -41, -37, -34, -31, -28, -25, -22, -20, -17, -15, -13, -11,
    -10, -8, -7, -6, -5, -4, -3, -2, -2, -1, -1, -1, -0, -0, -0, -0, -0, -0, -0
}

const int16 heartY[] = {
    -96, -96, -97, -97, -98, -99, -100, -102, -104, -106, -108, -110, -113, -115, -118, -121, -125, -128,
    -131, -135, -139, -143, -146, -150, -154, -158, -162, -166, -170, -174, -178, -182, -186, -190, -193, -197,
    -200, -203, -206, -209, -212, -215, -217, -219, -221, -223, -225, -226, -227, -228, -229, -229, -229, -229,
    -229, -228, -227, -226, -225, -223, -221, -219, -217, -214, -211, -208, -205, -201, -197, -193, -189, -185,
    -180, -176, -171, -166, -160, -155, -150, -144, -138, -132, -127, -121, -115, -108, -102, -96, -90, -83,
    -77, -71, -64, -58, -51, -45, -38, -32, -26, -19, -13, -7, -0, 6, 12, 18, 24, 30,
    37, 43, 49, 54, 60, 66, 72, 78, 83, 89, 95, 100, 106, 111, 117, 122, 128, 133,
    138, 144, 149, 154, 159, 164, 170, 175, 180, 185, 190, 195, 200, 205, 209, 214, 219, 224,
    228, 233, 238, 242, 246, 251, 255, 259, 263, 267, 271, 275, 279, 283, 286, 289, 293, 296,
    299, 302, 305, 307, 310, 312, 314, 316, 318, 320, 321, 323, 324, 325, 326, 326, 327, 327,
    327, 327, 327, 326, 326, 325, 324, 323, 321, 320, 318, 316, 314, 312, 310, 307, 305, 302,
    299, 296, 293, 289, 286, 283, 279, 275, 271, 267, 263, 259, 255, 251, 246, 242, 238, 233,
    228, 224, 219, 214, 209, 205, 200, 195, 190, 185, 180, 175, 170, 164, 159, 154, 149, 144,
    138, 133, 128, 122, 117, 111, 106, 100, 95, 89, 83, 78, 72, 66, 60, 54, 49, 43,
    37, 30, 24, 18, 12, 6, -0, -7, -13, -19, -26, -32, -38, -45, -51, -58, -64, -71,
    -77, -83, -90, -96, -102, -108, -115, -121, -127, -132, -138, -144, -150, -155, -160, -166, -171, -176,
    -180, -185, -189, -193, -197, -201, -205, -208, -211, -214, -217, -219, -221, -223, -225, -226, -227, -228,
    -229, -229, -229, -229, -229, -228, -227, -226, -225, -223, -221, -219, -217, -215, -212, -209, -206, -203,
    -200, -197, -193, -190, -186, -182, -178, -174, -170, -166, -162, -158, -154, -150, -146, -143, -139, -135,
    -131, -128, -125, -121, -118, -115, -113, -110, -108, -106, -104, -102, -100, -99, -98, -97, -97, -96, -96
}

const int16 sin[] = { 
	0, 6, 11, 17, 23, 29, 34, 40, 46, 51, 57, 63, 68, 74, 79, 85, 90, 96,
	101, 107, 112, 117, 123, 128, 133, 138, 144, 149, 154, 159, 164, 169, 174, 178, 183, 188,
	193, 197, 202, 206, 211, 215, 219, 223, 228, 232, 236, 240, 244, 247, 251, 255, 258, 262,
	265, 268, 272, 275, 278, 281, 284, 287, 289, 292, 295, 297, 299, 302, 304, 306, 308, 310,
	312, 313, 315, 317, 318, 319, 321, 322, 323, 324, 324, 325, 326, 326, 327, 327, 327, 328,
	328, 328, 327, 327, 327, 326, 326, 325, 324, 324, 323, 322, 321, 319, 318, 317, 315, 313,
	312, 310, 308, 306, 304, 302, 299, 297, 295, 292, 289, 287, 284, 281, 278, 275, 272, 268,
	265, 262, 258, 255, 251, 247, 244, 240, 236, 232, 228, 223, 219, 215, 211, 206, 202, 197,
	193, 188, 183, 178, 174, 169, 164, 159, 154, 149, 144, 138, 133, 128, 123, 117, 112, 107,
	101, 96, 90, 85, 79, 74, 68, 63, 57, 51, 46, 40, 34, 29, 23, 17, 11, 6,
	0, -6, -11, -17, -23, -29, -34, -40, -46, -51, -57, -63, -68, -74, -79, -85, -90, -96,
	-101, -107, -112, -117, -123, -128, -133, -138, -144, -149, -154, -159, -164, -169, -174, -178, -183, -188,
	-193, -197, -202, -206, -211, -215, -219, -223, -228, -232, -236, -240, -244, -247, -251, -255, -258, -262,
	-265, -268, -272, -275, -278, -281, -284, -287, -289, -292, -295, -297, -299, -302, -304, -306, -308, -310,
	-312, -313, -315, -317, -318, -319, -321, -322, -323, -324, -324, -325, -326, -326, -327, -327, -327, -328,
	-328, -328, -327, -327, -327, -326, -326, -325, -324, -324, -323, -322, -321, -319, -318, -317, -315, -313,
	-312, -310, -308, -306, -304, -302, -299, -297, -295, -292, -289, -287, -284, -281, -278, -275, -272, -268,
	-265, -262, -258, -255, -251, -247, -244, -240, -236, -232, -228, -223, -219, -215, -211, -206, -202, -197,
	-193, -188, -183, -178, -174, -169, -164, -159, -154, -149, -144, -138, -133, -128, -123, -117, -112, -107,
	-101, -96, -90, -85, -79, -74, -68, -63, -57, -51, -46, -40, -34, -29, -23, -17, -11, -6
}

const int16 cos[] = { 
	328, 328, 327, 327, 327, 326, 326, 325, 324, 324, 323, 322, 321, 319, 318, 317, 315, 313,
	312, 310, 308, 306, 304, 302, 299, 297, 295, 292, 289, 287, 284, 281, 278, 275, 272, 268,
	265, 262, 258, 255, 251, 247, 244, 240, 236, 232, 228, 223, 219, 215, 211, 206, 202, 197,
	193, 188, 183, 178, 174, 169, 164, 159, 154, 149, 144, 138, 133, 128, 123, 117, 112, 107,
	101, 96, 90, 85, 79, 74, 68, 63, 57, 51, 46, 40, 34, 29, 23, 17, 11, 6,
	0, -6, -11, -17, -23, -29, -34, -40, -46, -51, -57, -63, -68, -74, -79, -85, -90, -96,
	-101, -107, -112, -117, -123, -128, -133, -138, -144, -149, -154, -159, -164, -169, -174, -178, -183, -188,
	-193, -197, -202, -206, -211, -215, -219, -223, -228, -232, -236, -240, -244, -247, -251, -255, -258, -262,
	-265, -268, -272, -275, -278, -281, -284, -287, -289, -292, -295, -297, -299, -302, -304, -306, -308, -310,
	-312, -313, -315, -317, -318, -319, -321, -322, -323, -324, -324, -325, -326, -326, -327, -327, -327, -328,
	-328, -328, -327, -327, -327, -326, -326, -325, -324, -324, -323, -322, -321, -319, -318, -317, -315, -313,
	-312, -310, -308, -306, -304, -302, -299, -297, -295, -292, -289, -287, -284, -281, -278, -275, -272, -268,
	-265, -262, -258, -255, -251, -247, -244, -240, -236, -232, -228, -223, -219, -215, -211, -206, -202, -197,
	-193, -188, -183, -178, -174, -169, -164, -159, -154, -149, -144, -138, -133, -128, -123, -117, -112, -107,
	-101, -96, -90, -85, -79, -74, -68, -63, -57, -51, -46, -40, -34, -29, -23, -17, -11, -6,
	-0, 6, 11, 17, 23, 29, 34, 40, 46, 51, 57, 63, 68, 74, 79, 85, 90, 96,
	101, 107, 112, 117, 123, 128, 133, 138, 144, 149, 154, 159, 164, 169, 174, 178, 183, 188,
	193, 197, 202, 206, 211, 215, 219, 223, 228, 232, 236, 240, 244, 247, 251, 255, 258, 262,
	265, 268, 272, 275, 278, 281, 284, 287, 289, 292, 295, 297, 299, 302, 304, 306, 308, 310,
	312, 313, 315, 317, 318, 319, 321, 322, 323, 324, 324, 325, 326, 326, 327, 327, 327, 328
}

// sin(x)
const int16 sin2[] = { 
	328, 328, 327, 327, 327, 326, 326, 325, 324, 324, 323, 322, 321, 319, 318, 317, 315, 313,
	312, 310, 308, 306, 304, 302, 299, 297, 295, 292, 289, 287, 284, 281, 278, 275, 272, 268,
	265, 262, 258, 255, 251, 247, 244, 240, 236, 232, 228, 223, 219, 215, 211, 206, 202, 197,
	193, 188, 183, 178, 174, 169, 164, 159, 154, 149, 144, 138, 133, 128, 123, 117, 112, 107,
	101, 96, 90, 85, 79, 74, 68, 63, 57, 51, 46, 40, 34, 29, 23, 17, 11, 6,
	0, -6, -11, -17, -23, -29, -34, -40, -46, -51, -57, -63, -68, -74, -79, -85, -90, -96,
	-101, -107, -112, -117, -123, -128, -133, -138, -144, -149, -154, -159, -164, -169, -174, -178, -183, -188,
	-193, -197, -202, -206, -211, -215, -219, -223, -228, -232, -236, -240, -244, -247, -251, -255, -258, -262,
	-265, -268, -272, -275, -278, -281, -284, -287, -289, -292, -295, -297, -299, -302, -304, -306, -308, -310,
	-312, -313, -315, -317, -318, -319, -321, -322, -323, -324, -324, -325, -326, -326, -327, -327, -327, -328,
	-328, -328, -327, -327, -327, -326, -326, -325, -324, -324, -323, -322, -321, -319, -318, -317, -315, -313,
	-312, -310, -308, -306, -304, -302, -299, -297, -295, -292, -289, -287, -284, -281, -278, -275, -272, -268,
	-265, -262, -258, -255, -251, -247, -244, -240, -236, -232, -228, -223, -219, -215, -211, -206, -202, -197,
	-193, -188, -183, -178, -174, -169, -164, -159, -154, -149, -144, -138, -133, -128, -123, -117, -112, -107,
	-101, -96, -90, -85, -79, -74, -68, -63, -57, -51, -46, -40, -34, -29, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 29, 34, 40, 46, 51, 57, 63, 68, 74, 79, 85, 90, 96,
	101, 107, 112, 117, 123, 128, 133, 138, 144, 149, 154, 159, 164, 169, 174, 178, 183, 188,
	193, 197, 202, 206, 211, 215, 219, 223, 228, 232, 236, 240, 244, 247, 251, 255, 258, 262,
	265, 268, 272, 275, 278, 281, 284, 287, 289, 292, 295, 297, 299, 302, 304, 306, 308, 310,
	312, 313, 315, 317, 318, 319, 321, 322, 323, 324, 324, 325, 326, 326, 327, 327, 327, 328
}

// cos(x)
const int16 cos2[] = { 
	0, -6, -11, -17, -23, -29, -34, -40, -46, -51, -57, -63, -68, -74, -79, -85, -90, -96,
	-101, -107, -112, -117, -123, -128, -133, -138, -144, -149, -154, -159, -164, -169, -174, -178, -183, -188,
	-193, -197, -202, -206, -211, -215, -219, -223, -228, -232, -236, -240, -244, -247, -251, -255, -258, -262,
	-265, -268, -272, -275, -278, -281, -284, -287, -289, -292, -295, -297, -299, -302, -304, -306, -308, -310,
	-312, -313, -315, -317, -318, -319, -321, -322, -323, -324, -324, -325, -326, -326, -327, -327, -327, -328,
	-328, -328, -327, -327, -327, -326, -326, -325, -324, -324, -323, -322, -321, -319, -318, -317, -315, -313,
	-312, -310, -308, -306, -304, -302, -299, -297, -295, -292, -289, -287, -284, -281, -278, -275, -272, -268,
	-265, -262, -258, -255, -251, -247, -244, -240, -236, -232, -228, -223, -219, -215, -211, -206, -202, -197,
	-193, -188, -183, -178, -174, -169, -164, -159, -154, -149, -144, -138, -133, -128, -123, -117, -112, -107,
	-101, -96, -90, -85, -79, -74, -68, -63, -57, -51, -46, -40, -34, -29, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 29, 34, 40, 46, 51, 57, 63, 68, 74, 79, 85, 90, 96,
	101, 107, 112, 117, 123, 128, 133, 138, 144, 149, 154, 159, 164, 169, 174, 178, 183, 188,
	193, 197, 202, 206, 211, 215, 219, 223, 228, 232, 236, 240, 244, 247, 251, 255, 258, 262,
	265, 268, 272, 275, 278, 281, 284, 287, 289, 292, 295, 297, 299, 302, 304, 306, 308, 310,
	312, 313, 315, 317, 318, 319, 321, 322, 323, 324, 324, 325, 326, 326, 327, 327, 327, 328,
	328, 328, 327, 327, 327, 326, 326, 325, 324, 324, 323, 322, 321, 319, 318, 317, 315, 313,
	312, 310, 308, 306, 304, 302, 299, 297, 295, 292, 289, 287, 284, 281, 278, 275, 272, 268,
	265, 262, 258, 255, 251, 247, 244, 240, 236, 232, 228, 223, 219, 215, 211, 206, 202, 197,
	193, 188, 183, 178, 174, 169, 164, 159, 154, 149, 144, 138, 133, 128, 123, 117, 112, 107,
	101, 96, 90, 85, 79, 74, 68, 63, 57, 51, 46, 40, 34, 29, 23, 17, 11, 6
}

const int16 lemniscateX[] = {
	0, -3, -6, -9, -11, -14, -17, -20, -23, -26, -29, -32, -35, -38, -41, -44, -47, -50,
	-53, -56, -60, -63, -66, -69, -73, -76, -79, -83, -86, -90, -94, -97, -101, -105, -109, -112,
	-116, -120, -124, -129, -133, -137, -141, -146, -150, -154, -159, -164, -168, -173, -178, -182, -187, -192,
	-197, -202, -207, -212, -217, -222, -227, -232, -237, -242, -247, -252, -257, -262, -266, -271, -276, -280,
	-284, -289, -293, -297, -300, -304, -307, -310, -313, -316, -318, -320, -322, -324, -325, -326, -327, -328,
	-328, -328, -327, -326, -325, -324, -322, -320, -318, -316, -313, -310, -307, -304, -300, -297, -293, -289,
	-284, -280, -276, -271, -266, -262, -257, -252, -247, -242, -237, -232, -227, -222, -217, -212, -207, -202,
	-197, -192, -187, -182, -178, -173, -168, -164, -159, -154, -150, -146, -141, -137, -133, -129, -124, -120,
	-116, -112, -109, -105, -101, -97, -94, -90, -86, -83, -79, -76, -73, -69, -66, -63, -60, -56,
	-53, -50, -47, -44, -41, -38, -35, -32, -29, -26, -23, -20, -17, -14, -11, -9, -6, -3,
	0, 3, 6, 9, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50,
	53, 56, 60, 63, 66, 69, 73, 76, 79, 83, 86, 90, 94, 97, 101, 105, 109, 112,
	116, 120, 124, 129, 133, 137, 141, 146, 150, 154, 159, 164, 168, 173, 178, 182, 187, 192,
	197, 202, 207, 212, 217, 222, 227, 232, 237, 242, 247, 252, 257, 262, 266, 271, 276, 280,
	284, 289, 293, 297, 300, 304, 307, 310, 313, 316, 318, 320, 322, 324, 325, 326, 327, 328,
	328, 328, 327, 326, 325, 324, 322, 320, 318, 316, 313, 310, 307, 304, 300, 297, 293, 289,
	284, 280, 276, 271, 266, 262, 257, 252, 247, 242, 237, 232, 227, 222, 217, 212, 207, 202,
	197, 192, 187, 182, 178, 173, 168, 164, 159, 154, 150, 146, 141, 137, 133, 129, 124, 120,
	116, 112, 109, 105, 101, 97, 94, 90, 86, 83, 79, 76, 73, 69, 66, 63, 60, 56,
	53, 50, 47, 44, 41, 38, 35, 32, 29, 26, 23, 20, 17, 14, 11, 9, 6, 3
}

const int8 lemniscateY[] = {
	0, -3, -6, -9, -11, -14, -17, -20, -23, -26, -28, -31, -34, -37, -40, -42, -45, -48,
	-51, -53, -56, -59, -61, -64, -66, -69, -71, -74, -76, -79, -81, -83, -86, -88, -90, -92,
	-94, -96, -98, -100, -102, -103, -105, -106, -108, -109, -110, -112, -113, -113, -114, -115, -115, -116,
	-116, -116, -116, -115, -115, -114, -114, -112, -111, -110, -108, -106, -104, -102, -100, -97, -94, -91,
	-88, -84, -81, -77, -73, -68, -64, -59, -54, -49, -44, -39, -34, -28, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 28, 34, 39, 44, 49, 54, 59, 64, 68, 73, 77, 81, 84,
	88, 91, 94, 97, 100, 102, 104, 106, 108, 110, 111, 112, 114, 114, 115, 115, 116, 116,
	116, 116, 115, 115, 114, 113, 113, 112, 110, 109, 108, 106, 105, 103, 102, 100, 98, 96,
	94, 92, 90, 88, 86, 83, 81, 79, 76, 74, 71, 69, 66, 64, 61, 59, 56, 53,
	51, 48, 45, 42, 40, 37, 34, 31, 28, 26, 23, 20, 17, 14, 11, 9, 6, 3,
	0, -3, -6, -9, -11, -14, -17, -20, -23, -26, -28, -31, -34, -37, -40, -42, -45, -48,
	-51, -53, -56, -59, -61, -64, -66, -69, -71, -74, -76, -79, -81, -83, -86, -88, -90, -92,
	-94, -96, -98, -100, -102, -103, -105, -106, -108, -109, -110, -112, -113, -113, -114, -115, -115, -116,
	-116, -116, -116, -115, -115, -114, -114, -112, -111, -110, -108, -106, -104, -102, -100, -97, -94, -91,
	-88, -84, -81, -77, -73, -68, -64, -59, -54, -49, -44, -39, -34, -28, -23, -17, -11, -6,
	0, 6, 11, 17, 23, 28, 34, 39, 44, 49, 54, 59, 64, 68, 73, 77, 81, 84,
	88, 91, 94, 97, 100, 102, 104, 106, 108, 110, 111, 112, 114, 114, 115, 115, 116, 116,
	116, 116, 115, 115, 114, 113, 113, 112, 110, 109, 108, 106, 105, 103, 102, 100, 98, 96,
	94, 92, 90, 88, 86, 83, 81, 79, 76, 74, 71, 69, 66, 64, 61, 59, 56, 53,
	51, 48, 45, 42, 40, 37, 34, 31, 28, 26, 23, 20, 17, 14, 11, 9, 6, 3
}

const int16 roseX[] = {
	0, -29, -57, -85, -112, -138, -163, -187, -209, -229, -247, -263, -278, -289, -299, -306, -310, -312,
	-312, -309, -303, -295, -285, -273, -259, -243, -226, -206, -186, -164, -142, -119, -95, -71, -47, -23,
	0, 23, 45, 66, 86, 105, 122, 137, 152, 164, 174, 183, 190, 195, 198, 199, 199, 196,
	193, 187, 180, 172, 163, 153, 142, 130, 118, 105, 92, 79, 67, 54, 42, 30, 19, 9,
	0, -8, -16, -22, -27, -31, -34, -36, -37, -36, -35, -33, -30, -26, -21, -17, -11, -6,
	0, 6, 11, 17, 21, 26, 30, 33, 35, 36, 37, 36, 34, 31, 27, 22, 16, 8,
	0, -9, -19, -30, -42, -54, -67, -79, -92, -105, -118, -130, -142, -153, -163, -172, -180, -187,
	-193, -196, -199, -199, -198, -195, -190, -183, -174, -164, -152, -137, -122, -105, -86, -66, -45, -23,
	0, 23, 47, 71, 95, 119, 142, 164, 186, 206, 226, 243, 259, 273, 285, 295, 303, 309,
	312, 312, 310, 306, 299, 289, 278, 263, 247, 229, 209, 187, 163, 138, 112, 85, 57, 29,
	0, -29, -57, -85, -112, -138, -163, -187, -209, -229, -247, -263, -278, -289, -299, -306, -310, -312,
	-312, -309, -303, -295, -285, -273, -259, -243, -226, -206, -186, -164, -142, -119, -95, -71, -47, -23,
	0, 23, 45, 66, 86, 105, 122, 137, 152, 164, 174, 183, 190, 195, 198, 199, 199, 196,
	193, 187, 180, 172, 163, 153, 142, 130, 118, 105, 92, 79, 67, 54, 42, 30, 19, 9,
	0, -8, -16, -22, -27, -31, -34, -36, -37, -36, -35, -33, -30, -26, -21, -17, -11, -6,
	0, 6, 11, 17, 21, 26, 30, 33, 35, 36, 37, 36, 34, 31, 27, 22, 16, 8,
	0, -9, -19, -30, -42, -54, -67, -79, -92, -105, -118, -130, -142, -153, -163, -172, -180, -187,
	-193, -196, -199, -199, -198, -195, -190, -183, -174, -164, -152, -137, -122, -105, -86, -66, -45, -23,
	0, 23, 47, 71, 95, 119, 142, 164, 186, 206, 226, 243, 259, 273, 285, 295, 303, 309,
	312, 312, 310, 306, 299, 289, 278, 263, 247, 229, 209, 187, 163, 138, 112, 85, 57, 29
}

const int16 roseY[] = {
    0, 0, -2, -4, -8, -12, -17, -23, -29, -36, -44, -51, -59, -67, -74, -82, -89, -95,
    -101, -106, -110, -113, -115, -116, -115, -113, -110, -105, -99, -91, -82, -71, -59, -46, -32, -16,
    0, 17, 35, 53, 72, 91, 110, 128, 146, 164, 181, 196, 211, 224, 236, 246, 254, 261,
    265, 267, 268, 265, 261, 255, 246, 235, 222, 206, 189, 170, 150, 127, 104, 79, 53, 27,
    0, -27, -55, -82, -109, -135, -160, -184, -207, -229, -249, -266, -282, -296, -307, -316, -322, -326,
    -328, -326, -322, -316, -307, -296, -282, -266, -249, -229, -207, -184, -160, -135, -109, -82, -55, -27,
    0, 27, 53, 79, 104, 127, 150, 170, 189, 206, 222, 235, 246, 255, 261, 265, 268, 267,
    265, 261, 254, 246, 236, 224, 211, 196, 181, 164, 146, 128, 110, 91, 72, 53, 35, 17,
    0, -16, -32, -46, -59, -71, -82, -91, -99, -105, -110, -113, -115, -116, -115, -113, -110, -106,
    -101, -95, -89, -82, -74, -67, -59, -51, -44, -36, -29, -23, -17, -12, -8, -4, -2, 0,
    0, 0, -2, -4, -8, -12, -17, -23, -29, -36, -44, -51, -59, -67, -74, -82, -89, -95,
    -101, -106, -110, -113, -115, -116, -115, -113, -110, -105, -99, -91, -82, -71, -59, -46, -32, -16,
    0, 17, 35, 53, 72, 91, 110, 128, 146, 164, 181, 196, 211, 224, 236, 246, 254, 261,
    265, 267, 268, 265, 261, 255, 246, 235, 222, 206, 189, 170, 150, 127, 104, 79, 53, 27,
    0, -27, -55, -82, -109, -135, -160, -184, -207, -229, -249, -266, -282, -296, -307, -316, -322, -326,
    -328, -326, -322, -316, -307, -296, -282, -266, -249, -229, -207, -184, -160, -135, -109, -82, -55, -27,
    0, 27, 53, 79, 104, 127, 150, 170, 189, 206, 222, 235, 246, 255, 261, 265, 268, 267,
    265, 261, 254, 246, 236, 224, 211, 196, 181, 164, 146, 128, 110, 91, 72, 53, 35, 17,
    0, -16, -32, -46, -59, -71, -82, -91, -99, -105, -110, -113, -115, -116, -115, -113, -110, -106,
    -101, -95, -89, -82, -74, -67, -59, -51, -44, -36, -29, -23, -17, -12, -8, -4, -2, 0
}

const int16 diamondX[] = {
    0, 4, 7, 11, 15, 18, 22, 26, 29, 33, 37, 40, 44, 48, 52, 55, 59, 63,
    66, 70, 74, 77, 81, 85, 88, 92, 96, 99, 103, 107, 110, 114, 118, 121, 125, 129,
    133, 136, 140, 144, 147, 151, 155, 158, 162, 166, 169, 173, 177, 180, 184, 188, 191, 195,
    199, 202, 206, 210, 214, 217, 221, 225, 228, 232, 236, 239, 243, 247, 250, 254, 258, 261,
    265, 269, 272, 276, 280, 283, 287, 291, 295, 298, 302, 306, 309, 313, 317, 320, 324, 328,
    328, 324, 320, 317, 313, 309, 306, 302, 298, 295, 291, 287, 283, 280, 276, 272, 269, 265, 
    261, 258, 254, 250, 247, 243, 239, 236, 232, 228, 225, 221, 217, 214, 210, 206, 202, 199,
    195, 191, 188, 184, 180, 177, 173, 169, 166, 162, 158, 155, 151, 147, 144, 140, 136, 133,
    129, 125, 121, 118, 114, 110, 107, 103, 99, 96, 92, 88, 85, 81, 77, 74, 70, 66,
    63, 59, 55, 52, 48, 44, 40, 37, 33, 29, 26, 22, 18, 15, 11, 7, 4, 0,
    0, -4, -7, -11, -15, -18, -22, -26, -29, -33, -37, -40, -44, -48, -52, -55, -59, -63,
    -66, -70, -74, -77, -81, -85, -88, -92, -96, -99, -103, -107, -110, -114, -118, -121, -125, -129,
    -133, -136, -140, -144, -147, -151, -155, -158, -162, -166, -169, -173, -177, -180, -184, -188, -191, -195,
    -199, -202, -206, -210, -214, -217, -221, -225, -228, -232, -236, -239, -243, -247, -250, -254, -258, -261,
    -265, -269, -272, -276, -280, -283, -287, -291, -295, -298, -302, -306, -309, -313, -317, -320, -324, -328,
    -328, -324, -320, -317, -313, -309, -306, -302, -298, -295, -291, -287, -283, -280, -276, -272, -269, -265,
    -261, -258, -254, -250, -247, -243, -239, -236, -232, -228, -225, -221, -217, -214, -210, -206, -202, -199,
    -195, -191, -188, -184, -180, -177, -173, -169, -166, -162, -158, -155, -151, -147, -144, -140, -136, -133,
    -129, -125, -121, -118, -114, -110, -107, -103, -99, -96, -92, -88, -85, -81, -77, -74, -70, -66,
    -63, -59, -55, -52, -48, -44, -40, -37, -33, -29, -26, -22, -18, -15, -11, -7, -4, 0
}

const int16 diamondY[] = {
    328, 324, 320, 317, 313, 309, 306, 302, 298, 295, 291, 287, 283, 280, 276, 272, 269, 265, 
    261, 258, 254, 250, 247, 243, 239, 236, 232, 228, 225, 221, 217, 214, 210, 206, 202, 199,
    195, 191, 188, 184, 180, 177, 173, 169, 166, 162, 158, 155, 151, 147, 144, 140, 136, 133,
    129, 125, 121, 118, 114, 110, 107, 103, 99, 96, 92, 88, 85, 81, 77, 74, 70, 66,
    63, 59, 55, 52, 48, 44, 40, 37, 33, 29, 26, 22, 18, 15, 11, 7, 4, 0,
    0, -4, -7, -11, -15, -18, -22, -26, -29, -33, -37, -40, -44, -48, -52, -55, -59, -63,
    -66, -70, -74, -77, -81, -85, -88, -92, -96, -99, -103, -107, -110, -114, -118, -121, -125, -129,
    -133, -136, -140, -144, -147, -151, -155, -158, -162, -166, -169, -173, -177, -180, -184, -188, -191, -195,
    -199, -202, -206, -210, -214, -217, -221, -225, -228, -232, -236, -239, -243, -247, -250, -254, -258, -261,
    -265, -269, -272, -276, -280, -283, -287, -291, -295, -298, -302, -306, -309, -313, -317, -320, -324, -328,
    -328, -324, -320, -317, -313, -309, -306, -302, -298, -295, -291, -287, -283, -280, -276, -272, -269, -265,
    -261, -258, -254, -250, -247, -243, -239, -236, -232, -228, -225, -221, -217, -214, -210, -206, -202, -199,
    -195, -191, -188, -184, -180, -177, -173, -169, -166, -162, -158, -155, -151, -147, -144, -140, -136, -133,
    -129, -125, -121, -118, -114, -110, -107, -103, -99, -96, -92, -88, -85, -81, -77, -74, -70, -66,
    -63, -59, -55, -52, -48, -44, -40, -37, -33, -29, -26, -22, -18, -15, -11, -7, -4, 0,
    0, 4, 7, 11, 15, 18, 22, 26, 29, 33, 37, 40, 44, 48, 52, 55, 59, 63,
    66, 70, 74, 77, 81, 85, 88, 92, 96, 99, 103, 107, 110, 114, 118, 121, 125, 129,
    133, 136, 140, 144, 147, 151, 155, 158, 162, 166, 169, 173, 177, 180, 184, 188, 191, 195,
    199, 202, 206, 210, 214, 217, 221, 225, 228, 232, 236, 239, 243, 247, 250, 254, 258, 261,
    265, 269, 272, 276, 280, 283, 287, 291, 295, 298, 302, 306, 309, 313, 317, 320, 324, 328
}

const int16 horizonX[] = {
    0, 4, 7, 11, 15, 18, 22, 26, 29, 33, 37, 40, 44, 48, 52, 55, 59, 63,
    66, 70, 74, 77, 81, 85, 88, 92, 96, 99, 103, 107, 110, 114, 118, 121, 125, 129,
    133, 136, 140, 144, 147, 151, 155, 158, 162, 166, 169, 173, 177, 180, 184, 188, 191, 195,
    199, 202, 206, 210, 214, 217, 221, 225, 228, 232, 236, 239, 243, 247, 250, 254, 258, 261,
    265, 269, 272, 276, 280, 283, 287, 291, 295, 298, 302, 306, 309, 313, 317, 320, 324, 328,
    328, 324, 320, 317, 313, 309, 306, 302, 298, 295, 291, 287, 283, 280, 276, 272, 269, 265, 
    261, 258, 254, 250, 247, 243, 239, 236, 232, 228, 225, 221, 217, 214, 210, 206, 202, 199,
    195, 191, 188, 184, 180, 177, 173, 169, 166, 162, 158, 155, 151, 147, 144, 140, 136, 133,
    129, 125, 121, 118, 114, 110, 107, 103, 99, 96, 92, 88, 85, 81, 77, 74, 70, 66,
    63, 59, 55, 52, 48, 44, 40, 37, 33, 29, 26, 22, 18, 15, 11, 7, 4, 0,
    0, -4, -7, -11, -15, -18, -22, -26, -29, -33, -37, -40, -44, -48, -52, -55, -59, -63,
    -66, -70, -74, -77, -81, -85, -88, -92, -96, -99, -103, -107, -110, -114, -118, -121, -125, -129,
    -133, -136, -140, -144, -147, -151, -155, -158, -162, -166, -169, -173, -177, -180, -184, -188, -191, -195,
    -199, -202, -206, -210, -214, -217, -221, -225, -228, -232, -236, -239, -243, -247, -250, -254, -258, -261,
    -265, -269, -272, -276, -280, -283, -287, -291, -295, -298, -302, -306, -309, -313, -317, -320, -324, -328,
    -328, -324, -320, -317, -313, -309, -306, -302, -298, -295, -291, -287, -283, -280, -276, -272, -269, -265,
    -261, -258, -254, -250, -247, -243, -239, -236, -232, -228, -225, -221, -217, -214, -210, -206, -202, -199,
    -195, -191, -188, -184, -180, -177, -173, -169, -166, -162, -158, -155, -151, -147, -144, -140, -136, -133,
    -129, -125, -121, -118, -114, -110, -107, -103, -99, -96, -92, -88, -85, -81, -77, -74, -70, -66,
    -63, -59, -55, -52, -48, -44, -40, -37, -33, -29, -26, -22, -18, -15, -11, -7, -4, 0
}

const int16 flowerX[] = {
	-1, -19, -39, -60, -82, -105, -128, -150, -172, -192, -211, -228, -244, -256, -267, -275, -281, -285,
	-287, -287, -286, -284, -281, -278, -275, -272, -269, -268, -268, -268, -271, -274, -279, -284, -291, -298,
	-304, -311, -317, -322, -326, -328, -327, -324, -318, -309, -297, -282, -264, -244, -221, -195, -169, -140,
	-112, -83, -54, -27, -2, 21, 42, 59, 73, 82, 88, 89, 87, 80, 70, 56, 39, 20,
	-2, -25, -49, -74, -98, -122, -145, -166, -185, -202, -217, -228, -237, -244, -247, -249, -248, -245,
	-240, -234, -227, -220, -212, -204, -196, -188, -182, -176, -170, -166, -162, -159, -157, -155, -154, -152,
	-150, -148, -146, -143, -139, -134, -128, -122, -114, -106, -97, -87, -77, -67, -57, -47, -38, -29,
	-21, -15, -9, -4, 0, 2, 4, 4, 4, 3, 2, 0, -2, -3, -4, -4, -4, -2,
	0, 4, 9, 15, 21, 29, 38, 47, 57, 67, 77, 87, 97, 106, 114, 122, 128, 134,
	139, 143, 146, 148, 150, 152, 154, 155, 157, 159, 162, 166, 170, 176, 182, 188, 196, 204,
	212, 220, 227, 234, 240, 245, 248, 249, 247, 244, 237, 228, 217, 202, 185, 166, 145, 122,
	98, 74, 49, 25, 2, -20, -39, -56, -70, -80, -87, -89, -88, -82, -73, -59, -42, -21,
	2, 27, 54, 83, 112, 140, 169, 195, 221, 244, 264, 282, 297, 309, 318, 324, 327, 328,
	326, 322, 317, 311, 304, 298, 291, 284, 279, 274, 271, 268, 268, 268, 269, 272, 275, 278,
	281, 284, 286, 287, 287, 285, 281, 275, 267, 256, 244, 228, 211, 192, 172, 150, 128, 105,
	82, 60, 39, 19, 1, -15, -28, -39, -47, -53, -55, -55, -53, -48, -41, -32, -22, -11,
	1, 13, 25, 37, 48, 57, 66, 73, 79, 83, 86, 87, 87, 85, 82, 79, 74, 68,
	63, 57, 50, 44, 38, 32, 26, 20, 15, 10, 5, 0, -5, -10, -15, -20, -26, -32,
	-38, -44, -50, -57, -63, -68, -74, -79, -82, -85, -87, -87, -86, -83, -79, -73, -66, -57,
	-48, -37, -25, -13, -1, 11, 22, 32, 41, 48, 53, 55, 55, 53, 47, 39, 28, 15
}

const int16 flowerY[] = {
	1, 20, 39, 58, 77, 94, 111, 126, 139, 150, 159, 166, 171, 173, 173, 172, 169, 165,
	159, 153, 146, 139, 131, 124, 117, 110, 103, 98, 92, 87, 83, 79, 75, 71, 67, 63,
	59, 55, 50, 45, 40, 34, 29, 23, 17, 11, 5, 0, -5, -9, -12, -14, -15, -15,
	-14, -12, -9, -5, 0, 5, 10, 15, 19, 24, 27, 29, 30, 29, 27, 23, 17, 9,
	-1, -12, -25, -39, -55, -71, -87, -104, -120, -136, -152, -166, -179, -190, -200, -209, -215, -220,
	-224, -226, -227, -227, -227, -226, -225, -224, -224, -225, -226, -228, -232, -236, -242, -248, -256, -263,
	-271, -279, -286, -293, -298, -301, -302, -301, -297, -291, -281, -268, -253, -235, -213, -190, -165, -138,
	-110, -82, -54, -27, -2, 22, 43, 61, 75, 86, 92, 94, 92, 86, 75, 61, 43, 22,
	-2, -27, -54, -82, -110, -138, -165, -190, -213, -235, -253, -268, -281, -291, -297, -301, -302, -301,
	-298, -293, -286, -279, -271, -263, -256, -248, -242, -236, -232, -228, -226, -225, -224, -224, -225, -226,
	-227, -227, -227, -226, -224, -220, -215, -209, -200, -190, -179, -166, -152, -136, -120, -104, -87, -71,
	-55, -39, -25, -12, -1, 9, 17, 23, 27, 29, 30, 29, 27, 24, 19, 15, 10, 5,
	0, -5, -9, -12, -14, -15, -15, -14, -12, -9, -5, 0, 5, 11, 17, 23, 29, 34,
	40, 45, 50, 55, 59, 63, 67, 71, 75, 79, 83, 87, 92, 98, 103, 110, 117, 124,
	131, 139, 146, 153, 159, 165, 169, 172, 173, 173, 171, 166, 159, 150, 139, 126, 111, 94,
	77, 58, 39, 20, 1, -16, -32, -47, -58, -67, -73, -76, -75, -71, -63, -52, -37, -19,
	2, 24, 49, 75, 102, 129, 156, 182, 206, 229, 250, 268, 284, 297, 308, 315, 320, 322,
	322, 321, 317, 313, 308, 302, 297, 292, 288, 285, 283, 282, 283, 285, 288, 292, 297, 302,
	308, 313, 317, 321, 322, 322, 320, 315, 308, 297, 284, 268, 250, 229, 206, 182, 156, 129,
	102, 75, 49, 24, 2, -19, -37, -52, -63, -71, -75, -76, -73, -67, -58, -47, -32, -16
}
 